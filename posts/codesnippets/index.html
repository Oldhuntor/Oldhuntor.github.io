<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Bayesian Cointegration codes | Xuanhao&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="Cointegration strategy backtesting framework
from backtest_multi_symbols import Broker, BarData, Backtestor, Position, DailyBar
from collections import deque
from statsmodels.tsa.stattools import coint
import pandas as pd
import numpy as np
from itertools import combinations
from sklearn.linear_model import LinearRegression
from statsmodels.tsa.stattools import adfuller

from model_new.bayesian_regression import bayesian_rolling_window
from model_new.jointCov2 import fit_HGP
from model_new.BayesGAM import bayesian_gam_with_splines
from model_new.BSTS import bsts_fit



class Log:
    def __init__(self, broker: Broker):
        self.resultPath = &#39;backTestResult/backtestLog&#39;
        self.logs = []
        self.broker = broker

    def logging(self, bars: dict):
        data = {}
        for symbol in bars:
            data[f&#34;close_{symbol}&#34;] = bars[symbol].close
            pos = self.broker.positions.get(symbol, 0)
            if pos != 0:
                data[f&#34;position_{symbol}&#34;] = self.broker.positions[symbol].volume
                data[f&#34;position_{symbol}_worth&#34;] = self.broker.positions[symbol].volume * bars[symbol].close

            data[&#39;time&#39;] = bars[symbol].time

        equity = self.broker.calculate_total_account_equity(bars)
        data[&#34;equity&#34;] = equity
        data[&#39;cash&#39;] = self.broker.cash
        self.logs.append(data)

    def save_logs(self):
        df = pd.DataFrame(self.logs)
        # df.to_csv(self.resultPath &#43; &#39;.csv&#39;, index=False)


class BacktestorPairTrading(Backtestor):
    def __init__(self, broker: Broker, strategy, log, start, end):
        super().__init__(broker, strategy, log, start, end)
        self.log: Log = log

    def run_backtest(self):
        for i in range(self.data_length):
            bars = {}
            for symbol in self.symbols:
                data = self.data[f&#39;{symbol}&#39;].iloc[i]
                bar = BarData(data[&#39;timestamp&#39;], data[&#39;open&#39;], data[&#39;high&#39;], data[&#39;low&#39;], ((data[&#39;close&#39;])),
                              data[&#39;volume&#39;])
                bars[symbol] = bar
            self.strategy.processBar(bars)
            self.log.logging(bars)
            equity = self.broker.calculate_total_account_equity(bars)
            accountPNL = equity - self.strategy.initial_balance
            if accountPNL/self.strategy.initial_balance &lt; -self.strategy.stop_loss:
                print(f&#34;stop loss at {self.strategy.stop_loss} !!!&#34;)
                break

        self.on_close(bars)
        self.log.save_logs()

    def on_close(self, bars):
        if self.strategy.is_open:
            print(&#39;out of time force close&#39;)
            self.strategy.close_position_new(bars, ignore_diff=True)


class Cointegration:
    def __init__(self, broker: Broker, setting: dict):
        self.short_leg = setting[&#39;short_leg&#39;]
        self.long_leg = setting[&#39;long_leg&#39;]
        self.open_margin = setting[&#39;open_margin&#39;]
        self.close_margin = setting[&#39;close_margin&#39;]
        self.grid_amount = setting[&#39;grid_amount&#39;]
        self.array_len = setting[&#39;array_len&#39;]
        self.stop_loss = setting[&#39;stop_loss&#39;]
        self.pValue = setting[&#39;pValue&#39;]
        self.initial_balance = broker.cash
        self.maximum_holding_period = setting[&#39;maximum_holding_period&#39;]
        self.broker = broker
        self.beta = None
        self.intercept = None
        self.mean = None
        self.dev = None
        self.start = False
        self.open_diff = None
        self.bar_array = deque(maxlen=self.array_len)
        self.spread_array = deque(maxlen=self.array_len)
        self.is_open = False
        self.holding_count = 0

    def get_model(self):
        pass

    def get_legs(self):
        long_legs = []
        short_legs = []
        for i in range(self.array_len):

            bar = self.bar_array[i]
            long_legs.append(np.log(bar[self.long_leg]))
            short_legs.append(np.log(bar[self.short_leg]))

        return long_legs, short_legs

    def get_beta(self):
        long_legs, short_legs = self.get_legs()

        # 使用 scikit-learn 回归模型计算 Beta（不带截距）
        long_legs = np.array(long_legs).reshape(-1, 1)
        short_legs = np.array(short_legs)
        model = LinearRegression(fit_intercept=True).fit(long_legs, short_legs)
        beta = model.coef_[0]
        intercept = model.intercept_
        return beta, intercept

    def get_beta_BayesRegression(self):
        long_legs, short_legs = self.get_legs()
        result = bayesian_rolling_window(long_legs, short_legs, window_size=20)

        y_values = result[&#39;y&#39;]
        beta_values = result[&#39;beta&#39;]
        mu_values = result[&#39;mu&#39;]
        epsilon_values = result[&#39;epsilon&#39;]

        y_pred_mean = y_values[&#39;mean&#39;]
        y_pred_upper = y_values[&#39;upper&#39;]
        y_pred_lower = y_values[&#39;lower&#39;]

        beta_posterior = beta_values[&#39;mean&#39;]
        beta_upper = beta_values[&#39;upper&#39;]
        beta_lower = beta_values[&#39;lower&#39;]

        mu_posterior = mu_values[&#39;mean&#39;]
        mu_upper = mu_values[&#39;upper&#39;]
        mu_lower = mu_values[&#39;lower&#39;]

        epsilon_mean = epsilon_values[&#39;mean&#39;]
        epsilon_upper = epsilon_values[&#39;upper&#39;]
        epsilon_lower = epsilon_values[&#39;lower&#39;]

        return beta_posterior[-1], mu_posterior[-1]

    def get_beta_GPs(self):
        long_legs, short_legs = self.get_legs()
        long_legs = np.array(long_legs)
        short_legs = np.array(short_legs)
        result = fit_HGP(long_legs, short_legs)

        y_values = result[&#39;y&#39;]
        beta_values = result[&#39;beta&#39;]
        mu_values = result[&#39;mu&#39;]
        epsilon_values = result[&#39;epsilon&#39;]

        y_pred_mean = y_values[&#39;mean&#39;]
        y_pred_upper = y_values[&#39;upper&#39;]
        y_pred_lower = y_values[&#39;lower&#39;]

        beta_posterior = beta_values[&#39;mean&#39;]
        beta_upper = beta_values[&#39;upper&#39;]
        beta_lower = beta_values[&#39;lower&#39;]

        mu_posterior = mu_values[&#39;mean&#39;]
        mu_upper = mu_values[&#39;upper&#39;]
        mu_lower = mu_values[&#39;lower&#39;]

        epsilon_mean = epsilon_values[&#39;mean&#39;]
        epsilon_upper = epsilon_values[&#39;upper&#39;]
        epsilon_lower = epsilon_values[&#39;lower&#39;]

        return np.float64(beta_posterior[-1]), np.float64(mu_posterior[-1])

    def get_beta_BSTS(self):
        pass

    def get_beta_GAM(self):
        long_legs = []
        short_legs = []
        for i in range(self.array_len):
            bar = self.bar_array[i]
            long_legs.append(bar[self.long_leg])
            short_legs.append(bar[self.short_leg])
        long_legs = np.array(long_legs)
        short_legs = np.array(short_legs)

        result = bayesian_gam_with_splines(long_legs,short_legs,df=10)
        y_values = result[&#39;y&#39;]
        beta_values = result[&#39;beta&#39;]
        mu_values = result[&#39;mu&#39;]
        epsilon_values = result[&#39;epsilon&#39;]

        y_pred_mean = y_values[&#39;mean&#39;]
        y_pred_upper = y_values[&#39;upper&#39;]
        y_pred_lower = y_values[&#39;lower&#39;]

        beta_posterior = beta_values[&#39;mean&#39;]
        beta_upper = beta_values[&#39;upper&#39;]
        beta_lower = beta_values[&#39;lower&#39;]

        mu_posterior = mu_values[&#39;mean&#39;]
        mu_upper = mu_values[&#39;upper&#39;]
        mu_lower = mu_values[&#39;lower&#39;]

        epsilon_mean = epsilon_values[&#39;mean&#39;]
        epsilon_upper = epsilon_values[&#39;upper&#39;]
        epsilon_lower = epsilon_values[&#39;lower&#39;]

        return beta_posterior[-1], mu_posterior[-1]


    def processBar(self, bars: dict):
        from math import log
        # append log data
        bar = {
            self.short_leg: (bars[self.short_leg].close),
            self.long_leg: (bars[self.long_leg].close),
        }
        self.bar_array.append(bar)
        if len(self.bar_array) &lt; self.array_len:
            return

        p_value = self.coin_test()

        spread, _ = self.spread(bars)
        self.spread_array.append(spread)
        if len(self.spread_array) &lt; self.array_len/5:
            return

        if self.is_open:
            self.holding_count &#43;= 1
            spread, _ = self.spread(bars)
            diff = (spread - self.mean) / self.dev
            if self.holding_count &gt;= self.maximum_holding_period:
                print(&#39;holding too long force quit&#39;)
                self.close_position_new(bars, ignore_diff=True)
                self.holding_count = 0
                return

        if self.mean:
            diff = (spread - self.mean) / self.dev
            # print(f&#34;current diff {diff}&#34;)

        adf_center = adfuller(self.spread_array, regression=&#39;c&#39;)[1]
        adf_trend = adfuller(self.spread_array, regression=&#39;ct&#39;)[1]

        if adf_center &lt; self.pValue:
            self.is_stationary = True
        else:
            self.is_stationary = False

        # if adf_trend &lt; 0.05:
        #     print(f&#39;adf ct test result {adf_trend}, has a trend, not enter trading&#39;)
        #     return

        # if p_value &lt;= self.pValue:
        if self.is_stationary:
            self.hedge(bars)
        elif self.is_open:
            self.close_position_new(bars)

    def hedge(self, bars: dict):
        if not self.is_open:
            # self.open_position(bars)
            self.open_position_new(bars)
        else:
            self.close_position_new(bars)

    def open_position_new(self, bars: dict):
        spread, _ = self.spread(bars)
        self.mean, self.dev = self.get_diff(spread)
        diff = (spread - self.mean) / self.dev
        long_leg_price = (bars[self.long_leg].close)
        short_leg_price = (bars[self.short_leg].close)
        time = bars[self.short_leg].time
        short_leg_qty = self.grid_amount/(long_leg_price*abs(self.beta) &#43; short_leg_price)
        long_leg_qty = short_leg_qty*abs(self.beta)
        if abs(diff) &gt; 2:
            print(
                f&#39;open parameter beta: {self.beta}, intercept: {self.intercept}, spread mean:{self.mean}, spread dev {self.dev}, diff:{diff} , time:{time}&#39;)
            self.open_diff = diff
            if self.beta &lt; 0:

                if diff &gt; 0:

                    self.broker.short(
                        price=long_leg_price,
                        symbol=self.long_leg,
                        vol=long_leg_qty,
                        leverage=1,
                        time=time)

                    self.broker.short(
                        price=short_leg_price,
                        symbol=self.short_leg,
                        vol=short_leg_qty,
                        leverage=1,
                        time=time)

                    self.is_open = True

                else:
                    self.broker.long(
                        price=long_leg_price,
                        symbol=self.long_leg,
                        vol=long_leg_qty,
                        leverage=1,
                        time=time)

                    self.broker.long(
                        price=short_leg_price,
                        symbol=self.short_leg,
                        vol=short_leg_qty,
                        leverage=1,
                        time=time)

                    self.is_open = True

            else:
                if diff &gt; 0:
                    self.broker.long(
                        price=long_leg_price,
                        symbol=self.long_leg,
                        vol=long_leg_qty,
                        leverage=1,
                        time=time)

                    self.broker.short(
                        price=short_leg_price,
                        symbol=self.short_leg,
                        vol=short_leg_qty,
                        leverage=1,
                        time=time)

                    self.is_open = True

                else:
                    self.broker.long(
                        price=short_leg_price,
                        symbol=self.short_leg,
                        vol=short_leg_qty,
                        leverage=1,
                        time=time)

                    self.broker.short(
                        price=long_leg_price,
                        symbol=self.long_leg,
                        vol=long_leg_qty,
                        leverage=1,
                        time=time)

                    self.is_open = True


    def close_position_new(self, bars: dict, ignore_diff=False):
        spread, _ = self.spread(bars)
        diff = (spread - self.mean) / self.dev
        # calculate position pnl
        long_leg_price = (bars[self.long_leg].close)
        short_leg_price = (bars[self.short_leg].close)
        time = bars[self.short_leg].time
        long_leg_pos: Position = self.broker.positions[self.long_leg]
        short_leg_pos: Position = self.broker.positions[self.short_leg]


        # Close the position when the unrealize loss is too much !!!
        # profit_rate = self.broker.get_current_pos_profit_rate(bars)
        # if profit_rate &lt; -0.1:
        #     print(&#39;position profit rate is too low, force quit&#39;)
        #     ignore_diff = True
        if (self.open_diff &gt; 0 and diff &lt; 0) or (self.open_diff &lt; 0 and diff &gt; 0) or ignore_diff:

        # if abs(diff) &lt; -2 or ignore_diff:
            self.holding_count = 0
            print(
                f&#39;close parameter beta: {self.beta}, intercept: {self.intercept}, spread mean:{self.mean}, spread dev {self.dev}, diff:{diff} , time:{time}&#39;)

            if short_leg_pos.direction == &#39;short&#39;:
                self.broker.cover_short(
                    price=short_leg_price,
                    symbol=self.short_leg,
                    vol=short_leg_pos.volume,
                    time=time)
            else:
                self.broker.cover_long(
                    price=short_leg_price,
                    symbol=self.short_leg,
                    vol=short_leg_pos.volume,
                    time=time)

            if long_leg_pos.direction == &#39;short&#39;:
                self.broker.cover_short(
                    price=long_leg_price,
                    symbol=self.long_leg,
                    vol=long_leg_pos.volume,
                    time=time)
            else:
                self.broker.cover_long(
                    price=long_leg_price,
                    symbol=self.long_leg,
                    vol=long_leg_pos.volume,
                    time=time)

            self.is_open = False
            self.beta, self.intercept = None, None

    def spread(self, bars: dict):
        long: BarData = bars[self.long_leg]
        short: BarData = bars[self.short_leg]

        long_price = (long.close)
        short_price = (short.close)

        spread = short_price - (self.beta * long_price &#43; self.intercept)
        diff = spread / (self.beta * long_price &#43; self.intercept)
        return spread, diff

    def get_diff(self, spread):
        mean = np.mean(self.spread_array)
        dev = np.std(self.spread_array)
        return mean, dev

    def coin_test(self):
        long_legs = []
        short_legs = []
        for i in range(self.array_len):
            bar = self.bar_array[i]
            long_legs.append(bar[self.long_leg])
            short_legs.append(bar[self.short_leg])

        if not self.beta:
            self.beta, self.intercept = self.get_beta_GPs()

        long_legs_modify = []

        for i in range(self.array_len):
            new_long_leg = long_legs[i] * self.beta &#43; self.intercept
            long_legs_modify.append(new_long_leg)

        _, p_value, _ = coint(long_legs_modify, short_legs)
        return p_value


def generate_combinations(symbols):
    return list(combinations(symbols, 2))


p_value = 0.99
stop_loss = 0.5


def main(selected_symbols):
    cash = 1000000
    transactionFeeRate = 0
    start = &#39;2023-01-01&#39;
    end = &#39;2024-10-31&#39;
    broker = Broker(cash, transactionFeeRate, selected_symbols)
    setting = {
        &#39;short_leg&#39;: selected_symbols[0],
        &#39;long_leg&#39;: selected_symbols[1],
        &#39;open_margin&#39;: 0.05,
        &#39;close_margin&#39;: 0.02,
        &#39;stop_loss&#39;: stop_loss,
        &#39;pValue&#39;: 0.05,
        &#39;grid_amount&#39;: cash * 0.2,
        &#39;array_len&#39;: 300,
        &#39;maximum_holding_period&#39;: 300,
    }

    strategy = Cointegration(broker, setting)
    log = Log(broker)
    backtestor = BacktestorPairTrading(broker, strategy, log, start, end)
    backtestor.load_data()
    backtestor.run_backtest()
    result = backtestor.performance()
    msg_df = pd.DataFrame(broker.msg)
    profit, loss, winrate = analyze_arbitrage_cycles(msg_df)
    # msg_df.to_csv(&#39;backTestResult/msg_df.csv&#39;)
    pnl_ratio = profit / loss
    result[&#39;pnl_ratio&#39;] = pnl_ratio
    result[&#39;win_rate&#39;] = winrate
    return result
    # msg_df = pd.DataFrame(broker.msg)
    # msg_df.to_csv(&#39;backTestResult/msg_df.csv&#39;)






if __name__ == &#39;__main__&#39;:
    from backTestResult.cointegration_analysis import analyze_arbitrage_cycles

    cash = 1000000
    transactionFeeRate = 0.00025
    start = &#39;2023-01-01&#39;
    end = &#39;2024-10-31&#39;
    long_leg = &#39;DOGE&#39;
    short_leg = &#39;XRP&#39;
    selected_symbols = [long_leg, short_leg]
    broker = Broker(cash, transactionFeeRate, selected_symbols)
    setting = {
        &#39;short_leg&#39;: short_leg,
        &#39;long_leg&#39;: long_leg,
        &#39;open_margin&#39;: 0.05,
        &#39;close_margin&#39;: 0.04,
        &#39;stop_loss&#39;: 0.4,
        &#39;pValue&#39;: 0.05,
        &#39;grid_amount&#39;: cash * 0.2,
        &#39;array_len&#39;: 200,
        &#39;maximum_holding_period&#39;: 24* 30,
    }

    strategy = Cointegration(broker, setting)
    log = Log(broker)
    backtestor = BacktestorPairTrading(broker, strategy, log, start, end)
    backtestor.load_data()
    backtestor.run_backtest()
    result = backtestor.performance()
    msg_df = pd.DataFrame(broker.msg)
    analyze_arbitrage_cycles(msg_df)
    msg_df.to_csv(&#39;backTestResult/msg_df.csv&#39;)
Bayesian regression
def bayesian_rolling_window(X_t, Y_t, window_size=30):
    T = len(X_t)
    beta_t_est = np.zeros(T)
    mu_t_est = np.zeros(T)
    beta_var_est = np.zeros(T)
    mu_var_est = np.zeros(T)
    residual_var_est = np.zeros(T)
    Y_pred = np.zeros(T)
    Y_std_est = np.zeros(T)

    # Prior parameters
    beta_mean_prior = 0
    beta_var_prior = 1
    mu_mean_prior = 0
    mu_var_prior = 1
    sigma_prior = 1

    for t in range(window_size, T):
        # Get rolling window data
        X_window = np.float64(X_t[t - window_size:t])
        Y_window = np.float64(Y_t[t - window_size:t])

        # Posterior parameters for beta
        XTX = np.sum(X_window ** 2)
        XTY = np.sum(X_window * (Y_window - np.mean(Y_window)))
        beta_var_post = 1 / (1 / beta_var_prior &#43; XTX / sigma_prior)
        beta_mean_post = beta_var_post * (beta_mean_prior / beta_var_prior &#43; XTY / sigma_prior)

        # Posterior parameters for mu
        mu_var_post = 1 / (1 / mu_var_prior &#43; window_size / sigma_prior)
        mu_mean_post = mu_var_post * (mu_mean_prior / mu_var_prior &#43; np.sum(Y_window - beta_mean_post * X_window) / sigma_prior)

        # Estimate residual variance
        residuals_window = Y_window - (beta_mean_post * X_window &#43; mu_mean_post)
        residual_var_est[t] = np.var(residuals_window)

        # Store estimates
        beta_t_est[t] = beta_mean_post
        mu_t_est[t] = mu_mean_post
        beta_var_est[t] = beta_var_post
        mu_var_est[t] = mu_var_post

        # Predict Y_t and its credible interval
        Y_pred[t] = beta_t_est[t] * X_t[t] &#43; mu_t_est[t]
        Y_var_est = (X_t[t] ** 2) * (beta_var_est[t]) &#43; (mu_var_est[t]) &#43; (1 / sigma_prior)
        Y_std_est[t] = np.sqrt(Y_var_est)


        # Prior parameters
        beta_mean_prior = beta_mean_post
        beta_var_prior = beta_var_post
        mu_mean_prior = mu_mean_post
        mu_var_prior = mu_var_post

    residuals = Y_t - Y_pred

    data = {
        &#39;y&#39;: {
            &#39;mean&#39;: Y_pred,
            &#39;upper&#39;: Y_pred &#43; 1.96 * Y_std_est,
            &#39;lower&#39;: Y_pred - 1.96 * Y_std_est
        },
        &#39;beta&#39;: {
            &#39;mean&#39;: beta_t_est,
            &#39;upper&#39;:  beta_t_est &#43; 1.96 * np.sqrt(beta_var_est),
            &#39;lower&#39;: beta_t_est - 1.96 * np.sqrt(beta_var_est)
        },
        &#39;mu&#39;: {
            &#39;mean&#39;: mu_t_est,
            &#39;upper&#39;: mu_t_est &#43; 1.96 * np.sqrt(mu_var_est),
            &#39;lower&#39;: mu_t_est - 1.96 * np.sqrt(mu_var_est)
        },
        &#39;epsilon&#39;: {
            &#39;mean&#39;: residuals,
            &#39;upper&#39;: residuals &#43; 1.96 * np.sqrt(residual_var_est),
            &#39;lower&#39;: residuals - 1.96 * np.sqrt(residual_var_est)
        },
    }

    return data
Bayesian GAM
def bayesian_gam_with_splines(X_t, Y_t, df=10):
    T = len(X_t)
    time = np.linspace(0, 1, T)

    # Design matrices for splines
    design_matrix = patsy.dmatrix(f&#34;bs(time, df={df}, degree=3)&#34;, {&#34;time&#34;: time}, return_type=&#39;dataframe&#39;)

    # Joint Bayesian Ridge Regression for beta_t and mu_t
    X_joint = np.hstack([np.multiply(design_matrix.values, X_t[:, None]), design_matrix.values])
    model_joint = BayesianRidge()
    model_joint.fit(X_joint, Y_t)

    # Predict values with uncertainties
    Y_pred, Y_std = model_joint.predict(X_joint, return_std=True)

    # Separate beta_t and mu_t
    beta_t_est = design_matrix.values @ model_joint.coef_[:design_matrix.shape[1]]
    mu_t_est = design_matrix.values @ model_joint.coef_[design_matrix.shape[1]:]

    # Compute standard deviations for beta and mu
    coef_cov = np.linalg.inv(model_joint.alpha_ * np.eye(X_joint.shape[1]) &#43; model_joint.lambda_ * X_joint.T @ X_joint)
    beta_std_est = np.sqrt(np.sum((design_matrix.values @ coef_cov[:design_matrix.shape[1], :design_matrix.shape[1]]) * design_matrix.values, axis=1))
    mu_std_est = np.sqrt(np.sum((design_matrix.values @ coef_cov[design_matrix.shape[1]:, design_matrix.shape[1]:]) * design_matrix.values, axis=1))

    # Posterior variance of noise
    residual_var_est = 1 / model_joint.alpha_  # Posterior noise variance

    residuals = Y_t - Y_pred

    data = {
        &#39;y&#39;: {
            &#39;mean&#39;: Y_pred,
            &#39;upper&#39;: Y_pred &#43; 1.96 * Y_std,
            &#39;lower&#39;: Y_pred - 1.96 * Y_std
        },
        &#39;beta&#39;: {
            &#39;mean&#39;: beta_t_est,
            &#39;upper&#39;: beta_t_est &#43; 1.96 * beta_std_est,
            &#39;lower&#39;: beta_t_est - 1.96 * beta_std_est
        },
        &#39;mu&#39;: {
            &#39;mean&#39;: mu_t_est,
            &#39;upper&#39;: mu_t_est &#43; 1.96 * mu_std_est,
            &#39;lower&#39;: mu_t_est - 1.96 * mu_std_est
        },
        &#39;epsilon&#39;: {
            &#39;mean&#39;: residuals,
            &#39;upper&#39;: residuals &#43; 1.96 * np.sqrt(residual_var_est),
            &#39;lower&#39;: residuals - 1.96 * np.sqrt(residual_var_est)
        },
    }

    return data
Gaussian Process
class TimeVaryingGP(ExactGP):
    def __init__(self, train_x, train_y, likelihood):
        super(TimeVaryingGP, self).__init__(train_x, train_y, likelihood)

        # Separate kernels for each component
        self.beta_kernel = ScaleKernel(RBFKernel())
        # self.beta_kernel.base_kernel.register_prior(
        #     &#39;lengthscale_prior&#39;,
        #     gpytorch.priors.GammaPrior(10.0, 20.0),
        #     &#39;lengthscale&#39;
        # )
        self.mu_kernel = ScaleKernel(RBFKernel())
        self.eps_kernel = ScaleKernel(RBFKernel())

        self.mean = ZeroMean()

    def forward(self, x):
        # Extract time and covariates
        t = x[:, 0]  # time index
        X = x[:, 1]  # covariate

        # Compute kernel matrices
        K_beta = self.beta_kernel(t)
        K_mu = self.mu_kernel(t)
        K_eps = self.eps_kernel(t)

        # Compute covariance matrix
        covar = X.unsqueeze(1) * K_beta * X.unsqueeze(0) &#43; K_mu &#43; K_eps

        mean = self.mean(x)
        return MultivariateNormal(mean, covar)


def train_model(X, y, n_iter=100):
    if not isinstance(X, torch.Tensor):
        X = torch.from_numpy(X).clone().detach().float()
        y = torch.from_numpy(y).clone().detach().float()
    else:
        X = X.clone().detach().float()
        y = y.clone().detach().float()

    # Initialize model
    likelihood = gpytorch.likelihoods.GaussianLikelihood()
    model = TimeVaryingGP(X, y, likelihood)

    # Use the adam optimizer
    optimizer = torch.optim.Adam([
        {&#39;params&#39;: model.parameters()},
    ], lr=0.1)

    # &#34;Loss&#34; for GPs - the marginal log likelihood
    mll = gpytorch.mlls.ExactMarginalLogLikelihood(likelihood, model)

    # Training loop
    model.train()
    likelihood.train()

    for i in range(n_iter):
        optimizer.zero_grad()
        output = model(X)
        loss = -mll(output, y)
        loss.backward()
        optimizer.step()

    return model, likelihood


def predict_latent(model, X_train, y_train, X_new):
    model.eval()
    jitter = 1e-6

    with torch.no_grad():
        t_train = X_train[:, 0]
        x_train = X_train[:, 1]
        t_new = X_new[:, 0]
        x_new = X_new[:, 1]

        K_beta = model.beta_kernel(t_new, t_train).evaluate()
        K_mu = model.mu_kernel(t_new, t_train).evaluate()
        K_eps = model.eps_kernel(t_new, t_train).evaluate()

        K_total = x_train * model.beta_kernel(t_train).evaluate() * x_train.unsqueeze(-1) &#43; \
                  model.mu_kernel(t_train).evaluate() &#43; \
                  model.eps_kernel(t_train).evaluate() &#43; \
                  model.likelihood.noise * torch.eye(len(t_train)) &#43; \
                  jitter * torch.eye(len(t_train))

        K_new_beta = model.beta_kernel(t_new).evaluate() &#43; jitter * torch.eye(len(t_new))
        K_new_mu = model.mu_kernel(t_new).evaluate() &#43; jitter * torch.eye(len(t_new))
        K_new_eps = model.eps_kernel(t_new).evaluate() &#43; jitter * torch.eye(len(t_new))

        # Compute posterior mean using Cholesky
        L = torch.linalg.cholesky(K_total)
        alpha = torch.linalg.solve_triangular(L, y_train.unsqueeze(1), upper=False)
        alpha = torch.linalg.solve_triangular(L.T, alpha, upper=True)

        K_stacked = torch.stack([
            x_new.unsqueeze(-1) * K_beta,
            K_mu,
            K_eps
        ])
        posterior_mean = K_stacked @ alpha

        # Compute posterior variance using Cholesky
        v_beta = torch.linalg.solve_triangular(L, (x_train * K_beta.T).T, upper=False)
        v_mu = torch.linalg.solve_triangular(L, K_mu.T, upper=False)
        v_eps = torch.linalg.solve_triangular(L, K_eps.T, upper=False)

        post_var_beta = K_new_beta - v_beta.T @ v_beta
        post_var_mu = K_new_mu - v_mu.T @ v_mu
        post_var_eps = K_new_eps - v_eps.T @ v_eps

        return {
            &#39;mean&#39;: {
                &#39;beta&#39;: posterior_mean[0].squeeze(),
                &#39;mu&#39;: posterior_mean[1].squeeze(),
                &#39;epsilon&#39;: posterior_mean[2].squeeze()
            },
            &#39;variance&#39;: {
                &#39;beta&#39;: post_var_beta.diag(),
                &#39;mu&#39;: post_var_mu.diag(),
                &#39;epsilon&#39;: post_var_eps.diag()
            }
        }


def predict(model, likelihood, X_new, X_train=None, y_train=None):
    model.eval()
    likelihood.eval()

    if X_train is None:
        X_train = model.train_inputs[0]
    if y_train is None:
        y_train = model.train_targets

    with torch.no_grad(), gpytorch.settings.fast_pred_var():
        observed_pred = likelihood(model(X_new))

    latent_values = predict_latent(model, X_train, y_train, X_new)
    return observed_pred.mean, observed_pred.variance, latent_values
BSTS
def bsts_fit(x,y):
    with pm.Model() as model:
        # Priors for variances

        # sigma = pm.HalfCauchy(&#39;sigma&#39;, beta=1)
        # Random walk for log volatility
        log_sigma = pm.GaussianRandomWalk(&#39;log_sigma&#39;,
                                          sigma=0.1,
                                          shape=len(y),
                                          init_dist=pm.Normal.dist(mu=0, sigma=1))
        sigma = pm.Deterministic(&#39;sigma&#39;, pm.math.exp(log_sigma))

        sigma_beta = pm.HalfCauchy(&#39;sigma_beta&#39;, beta=1)
        sigma_mu = pm.HalfCauchy(&#39;sigma_mu&#39;, beta=1)

        # Gaussian Random Walks for beta and mu
        beta = pm.GaussianRandomWalk(&#39;beta&#39;, sigma=sigma_beta, init_dist=pm.Normal.dist(0, 10), shape=len(y))
        mu = pm.GaussianRandomWalk(&#39;mu&#39;, sigma=sigma_mu, init_dist=pm.Normal.dist(0, 10), shape=len(y))

        # Observation model
        Y_obs = pm.Normal(&#39;Y_obs&#39;, mu=beta * x &#43; mu, sigma=sigma, observed=y)

        # ---- 3. MCMC Sampling ----
        trace = pm.sample(1000, tune=1000, chains=2, target_accept=0.9)
        ppc = pm.sample_posterior_predictive(trace, var_names=[&#34;Y_obs&#34;], random_seed=42)

        # Extract posterior mean and 95% credible intervals
        beta_posterior = trace.posterior[&#39;beta&#39;].mean(dim=(&#34;chain&#34;, &#34;draw&#34;))
        beta_lower = trace.posterior[&#39;beta&#39;].quantile(0.025, dim=(&#34;chain&#34;, &#34;draw&#34;))
        beta_upper = trace.posterior[&#39;beta&#39;].quantile(0.975, dim=(&#34;chain&#34;, &#34;draw&#34;))

        mu_posterior = trace.posterior[&#39;mu&#39;].mean(dim=(&#34;chain&#34;, &#34;draw&#34;))
        mu_lower = trace.posterior[&#39;mu&#39;].quantile(0.025, dim=(&#34;chain&#34;, &#34;draw&#34;))
        mu_upper = trace.posterior[&#39;mu&#39;].quantile(0.975, dim=(&#34;chain&#34;, &#34;draw&#34;))

        # Extract posterior predictive samples
        y_pred_samples = ppc.posterior_predictive[&#39;Y_obs&#39;]

        # Calculate mean and 95% prediction interval
        y_pred_mean = y_pred_samples.mean(dim=(&#39;chain&#39;, &#39;draw&#39;)).values
        y_pred_lower = np.percentile(y_pred_samples.values, 2.5, axis=(0, 1))  # 2.5% quantile
        y_pred_upper = np.percentile(y_pred_samples.values, 97.5, axis=(0, 1))  # 97.5% quantile

        epsilon_samples = y - y_pred_samples.values  # Shape: (chains, draws, time)

        # ---- 3. Calculate Mean and Intervals ----
        # Mean residuals
        epsilon_mean = epsilon_samples.mean(axis=(0, 1))  # Average over chains and draws

        # 95% prediction intervals
        epsilon_lower = np.percentile(epsilon_samples, 2.5, axis=(0, 1))
        epsilon_upper = np.percentile(epsilon_samples, 97.5, axis=(0, 1))

        data = {
            &#39;y&#39;: {
                &#39;mean&#39;: y_pred_mean,
                &#39;upper&#39;: y_pred_upper,
                &#39;lower&#39;: y_pred_lower
            },
            &#39;beta&#39;: {
                &#39;mean&#39;: beta_posterior,
                &#39;upper&#39;: beta_upper,
                &#39;lower&#39;: beta_lower
            },
            &#39;mu&#39;: {
                &#39;mean&#39;: mu_posterior,
                &#39;upper&#39;: mu_upper,
                &#39;lower&#39;: mu_lower
            },
            &#39;epsilon&#39;: {
                &#39;mean&#39;: epsilon_mean,
                &#39;upper&#39;: epsilon_upper,
                &#39;lower&#39;: epsilon_lower
            },
        }

        return data
Gaussian Process clustering
import pandas as pd
import numpy as np
from sklearn.cluster import KMeans
import gpytorch
import torch


class SparseGPModel(gpytorch.models.ApproximateGP):
    def __init__(self, inducing_points):
        variational_distribution = gpytorch.variational.CholeskyVariationalDistribution(inducing_points.size(0))
        variational_strategy = gpytorch.variational.VariationalStrategy(
            self, inducing_points, variational_distribution, learn_inducing_locations=True
        )
        super().__init__(variational_strategy)
        # Define kernel: RBF kernel with constant mean
        self.mean_module = gpytorch.means.ConstantMean()
        self.covar_module = gpytorch.kernels.ScaleKernel(gpytorch.kernels.RBFKernel())

    def forward(self, x):
        mean_x = self.mean_module(x)
        covar_x = self.covar_module(x)
        return gpytorch.distributions.MultivariateNormal(mean_x, covar_x)


def sparse_gpr_hyperparameter_clustering(data, n_clusters=3, num_inducing=10, verbose=True):

    symbols = data.iloc[:, 0].values
    time_points = torch.tensor(np.arange(data.shape[1] - 1), dtype=torch.float32)  # Time indices
    time_series = torch.tensor(data.iloc[:, 1:].values, dtype=torch.float32)  # Time series values

    # Initialize list to store hyperparameters
    hyperparameters = []

    if verbose:
        print(&#34;Starting Sparse Gaussian Process Regression for each stock...\n&#34;)

    for idx, ts in enumerate(time_series):
        ts = ts.unsqueeze(-1)  # Add a dimension for compatibility (n_samples, 1)

        inducing_points = time_points[::len(time_points) // num_inducing][:num_inducing].unsqueeze(-1)

        model = SparseGPModel(inducing_points)
        likelihood = gpytorch.likelihoods.GaussianLikelihood()

        model.train()
        likelihood.train()
        optimizer = torch.optim.Adam(model.parameters(), lr=0.1)
        mll = gpytorch.mlls.VariationalELBO(likelihood, model, num_data=len(time_points))

        # Training loop (simple with fixed iterations for now)
        training_iter = 100  # You can adjust this
        for i in range(training_iter):
            optimizer.zero_grad()
            output = model(time_points.unsqueeze(-1))
            loss = -mll(output, ts).sum()
            loss.backward()
            optimizer.step()

        # Extract learned hyperparameters
        kernel_params = model.covar_module.base_kernel.lengthscale.item()
        outputscale = model.covar_module.outputscale.item()
        noise = likelihood.noise.item()

        hyperparameters.append([outputscale, kernel_params, noise])

        if verbose:
            print(f&#34;Processed {idx &#43; 1}/{len(time_series)}: Symbol = {symbols[idx]}, &#34;
                  f&#34;Output Scale = {outputscale:.3f}, Length Scale = {kernel_params:.3f}, noise = {noise:.3f}&#34;)

    if verbose:
        print(&#34;\nFinished Sparse Gaussian Process Regression.&#34;)
        print(&#34;Starting clustering on hyperparameters...\n&#34;)

    # Perform clustering on hyperparameters
    hyperparameters = np.array(hyperparameters)
    kmeans = KMeans(n_clusters=n_clusters, random_state=0)
    labels = kmeans.fit_predict(hyperparameters)

    clusters = {}
    for cluster_id in range(n_clusters):
        clusters[f&#39;Cluster{cluster_id&#43;1}&#39;] = symbols[labels == cluster_id].tolist()

        if verbose:
            print(f&#34;Cluster {cluster_id &#43; 1}: {len(clusters[f&#39;Cluster{cluster_id&#43;1}&#39;])} symbols&#34;)

    if verbose:
        print(&#34;\nClustering complete. Summary:&#34;)
        for cluster, symbols in clusters.items():
            print(f&#34;{cluster}: {symbols}&#34;)

    return clusters


df = pd.read_csv(&#39;Quantitative_Research/model_new/bayesian_clustering/transposed_stock_data.csv&#39;)
clusters = sparse_gpr_hyperparameter_clustering(df, n_clusters=10, verbose=True)
print(clusters)
Appendix
broker object
class Broker:
    def __init__(self, cash: float, feeRate: float, symbols: list):
        self.positions = {}
        self.wallet = {}
        for symbol in symbols:
            self.wallet[symbol] = 0
        self.cash = cash
        self.feeRate = feeRate
        self.totalFee = 0
        self.symbols = symbols
        self.msg = []

    def buy(self, price, symbol, vol):
        # cash = self.cash
        # if cash - price * vol * (1 &#43; self.feeRate) &lt; 0:
        #     # print(&#34;not enough cash, but amount that minus fees&#34;)
        #     vol -= price * vol * self.feeRate / price
        self.cash -= price * vol * (1 &#43; self.feeRate)
        self.wallet[symbol] &#43;= vol
        self.totalFee &#43;= price * vol * self.feeRate
        msg = f&#34;Buy {symbol} at price: {price} for {vol} amount&#34;
        print(msg)
        msg_dict = {
            &#34;symbol&#34;: symbol,
            &#34;price&#34;: price,
            &#34;vol&#34;: vol,
            &#34;action&#34;: &#34;buy&#34;

        }
        self.msg.append(msg_dict)

    def sell(self, price, symbol, vol):
        self.cash &#43;= price * vol * (1 - self.feeRate)
        self.wallet[symbol] -= vol
        self.totalFee &#43;= price * vol * self.feeRate
        msg = f&#34;Sell {symbol} at price: {price} for {vol} amount&#34;
        print(msg)
        msg_dict = {
            &#34;symbol&#34;: symbol,
            &#34;price&#34;: price,
            &#34;vol&#34;: vol,
            &#34;action&#34;: &#34;sell&#34;
        }
        self.msg.append(msg_dict)

    def _update_position(self, symbol, price, vol, direction, time):
        if symbol in self.positions:
            position = self.positions[symbol]
            if position.direction == direction:
                # 加仓，计算新的加权平均价格
                new_volume = position.volume &#43; vol
                new_avg_price = (position.avg_price * position.volume &#43; price * vol) / new_volume
                position.avg_price = new_avg_price
                position.volume = new_volume
                position.time = time
            else:
                # 如果方向相反，考虑部分平仓或完全平仓的情况
                if abs(position.volume) &gt; vol:
                    # 部分平仓
                    position.volume -= vol
                elif abs(position.volume) == vol:
                    # 完全平仓，删除仓位
                    del self.positions[symbol]
                else:
                    # 平掉原仓位并开立新方向的仓位
                    new_vol = vol - abs(position.volume)
                    position.direction = direction
                    position.avg_price = price
                    position.volume = new_vol
                    position.time = time
        else:
            # 开立新仓位
            self.positions[symbol] = Position(time=time, avg_price=price, symbol=symbol, direction=direction,
                                              volume=vol)

    def long(self, price, symbol, vol, leverage, time):
        &#34;&#34;&#34;
        开立多头仓位，使用杠杆购买资产。
        :param price: 当前资产价格
        :param symbol: 资产符号
        :param vol: 购买的资产数量
        :param leverage: 杠杆倍数
        :param time: 当前时间
        &#34;&#34;&#34;
        margin_required = (price * vol) / leverage
        # if self.cash &lt; margin_required:
        #     print(&#34;Not enough cash to open long position with leverage.&#34;)
        #     return

        self.cash -= margin_required
        fee = price * vol * self.feeRate
        self.totalFee &#43;= fee
        self._update_position(symbol, price, vol * leverage, &#39;long&#39;, time)
        msg = f&#34;Long {symbol} at price: {price} for {vol} amount with leverage {leverage}&#34;
        print(msg)
        msg_dict = {
            &#34;symbol&#34;: symbol,
            &#34;price&#34;: price,
            &#34;vol&#34;: vol,
            &#34;action&#34;: &#34;long&#34;
        }
        self.msg.append(msg_dict)

    def short(self, price, symbol, vol, leverage, time):
        &#34;&#34;&#34;
        开立空头仓位，使用杠杆卖出资产。
        :param price: 当前资产价格
        :param symbol: 资产符号
        :param vol: 卖出的资产数量
        :param leverage: 杠杆倍数
        :param time: 当前时间
        &#34;&#34;&#34;
        margin_required = (price * vol) / leverage
        # if self.cash &lt; margin_required:
        #     print(&#34;Not enough cash to open short position with leverage.&#34;)
        #     return

        self.cash -= margin_required
        fee = price * vol * self.feeRate
        self.totalFee &#43;= fee
        self._update_position(symbol, price, vol * leverage, &#39;short&#39;, time)
        msg = f&#34;Short {symbol} at price: {price} for {vol} amount with leverage {leverage}&#34;
        print(msg)
        msg_dict = {
            &#34;symbol&#34;: symbol,
            &#34;price&#34;: price,
            &#34;vol&#34;: vol,
            &#34;action&#34;: &#34;short&#34;
        }
        self.msg.append(msg_dict)

    def cover_long(self, price, symbol, vol, time):
        &#34;&#34;&#34;
        平掉多头仓位。
        :param price: 当前资产价格
        :param symbol: 资产符号
        :param vol: 平仓的资产数量
        :param time: 当前时间
        &#34;&#34;&#34;
        if symbol not in self.positions or self.positions[symbol].direction != &#39;long&#39;:
            print(&#34;No long position to cover.&#34;)
            return
        fee = price * vol * self.feeRate
        self.totalFee &#43;= fee
        position_worth = self.positions[symbol].avg_price * vol
        pnl = (price - self.positions[symbol].avg_price) * vol
        self.cash &#43;= pnl &#43; position_worth - fee
        self._update_position(symbol, price, vol, &#39;cover_long&#39;, time)
        msg = f&#34;Cover long {symbol} at price: {price} for {vol} amount&#34;
        print(msg)
        msg_dict = {
            &#34;symbol&#34;: symbol,
            &#34;price&#34;: price,
            &#34;vol&#34;: vol,
            &#34;action&#34;: &#34;cover long&#34;
        }
        self.msg.append(msg_dict)

    def cover_short(self, price, symbol, vol, time):
        &#34;&#34;&#34;
        平掉空头仓位。
        :param price: 当前资产价格
        :param symbol: 资产符号
        :param vol: 平仓的资产数量
        :param time: 当前时间
        &#34;&#34;&#34;
        if symbol not in self.positions or self.positions[symbol].direction != &#39;short&#39;:
            print(&#34;No short position to cover.&#34;)
            return
        fee = price * vol * self.feeRate
        self.totalFee &#43;= fee
        position_worth = self.positions[symbol].avg_price * vol
        pnl = (self.positions[symbol].avg_price - price) * vol
        self.cash &#43;= pnl &#43; position_worth - fee
        self._update_position(symbol, price, vol, &#39;cover_short&#39;, time)
        msg = f&#34;Cover short {symbol} at price: {price} for {vol} amount&#34;
        print(msg)
        msg_dict = {
            &#34;symbol&#34;: symbol,
            &#34;price&#34;: price,
            &#34;vol&#34;: vol,
            &#34;action&#34;: &#34;cover short&#34;
        }
        self.msg.append(msg_dict)

    def calculate_total_account_equity(self, current_prices: dict):
        &#34;&#34;&#34;
        计算当前账户的总净值，包括现金和所有持仓的浮动盈亏。
        :param current_prices: dict，包含每个资产的当前价格，例如：{&#34;BTC&#34;: 40000, &#34;ETH&#34;: 3000}
        &#34;&#34;&#34;
        total_pnl = 0
        position_worth = 0
        for symbol, position in self.positions.items():
            if symbol in current_prices:
                current_price: BarData = current_prices[symbol]

                if position.direction == &#39;long&#39;:
                    pnl = (current_price.close - position.avg_price) * position.volume
                elif position.direction == &#39;short&#39;:
                    pnl = (position.avg_price - current_price.close) * position.volume
                position_worth &#43;= position.volume * position.avg_price
                total_pnl &#43;= pnl
        total_equity = self.cash &#43; total_pnl &#43; position_worth
        # print(f&#34;Total Account Equity: {total_equity:.2f} USD&#34;)
        return total_equity

    def get_current_pos_profit_rate(self, current_prices:dict):
        total_pnl = 0
        position_worth = 0
        for symbol, position in self.positions.items():
            if symbol in current_prices:
                current_price: BarData = current_prices[symbol]

                if position.direction == &#39;long&#39;:
                    pnl = (current_price.close - position.avg_price) * position.volume
                elif position.direction == &#39;short&#39;:
                    pnl = (position.avg_price - current_price.close) * position.volume
                position_worth &#43;= position.volume * position.avg_price
                total_pnl &#43;= pnl

        profit_rate = total_pnl / position_worth
        return profit_rate
">
<meta name="author" content="">
<link rel="canonical" href="https://oldhuntor.github.io/posts/codesnippets/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css" integrity="sha256-1vzSCk&#43;4bvpN&#43;sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://oldhuntor.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://oldhuntor.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://oldhuntor.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://oldhuntor.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://oldhuntor.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://oldhuntor.github.io/posts/codesnippets/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://oldhuntor.github.io/posts/codesnippets/">
  <meta property="og:site_name" content="Xuanhao&#39;s Blog">
  <meta property="og:title" content="Bayesian Cointegration codes">
  <meta property="og:description" content="Cointegration strategy backtesting framework from backtest_multi_symbols import Broker, BarData, Backtestor, Position, DailyBar from collections import deque from statsmodels.tsa.stattools import coint import pandas as pd import numpy as np from itertools import combinations from sklearn.linear_model import LinearRegression from statsmodels.tsa.stattools import adfuller from model_new.bayesian_regression import bayesian_rolling_window from model_new.jointCov2 import fit_HGP from model_new.BayesGAM import bayesian_gam_with_splines from model_new.BSTS import bsts_fit class Log: def __init__(self, broker: Broker): self.resultPath = &#39;backTestResult/backtestLog&#39; self.logs = [] self.broker = broker def logging(self, bars: dict): data = {} for symbol in bars: data[f&#34;close_{symbol}&#34;] = bars[symbol].close pos = self.broker.positions.get(symbol, 0) if pos != 0: data[f&#34;position_{symbol}&#34;] = self.broker.positions[symbol].volume data[f&#34;position_{symbol}_worth&#34;] = self.broker.positions[symbol].volume * bars[symbol].close data[&#39;time&#39;] = bars[symbol].time equity = self.broker.calculate_total_account_equity(bars) data[&#34;equity&#34;] = equity data[&#39;cash&#39;] = self.broker.cash self.logs.append(data) def save_logs(self): df = pd.DataFrame(self.logs) # df.to_csv(self.resultPath &#43; &#39;.csv&#39;, index=False) class BacktestorPairTrading(Backtestor): def __init__(self, broker: Broker, strategy, log, start, end): super().__init__(broker, strategy, log, start, end) self.log: Log = log def run_backtest(self): for i in range(self.data_length): bars = {} for symbol in self.symbols: data = self.data[f&#39;{symbol}&#39;].iloc[i] bar = BarData(data[&#39;timestamp&#39;], data[&#39;open&#39;], data[&#39;high&#39;], data[&#39;low&#39;], ((data[&#39;close&#39;])), data[&#39;volume&#39;]) bars[symbol] = bar self.strategy.processBar(bars) self.log.logging(bars) equity = self.broker.calculate_total_account_equity(bars) accountPNL = equity - self.strategy.initial_balance if accountPNL/self.strategy.initial_balance &lt; -self.strategy.stop_loss: print(f&#34;stop loss at {self.strategy.stop_loss} !!!&#34;) break self.on_close(bars) self.log.save_logs() def on_close(self, bars): if self.strategy.is_open: print(&#39;out of time force close&#39;) self.strategy.close_position_new(bars, ignore_diff=True) class Cointegration: def __init__(self, broker: Broker, setting: dict): self.short_leg = setting[&#39;short_leg&#39;] self.long_leg = setting[&#39;long_leg&#39;] self.open_margin = setting[&#39;open_margin&#39;] self.close_margin = setting[&#39;close_margin&#39;] self.grid_amount = setting[&#39;grid_amount&#39;] self.array_len = setting[&#39;array_len&#39;] self.stop_loss = setting[&#39;stop_loss&#39;] self.pValue = setting[&#39;pValue&#39;] self.initial_balance = broker.cash self.maximum_holding_period = setting[&#39;maximum_holding_period&#39;] self.broker = broker self.beta = None self.intercept = None self.mean = None self.dev = None self.start = False self.open_diff = None self.bar_array = deque(maxlen=self.array_len) self.spread_array = deque(maxlen=self.array_len) self.is_open = False self.holding_count = 0 def get_model(self): pass def get_legs(self): long_legs = [] short_legs = [] for i in range(self.array_len): bar = self.bar_array[i] long_legs.append(np.log(bar[self.long_leg])) short_legs.append(np.log(bar[self.short_leg])) return long_legs, short_legs def get_beta(self): long_legs, short_legs = self.get_legs() # 使用 scikit-learn 回归模型计算 Beta（不带截距） long_legs = np.array(long_legs).reshape(-1, 1) short_legs = np.array(short_legs) model = LinearRegression(fit_intercept=True).fit(long_legs, short_legs) beta = model.coef_[0] intercept = model.intercept_ return beta, intercept def get_beta_BayesRegression(self): long_legs, short_legs = self.get_legs() result = bayesian_rolling_window(long_legs, short_legs, window_size=20) y_values = result[&#39;y&#39;] beta_values = result[&#39;beta&#39;] mu_values = result[&#39;mu&#39;] epsilon_values = result[&#39;epsilon&#39;] y_pred_mean = y_values[&#39;mean&#39;] y_pred_upper = y_values[&#39;upper&#39;] y_pred_lower = y_values[&#39;lower&#39;] beta_posterior = beta_values[&#39;mean&#39;] beta_upper = beta_values[&#39;upper&#39;] beta_lower = beta_values[&#39;lower&#39;] mu_posterior = mu_values[&#39;mean&#39;] mu_upper = mu_values[&#39;upper&#39;] mu_lower = mu_values[&#39;lower&#39;] epsilon_mean = epsilon_values[&#39;mean&#39;] epsilon_upper = epsilon_values[&#39;upper&#39;] epsilon_lower = epsilon_values[&#39;lower&#39;] return beta_posterior[-1], mu_posterior[-1] def get_beta_GPs(self): long_legs, short_legs = self.get_legs() long_legs = np.array(long_legs) short_legs = np.array(short_legs) result = fit_HGP(long_legs, short_legs) y_values = result[&#39;y&#39;] beta_values = result[&#39;beta&#39;] mu_values = result[&#39;mu&#39;] epsilon_values = result[&#39;epsilon&#39;] y_pred_mean = y_values[&#39;mean&#39;] y_pred_upper = y_values[&#39;upper&#39;] y_pred_lower = y_values[&#39;lower&#39;] beta_posterior = beta_values[&#39;mean&#39;] beta_upper = beta_values[&#39;upper&#39;] beta_lower = beta_values[&#39;lower&#39;] mu_posterior = mu_values[&#39;mean&#39;] mu_upper = mu_values[&#39;upper&#39;] mu_lower = mu_values[&#39;lower&#39;] epsilon_mean = epsilon_values[&#39;mean&#39;] epsilon_upper = epsilon_values[&#39;upper&#39;] epsilon_lower = epsilon_values[&#39;lower&#39;] return np.float64(beta_posterior[-1]), np.float64(mu_posterior[-1]) def get_beta_BSTS(self): pass def get_beta_GAM(self): long_legs = [] short_legs = [] for i in range(self.array_len): bar = self.bar_array[i] long_legs.append(bar[self.long_leg]) short_legs.append(bar[self.short_leg]) long_legs = np.array(long_legs) short_legs = np.array(short_legs) result = bayesian_gam_with_splines(long_legs,short_legs,df=10) y_values = result[&#39;y&#39;] beta_values = result[&#39;beta&#39;] mu_values = result[&#39;mu&#39;] epsilon_values = result[&#39;epsilon&#39;] y_pred_mean = y_values[&#39;mean&#39;] y_pred_upper = y_values[&#39;upper&#39;] y_pred_lower = y_values[&#39;lower&#39;] beta_posterior = beta_values[&#39;mean&#39;] beta_upper = beta_values[&#39;upper&#39;] beta_lower = beta_values[&#39;lower&#39;] mu_posterior = mu_values[&#39;mean&#39;] mu_upper = mu_values[&#39;upper&#39;] mu_lower = mu_values[&#39;lower&#39;] epsilon_mean = epsilon_values[&#39;mean&#39;] epsilon_upper = epsilon_values[&#39;upper&#39;] epsilon_lower = epsilon_values[&#39;lower&#39;] return beta_posterior[-1], mu_posterior[-1] def processBar(self, bars: dict): from math import log # append log data bar = { self.short_leg: (bars[self.short_leg].close), self.long_leg: (bars[self.long_leg].close), } self.bar_array.append(bar) if len(self.bar_array) &lt; self.array_len: return p_value = self.coin_test() spread, _ = self.spread(bars) self.spread_array.append(spread) if len(self.spread_array) &lt; self.array_len/5: return if self.is_open: self.holding_count &#43;= 1 spread, _ = self.spread(bars) diff = (spread - self.mean) / self.dev if self.holding_count &gt;= self.maximum_holding_period: print(&#39;holding too long force quit&#39;) self.close_position_new(bars, ignore_diff=True) self.holding_count = 0 return if self.mean: diff = (spread - self.mean) / self.dev # print(f&#34;current diff {diff}&#34;) adf_center = adfuller(self.spread_array, regression=&#39;c&#39;)[1] adf_trend = adfuller(self.spread_array, regression=&#39;ct&#39;)[1] if adf_center &lt; self.pValue: self.is_stationary = True else: self.is_stationary = False # if adf_trend &lt; 0.05: # print(f&#39;adf ct test result {adf_trend}, has a trend, not enter trading&#39;) # return # if p_value &lt;= self.pValue: if self.is_stationary: self.hedge(bars) elif self.is_open: self.close_position_new(bars) def hedge(self, bars: dict): if not self.is_open: # self.open_position(bars) self.open_position_new(bars) else: self.close_position_new(bars) def open_position_new(self, bars: dict): spread, _ = self.spread(bars) self.mean, self.dev = self.get_diff(spread) diff = (spread - self.mean) / self.dev long_leg_price = (bars[self.long_leg].close) short_leg_price = (bars[self.short_leg].close) time = bars[self.short_leg].time short_leg_qty = self.grid_amount/(long_leg_price*abs(self.beta) &#43; short_leg_price) long_leg_qty = short_leg_qty*abs(self.beta) if abs(diff) &gt; 2: print( f&#39;open parameter beta: {self.beta}, intercept: {self.intercept}, spread mean:{self.mean}, spread dev {self.dev}, diff:{diff} , time:{time}&#39;) self.open_diff = diff if self.beta &lt; 0: if diff &gt; 0: self.broker.short( price=long_leg_price, symbol=self.long_leg, vol=long_leg_qty, leverage=1, time=time) self.broker.short( price=short_leg_price, symbol=self.short_leg, vol=short_leg_qty, leverage=1, time=time) self.is_open = True else: self.broker.long( price=long_leg_price, symbol=self.long_leg, vol=long_leg_qty, leverage=1, time=time) self.broker.long( price=short_leg_price, symbol=self.short_leg, vol=short_leg_qty, leverage=1, time=time) self.is_open = True else: if diff &gt; 0: self.broker.long( price=long_leg_price, symbol=self.long_leg, vol=long_leg_qty, leverage=1, time=time) self.broker.short( price=short_leg_price, symbol=self.short_leg, vol=short_leg_qty, leverage=1, time=time) self.is_open = True else: self.broker.long( price=short_leg_price, symbol=self.short_leg, vol=short_leg_qty, leverage=1, time=time) self.broker.short( price=long_leg_price, symbol=self.long_leg, vol=long_leg_qty, leverage=1, time=time) self.is_open = True def close_position_new(self, bars: dict, ignore_diff=False): spread, _ = self.spread(bars) diff = (spread - self.mean) / self.dev # calculate position pnl long_leg_price = (bars[self.long_leg].close) short_leg_price = (bars[self.short_leg].close) time = bars[self.short_leg].time long_leg_pos: Position = self.broker.positions[self.long_leg] short_leg_pos: Position = self.broker.positions[self.short_leg] # Close the position when the unrealize loss is too much !!! # profit_rate = self.broker.get_current_pos_profit_rate(bars) # if profit_rate &lt; -0.1: # print(&#39;position profit rate is too low, force quit&#39;) # ignore_diff = True if (self.open_diff &gt; 0 and diff &lt; 0) or (self.open_diff &lt; 0 and diff &gt; 0) or ignore_diff: # if abs(diff) &lt; -2 or ignore_diff: self.holding_count = 0 print( f&#39;close parameter beta: {self.beta}, intercept: {self.intercept}, spread mean:{self.mean}, spread dev {self.dev}, diff:{diff} , time:{time}&#39;) if short_leg_pos.direction == &#39;short&#39;: self.broker.cover_short( price=short_leg_price, symbol=self.short_leg, vol=short_leg_pos.volume, time=time) else: self.broker.cover_long( price=short_leg_price, symbol=self.short_leg, vol=short_leg_pos.volume, time=time) if long_leg_pos.direction == &#39;short&#39;: self.broker.cover_short( price=long_leg_price, symbol=self.long_leg, vol=long_leg_pos.volume, time=time) else: self.broker.cover_long( price=long_leg_price, symbol=self.long_leg, vol=long_leg_pos.volume, time=time) self.is_open = False self.beta, self.intercept = None, None def spread(self, bars: dict): long: BarData = bars[self.long_leg] short: BarData = bars[self.short_leg] long_price = (long.close) short_price = (short.close) spread = short_price - (self.beta * long_price &#43; self.intercept) diff = spread / (self.beta * long_price &#43; self.intercept) return spread, diff def get_diff(self, spread): mean = np.mean(self.spread_array) dev = np.std(self.spread_array) return mean, dev def coin_test(self): long_legs = [] short_legs = [] for i in range(self.array_len): bar = self.bar_array[i] long_legs.append(bar[self.long_leg]) short_legs.append(bar[self.short_leg]) if not self.beta: self.beta, self.intercept = self.get_beta_GPs() long_legs_modify = [] for i in range(self.array_len): new_long_leg = long_legs[i] * self.beta &#43; self.intercept long_legs_modify.append(new_long_leg) _, p_value, _ = coint(long_legs_modify, short_legs) return p_value def generate_combinations(symbols): return list(combinations(symbols, 2)) p_value = 0.99 stop_loss = 0.5 def main(selected_symbols): cash = 1000000 transactionFeeRate = 0 start = &#39;2023-01-01&#39; end = &#39;2024-10-31&#39; broker = Broker(cash, transactionFeeRate, selected_symbols) setting = { &#39;short_leg&#39;: selected_symbols[0], &#39;long_leg&#39;: selected_symbols[1], &#39;open_margin&#39;: 0.05, &#39;close_margin&#39;: 0.02, &#39;stop_loss&#39;: stop_loss, &#39;pValue&#39;: 0.05, &#39;grid_amount&#39;: cash * 0.2, &#39;array_len&#39;: 300, &#39;maximum_holding_period&#39;: 300, } strategy = Cointegration(broker, setting) log = Log(broker) backtestor = BacktestorPairTrading(broker, strategy, log, start, end) backtestor.load_data() backtestor.run_backtest() result = backtestor.performance() msg_df = pd.DataFrame(broker.msg) profit, loss, winrate = analyze_arbitrage_cycles(msg_df) # msg_df.to_csv(&#39;backTestResult/msg_df.csv&#39;) pnl_ratio = profit / loss result[&#39;pnl_ratio&#39;] = pnl_ratio result[&#39;win_rate&#39;] = winrate return result # msg_df = pd.DataFrame(broker.msg) # msg_df.to_csv(&#39;backTestResult/msg_df.csv&#39;) if __name__ == &#39;__main__&#39;: from backTestResult.cointegration_analysis import analyze_arbitrage_cycles cash = 1000000 transactionFeeRate = 0.00025 start = &#39;2023-01-01&#39; end = &#39;2024-10-31&#39; long_leg = &#39;DOGE&#39; short_leg = &#39;XRP&#39; selected_symbols = [long_leg, short_leg] broker = Broker(cash, transactionFeeRate, selected_symbols) setting = { &#39;short_leg&#39;: short_leg, &#39;long_leg&#39;: long_leg, &#39;open_margin&#39;: 0.05, &#39;close_margin&#39;: 0.04, &#39;stop_loss&#39;: 0.4, &#39;pValue&#39;: 0.05, &#39;grid_amount&#39;: cash * 0.2, &#39;array_len&#39;: 200, &#39;maximum_holding_period&#39;: 24* 30, } strategy = Cointegration(broker, setting) log = Log(broker) backtestor = BacktestorPairTrading(broker, strategy, log, start, end) backtestor.load_data() backtestor.run_backtest() result = backtestor.performance() msg_df = pd.DataFrame(broker.msg) analyze_arbitrage_cycles(msg_df) msg_df.to_csv(&#39;backTestResult/msg_df.csv&#39;) Bayesian regression def bayesian_rolling_window(X_t, Y_t, window_size=30): T = len(X_t) beta_t_est = np.zeros(T) mu_t_est = np.zeros(T) beta_var_est = np.zeros(T) mu_var_est = np.zeros(T) residual_var_est = np.zeros(T) Y_pred = np.zeros(T) Y_std_est = np.zeros(T) # Prior parameters beta_mean_prior = 0 beta_var_prior = 1 mu_mean_prior = 0 mu_var_prior = 1 sigma_prior = 1 for t in range(window_size, T): # Get rolling window data X_window = np.float64(X_t[t - window_size:t]) Y_window = np.float64(Y_t[t - window_size:t]) # Posterior parameters for beta XTX = np.sum(X_window ** 2) XTY = np.sum(X_window * (Y_window - np.mean(Y_window))) beta_var_post = 1 / (1 / beta_var_prior &#43; XTX / sigma_prior) beta_mean_post = beta_var_post * (beta_mean_prior / beta_var_prior &#43; XTY / sigma_prior) # Posterior parameters for mu mu_var_post = 1 / (1 / mu_var_prior &#43; window_size / sigma_prior) mu_mean_post = mu_var_post * (mu_mean_prior / mu_var_prior &#43; np.sum(Y_window - beta_mean_post * X_window) / sigma_prior) # Estimate residual variance residuals_window = Y_window - (beta_mean_post * X_window &#43; mu_mean_post) residual_var_est[t] = np.var(residuals_window) # Store estimates beta_t_est[t] = beta_mean_post mu_t_est[t] = mu_mean_post beta_var_est[t] = beta_var_post mu_var_est[t] = mu_var_post # Predict Y_t and its credible interval Y_pred[t] = beta_t_est[t] * X_t[t] &#43; mu_t_est[t] Y_var_est = (X_t[t] ** 2) * (beta_var_est[t]) &#43; (mu_var_est[t]) &#43; (1 / sigma_prior) Y_std_est[t] = np.sqrt(Y_var_est) # Prior parameters beta_mean_prior = beta_mean_post beta_var_prior = beta_var_post mu_mean_prior = mu_mean_post mu_var_prior = mu_var_post residuals = Y_t - Y_pred data = { &#39;y&#39;: { &#39;mean&#39;: Y_pred, &#39;upper&#39;: Y_pred &#43; 1.96 * Y_std_est, &#39;lower&#39;: Y_pred - 1.96 * Y_std_est }, &#39;beta&#39;: { &#39;mean&#39;: beta_t_est, &#39;upper&#39;: beta_t_est &#43; 1.96 * np.sqrt(beta_var_est), &#39;lower&#39;: beta_t_est - 1.96 * np.sqrt(beta_var_est) }, &#39;mu&#39;: { &#39;mean&#39;: mu_t_est, &#39;upper&#39;: mu_t_est &#43; 1.96 * np.sqrt(mu_var_est), &#39;lower&#39;: mu_t_est - 1.96 * np.sqrt(mu_var_est) }, &#39;epsilon&#39;: { &#39;mean&#39;: residuals, &#39;upper&#39;: residuals &#43; 1.96 * np.sqrt(residual_var_est), &#39;lower&#39;: residuals - 1.96 * np.sqrt(residual_var_est) }, } return data Bayesian GAM def bayesian_gam_with_splines(X_t, Y_t, df=10): T = len(X_t) time = np.linspace(0, 1, T) # Design matrices for splines design_matrix = patsy.dmatrix(f&#34;bs(time, df={df}, degree=3)&#34;, {&#34;time&#34;: time}, return_type=&#39;dataframe&#39;) # Joint Bayesian Ridge Regression for beta_t and mu_t X_joint = np.hstack([np.multiply(design_matrix.values, X_t[:, None]), design_matrix.values]) model_joint = BayesianRidge() model_joint.fit(X_joint, Y_t) # Predict values with uncertainties Y_pred, Y_std = model_joint.predict(X_joint, return_std=True) # Separate beta_t and mu_t beta_t_est = design_matrix.values @ model_joint.coef_[:design_matrix.shape[1]] mu_t_est = design_matrix.values @ model_joint.coef_[design_matrix.shape[1]:] # Compute standard deviations for beta and mu coef_cov = np.linalg.inv(model_joint.alpha_ * np.eye(X_joint.shape[1]) &#43; model_joint.lambda_ * X_joint.T @ X_joint) beta_std_est = np.sqrt(np.sum((design_matrix.values @ coef_cov[:design_matrix.shape[1], :design_matrix.shape[1]]) * design_matrix.values, axis=1)) mu_std_est = np.sqrt(np.sum((design_matrix.values @ coef_cov[design_matrix.shape[1]:, design_matrix.shape[1]:]) * design_matrix.values, axis=1)) # Posterior variance of noise residual_var_est = 1 / model_joint.alpha_ # Posterior noise variance residuals = Y_t - Y_pred data = { &#39;y&#39;: { &#39;mean&#39;: Y_pred, &#39;upper&#39;: Y_pred &#43; 1.96 * Y_std, &#39;lower&#39;: Y_pred - 1.96 * Y_std }, &#39;beta&#39;: { &#39;mean&#39;: beta_t_est, &#39;upper&#39;: beta_t_est &#43; 1.96 * beta_std_est, &#39;lower&#39;: beta_t_est - 1.96 * beta_std_est }, &#39;mu&#39;: { &#39;mean&#39;: mu_t_est, &#39;upper&#39;: mu_t_est &#43; 1.96 * mu_std_est, &#39;lower&#39;: mu_t_est - 1.96 * mu_std_est }, &#39;epsilon&#39;: { &#39;mean&#39;: residuals, &#39;upper&#39;: residuals &#43; 1.96 * np.sqrt(residual_var_est), &#39;lower&#39;: residuals - 1.96 * np.sqrt(residual_var_est) }, } return data Gaussian Process class TimeVaryingGP(ExactGP): def __init__(self, train_x, train_y, likelihood): super(TimeVaryingGP, self).__init__(train_x, train_y, likelihood) # Separate kernels for each component self.beta_kernel = ScaleKernel(RBFKernel()) # self.beta_kernel.base_kernel.register_prior( # &#39;lengthscale_prior&#39;, # gpytorch.priors.GammaPrior(10.0, 20.0), # &#39;lengthscale&#39; # ) self.mu_kernel = ScaleKernel(RBFKernel()) self.eps_kernel = ScaleKernel(RBFKernel()) self.mean = ZeroMean() def forward(self, x): # Extract time and covariates t = x[:, 0] # time index X = x[:, 1] # covariate # Compute kernel matrices K_beta = self.beta_kernel(t) K_mu = self.mu_kernel(t) K_eps = self.eps_kernel(t) # Compute covariance matrix covar = X.unsqueeze(1) * K_beta * X.unsqueeze(0) &#43; K_mu &#43; K_eps mean = self.mean(x) return MultivariateNormal(mean, covar) def train_model(X, y, n_iter=100): if not isinstance(X, torch.Tensor): X = torch.from_numpy(X).clone().detach().float() y = torch.from_numpy(y).clone().detach().float() else: X = X.clone().detach().float() y = y.clone().detach().float() # Initialize model likelihood = gpytorch.likelihoods.GaussianLikelihood() model = TimeVaryingGP(X, y, likelihood) # Use the adam optimizer optimizer = torch.optim.Adam([ {&#39;params&#39;: model.parameters()}, ], lr=0.1) # &#34;Loss&#34; for GPs - the marginal log likelihood mll = gpytorch.mlls.ExactMarginalLogLikelihood(likelihood, model) # Training loop model.train() likelihood.train() for i in range(n_iter): optimizer.zero_grad() output = model(X) loss = -mll(output, y) loss.backward() optimizer.step() return model, likelihood def predict_latent(model, X_train, y_train, X_new): model.eval() jitter = 1e-6 with torch.no_grad(): t_train = X_train[:, 0] x_train = X_train[:, 1] t_new = X_new[:, 0] x_new = X_new[:, 1] K_beta = model.beta_kernel(t_new, t_train).evaluate() K_mu = model.mu_kernel(t_new, t_train).evaluate() K_eps = model.eps_kernel(t_new, t_train).evaluate() K_total = x_train * model.beta_kernel(t_train).evaluate() * x_train.unsqueeze(-1) &#43; \ model.mu_kernel(t_train).evaluate() &#43; \ model.eps_kernel(t_train).evaluate() &#43; \ model.likelihood.noise * torch.eye(len(t_train)) &#43; \ jitter * torch.eye(len(t_train)) K_new_beta = model.beta_kernel(t_new).evaluate() &#43; jitter * torch.eye(len(t_new)) K_new_mu = model.mu_kernel(t_new).evaluate() &#43; jitter * torch.eye(len(t_new)) K_new_eps = model.eps_kernel(t_new).evaluate() &#43; jitter * torch.eye(len(t_new)) # Compute posterior mean using Cholesky L = torch.linalg.cholesky(K_total) alpha = torch.linalg.solve_triangular(L, y_train.unsqueeze(1), upper=False) alpha = torch.linalg.solve_triangular(L.T, alpha, upper=True) K_stacked = torch.stack([ x_new.unsqueeze(-1) * K_beta, K_mu, K_eps ]) posterior_mean = K_stacked @ alpha # Compute posterior variance using Cholesky v_beta = torch.linalg.solve_triangular(L, (x_train * K_beta.T).T, upper=False) v_mu = torch.linalg.solve_triangular(L, K_mu.T, upper=False) v_eps = torch.linalg.solve_triangular(L, K_eps.T, upper=False) post_var_beta = K_new_beta - v_beta.T @ v_beta post_var_mu = K_new_mu - v_mu.T @ v_mu post_var_eps = K_new_eps - v_eps.T @ v_eps return { &#39;mean&#39;: { &#39;beta&#39;: posterior_mean[0].squeeze(), &#39;mu&#39;: posterior_mean[1].squeeze(), &#39;epsilon&#39;: posterior_mean[2].squeeze() }, &#39;variance&#39;: { &#39;beta&#39;: post_var_beta.diag(), &#39;mu&#39;: post_var_mu.diag(), &#39;epsilon&#39;: post_var_eps.diag() } } def predict(model, likelihood, X_new, X_train=None, y_train=None): model.eval() likelihood.eval() if X_train is None: X_train = model.train_inputs[0] if y_train is None: y_train = model.train_targets with torch.no_grad(), gpytorch.settings.fast_pred_var(): observed_pred = likelihood(model(X_new)) latent_values = predict_latent(model, X_train, y_train, X_new) return observed_pred.mean, observed_pred.variance, latent_values BSTS def bsts_fit(x,y): with pm.Model() as model: # Priors for variances # sigma = pm.HalfCauchy(&#39;sigma&#39;, beta=1) # Random walk for log volatility log_sigma = pm.GaussianRandomWalk(&#39;log_sigma&#39;, sigma=0.1, shape=len(y), init_dist=pm.Normal.dist(mu=0, sigma=1)) sigma = pm.Deterministic(&#39;sigma&#39;, pm.math.exp(log_sigma)) sigma_beta = pm.HalfCauchy(&#39;sigma_beta&#39;, beta=1) sigma_mu = pm.HalfCauchy(&#39;sigma_mu&#39;, beta=1) # Gaussian Random Walks for beta and mu beta = pm.GaussianRandomWalk(&#39;beta&#39;, sigma=sigma_beta, init_dist=pm.Normal.dist(0, 10), shape=len(y)) mu = pm.GaussianRandomWalk(&#39;mu&#39;, sigma=sigma_mu, init_dist=pm.Normal.dist(0, 10), shape=len(y)) # Observation model Y_obs = pm.Normal(&#39;Y_obs&#39;, mu=beta * x &#43; mu, sigma=sigma, observed=y) # ---- 3. MCMC Sampling ---- trace = pm.sample(1000, tune=1000, chains=2, target_accept=0.9) ppc = pm.sample_posterior_predictive(trace, var_names=[&#34;Y_obs&#34;], random_seed=42) # Extract posterior mean and 95% credible intervals beta_posterior = trace.posterior[&#39;beta&#39;].mean(dim=(&#34;chain&#34;, &#34;draw&#34;)) beta_lower = trace.posterior[&#39;beta&#39;].quantile(0.025, dim=(&#34;chain&#34;, &#34;draw&#34;)) beta_upper = trace.posterior[&#39;beta&#39;].quantile(0.975, dim=(&#34;chain&#34;, &#34;draw&#34;)) mu_posterior = trace.posterior[&#39;mu&#39;].mean(dim=(&#34;chain&#34;, &#34;draw&#34;)) mu_lower = trace.posterior[&#39;mu&#39;].quantile(0.025, dim=(&#34;chain&#34;, &#34;draw&#34;)) mu_upper = trace.posterior[&#39;mu&#39;].quantile(0.975, dim=(&#34;chain&#34;, &#34;draw&#34;)) # Extract posterior predictive samples y_pred_samples = ppc.posterior_predictive[&#39;Y_obs&#39;] # Calculate mean and 95% prediction interval y_pred_mean = y_pred_samples.mean(dim=(&#39;chain&#39;, &#39;draw&#39;)).values y_pred_lower = np.percentile(y_pred_samples.values, 2.5, axis=(0, 1)) # 2.5% quantile y_pred_upper = np.percentile(y_pred_samples.values, 97.5, axis=(0, 1)) # 97.5% quantile epsilon_samples = y - y_pred_samples.values # Shape: (chains, draws, time) # ---- 3. Calculate Mean and Intervals ---- # Mean residuals epsilon_mean = epsilon_samples.mean(axis=(0, 1)) # Average over chains and draws # 95% prediction intervals epsilon_lower = np.percentile(epsilon_samples, 2.5, axis=(0, 1)) epsilon_upper = np.percentile(epsilon_samples, 97.5, axis=(0, 1)) data = { &#39;y&#39;: { &#39;mean&#39;: y_pred_mean, &#39;upper&#39;: y_pred_upper, &#39;lower&#39;: y_pred_lower }, &#39;beta&#39;: { &#39;mean&#39;: beta_posterior, &#39;upper&#39;: beta_upper, &#39;lower&#39;: beta_lower }, &#39;mu&#39;: { &#39;mean&#39;: mu_posterior, &#39;upper&#39;: mu_upper, &#39;lower&#39;: mu_lower }, &#39;epsilon&#39;: { &#39;mean&#39;: epsilon_mean, &#39;upper&#39;: epsilon_upper, &#39;lower&#39;: epsilon_lower }, } return data Gaussian Process clustering import pandas as pd import numpy as np from sklearn.cluster import KMeans import gpytorch import torch class SparseGPModel(gpytorch.models.ApproximateGP): def __init__(self, inducing_points): variational_distribution = gpytorch.variational.CholeskyVariationalDistribution(inducing_points.size(0)) variational_strategy = gpytorch.variational.VariationalStrategy( self, inducing_points, variational_distribution, learn_inducing_locations=True ) super().__init__(variational_strategy) # Define kernel: RBF kernel with constant mean self.mean_module = gpytorch.means.ConstantMean() self.covar_module = gpytorch.kernels.ScaleKernel(gpytorch.kernels.RBFKernel()) def forward(self, x): mean_x = self.mean_module(x) covar_x = self.covar_module(x) return gpytorch.distributions.MultivariateNormal(mean_x, covar_x) def sparse_gpr_hyperparameter_clustering(data, n_clusters=3, num_inducing=10, verbose=True): symbols = data.iloc[:, 0].values time_points = torch.tensor(np.arange(data.shape[1] - 1), dtype=torch.float32) # Time indices time_series = torch.tensor(data.iloc[:, 1:].values, dtype=torch.float32) # Time series values # Initialize list to store hyperparameters hyperparameters = [] if verbose: print(&#34;Starting Sparse Gaussian Process Regression for each stock...\n&#34;) for idx, ts in enumerate(time_series): ts = ts.unsqueeze(-1) # Add a dimension for compatibility (n_samples, 1) inducing_points = time_points[::len(time_points) // num_inducing][:num_inducing].unsqueeze(-1) model = SparseGPModel(inducing_points) likelihood = gpytorch.likelihoods.GaussianLikelihood() model.train() likelihood.train() optimizer = torch.optim.Adam(model.parameters(), lr=0.1) mll = gpytorch.mlls.VariationalELBO(likelihood, model, num_data=len(time_points)) # Training loop (simple with fixed iterations for now) training_iter = 100 # You can adjust this for i in range(training_iter): optimizer.zero_grad() output = model(time_points.unsqueeze(-1)) loss = -mll(output, ts).sum() loss.backward() optimizer.step() # Extract learned hyperparameters kernel_params = model.covar_module.base_kernel.lengthscale.item() outputscale = model.covar_module.outputscale.item() noise = likelihood.noise.item() hyperparameters.append([outputscale, kernel_params, noise]) if verbose: print(f&#34;Processed {idx &#43; 1}/{len(time_series)}: Symbol = {symbols[idx]}, &#34; f&#34;Output Scale = {outputscale:.3f}, Length Scale = {kernel_params:.3f}, noise = {noise:.3f}&#34;) if verbose: print(&#34;\nFinished Sparse Gaussian Process Regression.&#34;) print(&#34;Starting clustering on hyperparameters...\n&#34;) # Perform clustering on hyperparameters hyperparameters = np.array(hyperparameters) kmeans = KMeans(n_clusters=n_clusters, random_state=0) labels = kmeans.fit_predict(hyperparameters) clusters = {} for cluster_id in range(n_clusters): clusters[f&#39;Cluster{cluster_id&#43;1}&#39;] = symbols[labels == cluster_id].tolist() if verbose: print(f&#34;Cluster {cluster_id &#43; 1}: {len(clusters[f&#39;Cluster{cluster_id&#43;1}&#39;])} symbols&#34;) if verbose: print(&#34;\nClustering complete. Summary:&#34;) for cluster, symbols in clusters.items(): print(f&#34;{cluster}: {symbols}&#34;) return clusters df = pd.read_csv(&#39;Quantitative_Research/model_new/bayesian_clustering/transposed_stock_data.csv&#39;) clusters = sparse_gpr_hyperparameter_clustering(df, n_clusters=10, verbose=True) print(clusters) Appendix broker object class Broker: def __init__(self, cash: float, feeRate: float, symbols: list): self.positions = {} self.wallet = {} for symbol in symbols: self.wallet[symbol] = 0 self.cash = cash self.feeRate = feeRate self.totalFee = 0 self.symbols = symbols self.msg = [] def buy(self, price, symbol, vol): # cash = self.cash # if cash - price * vol * (1 &#43; self.feeRate) &lt; 0: # # print(&#34;not enough cash, but amount that minus fees&#34;) # vol -= price * vol * self.feeRate / price self.cash -= price * vol * (1 &#43; self.feeRate) self.wallet[symbol] &#43;= vol self.totalFee &#43;= price * vol * self.feeRate msg = f&#34;Buy {symbol} at price: {price} for {vol} amount&#34; print(msg) msg_dict = { &#34;symbol&#34;: symbol, &#34;price&#34;: price, &#34;vol&#34;: vol, &#34;action&#34;: &#34;buy&#34; } self.msg.append(msg_dict) def sell(self, price, symbol, vol): self.cash &#43;= price * vol * (1 - self.feeRate) self.wallet[symbol] -= vol self.totalFee &#43;= price * vol * self.feeRate msg = f&#34;Sell {symbol} at price: {price} for {vol} amount&#34; print(msg) msg_dict = { &#34;symbol&#34;: symbol, &#34;price&#34;: price, &#34;vol&#34;: vol, &#34;action&#34;: &#34;sell&#34; } self.msg.append(msg_dict) def _update_position(self, symbol, price, vol, direction, time): if symbol in self.positions: position = self.positions[symbol] if position.direction == direction: # 加仓，计算新的加权平均价格 new_volume = position.volume &#43; vol new_avg_price = (position.avg_price * position.volume &#43; price * vol) / new_volume position.avg_price = new_avg_price position.volume = new_volume position.time = time else: # 如果方向相反，考虑部分平仓或完全平仓的情况 if abs(position.volume) &gt; vol: # 部分平仓 position.volume -= vol elif abs(position.volume) == vol: # 完全平仓，删除仓位 del self.positions[symbol] else: # 平掉原仓位并开立新方向的仓位 new_vol = vol - abs(position.volume) position.direction = direction position.avg_price = price position.volume = new_vol position.time = time else: # 开立新仓位 self.positions[symbol] = Position(time=time, avg_price=price, symbol=symbol, direction=direction, volume=vol) def long(self, price, symbol, vol, leverage, time): &#34;&#34;&#34; 开立多头仓位，使用杠杆购买资产。 :param price: 当前资产价格 :param symbol: 资产符号 :param vol: 购买的资产数量 :param leverage: 杠杆倍数 :param time: 当前时间 &#34;&#34;&#34; margin_required = (price * vol) / leverage # if self.cash &lt; margin_required: # print(&#34;Not enough cash to open long position with leverage.&#34;) # return self.cash -= margin_required fee = price * vol * self.feeRate self.totalFee &#43;= fee self._update_position(symbol, price, vol * leverage, &#39;long&#39;, time) msg = f&#34;Long {symbol} at price: {price} for {vol} amount with leverage {leverage}&#34; print(msg) msg_dict = { &#34;symbol&#34;: symbol, &#34;price&#34;: price, &#34;vol&#34;: vol, &#34;action&#34;: &#34;long&#34; } self.msg.append(msg_dict) def short(self, price, symbol, vol, leverage, time): &#34;&#34;&#34; 开立空头仓位，使用杠杆卖出资产。 :param price: 当前资产价格 :param symbol: 资产符号 :param vol: 卖出的资产数量 :param leverage: 杠杆倍数 :param time: 当前时间 &#34;&#34;&#34; margin_required = (price * vol) / leverage # if self.cash &lt; margin_required: # print(&#34;Not enough cash to open short position with leverage.&#34;) # return self.cash -= margin_required fee = price * vol * self.feeRate self.totalFee &#43;= fee self._update_position(symbol, price, vol * leverage, &#39;short&#39;, time) msg = f&#34;Short {symbol} at price: {price} for {vol} amount with leverage {leverage}&#34; print(msg) msg_dict = { &#34;symbol&#34;: symbol, &#34;price&#34;: price, &#34;vol&#34;: vol, &#34;action&#34;: &#34;short&#34; } self.msg.append(msg_dict) def cover_long(self, price, symbol, vol, time): &#34;&#34;&#34; 平掉多头仓位。 :param price: 当前资产价格 :param symbol: 资产符号 :param vol: 平仓的资产数量 :param time: 当前时间 &#34;&#34;&#34; if symbol not in self.positions or self.positions[symbol].direction != &#39;long&#39;: print(&#34;No long position to cover.&#34;) return fee = price * vol * self.feeRate self.totalFee &#43;= fee position_worth = self.positions[symbol].avg_price * vol pnl = (price - self.positions[symbol].avg_price) * vol self.cash &#43;= pnl &#43; position_worth - fee self._update_position(symbol, price, vol, &#39;cover_long&#39;, time) msg = f&#34;Cover long {symbol} at price: {price} for {vol} amount&#34; print(msg) msg_dict = { &#34;symbol&#34;: symbol, &#34;price&#34;: price, &#34;vol&#34;: vol, &#34;action&#34;: &#34;cover long&#34; } self.msg.append(msg_dict) def cover_short(self, price, symbol, vol, time): &#34;&#34;&#34; 平掉空头仓位。 :param price: 当前资产价格 :param symbol: 资产符号 :param vol: 平仓的资产数量 :param time: 当前时间 &#34;&#34;&#34; if symbol not in self.positions or self.positions[symbol].direction != &#39;short&#39;: print(&#34;No short position to cover.&#34;) return fee = price * vol * self.feeRate self.totalFee &#43;= fee position_worth = self.positions[symbol].avg_price * vol pnl = (self.positions[symbol].avg_price - price) * vol self.cash &#43;= pnl &#43; position_worth - fee self._update_position(symbol, price, vol, &#39;cover_short&#39;, time) msg = f&#34;Cover short {symbol} at price: {price} for {vol} amount&#34; print(msg) msg_dict = { &#34;symbol&#34;: symbol, &#34;price&#34;: price, &#34;vol&#34;: vol, &#34;action&#34;: &#34;cover short&#34; } self.msg.append(msg_dict) def calculate_total_account_equity(self, current_prices: dict): &#34;&#34;&#34; 计算当前账户的总净值，包括现金和所有持仓的浮动盈亏。 :param current_prices: dict，包含每个资产的当前价格，例如：{&#34;BTC&#34;: 40000, &#34;ETH&#34;: 3000} &#34;&#34;&#34; total_pnl = 0 position_worth = 0 for symbol, position in self.positions.items(): if symbol in current_prices: current_price: BarData = current_prices[symbol] if position.direction == &#39;long&#39;: pnl = (current_price.close - position.avg_price) * position.volume elif position.direction == &#39;short&#39;: pnl = (position.avg_price - current_price.close) * position.volume position_worth &#43;= position.volume * position.avg_price total_pnl &#43;= pnl total_equity = self.cash &#43; total_pnl &#43; position_worth # print(f&#34;Total Account Equity: {total_equity:.2f} USD&#34;) return total_equity def get_current_pos_profit_rate(self, current_prices:dict): total_pnl = 0 position_worth = 0 for symbol, position in self.positions.items(): if symbol in current_prices: current_price: BarData = current_prices[symbol] if position.direction == &#39;long&#39;: pnl = (current_price.close - position.avg_price) * position.volume elif position.direction == &#39;short&#39;: pnl = (position.avg_price - current_price.close) * position.volume position_worth &#43;= position.volume * position.avg_price total_pnl &#43;= pnl profit_rate = total_pnl / position_worth return profit_rate ">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-01-25T19:12:16+01:00">
    <meta property="article:modified_time" content="2025-01-25T19:12:16+01:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Bayesian Cointegration codes">
<meta name="twitter:description" content="Cointegration strategy backtesting framework
from backtest_multi_symbols import Broker, BarData, Backtestor, Position, DailyBar
from collections import deque
from statsmodels.tsa.stattools import coint
import pandas as pd
import numpy as np
from itertools import combinations
from sklearn.linear_model import LinearRegression
from statsmodels.tsa.stattools import adfuller

from model_new.bayesian_regression import bayesian_rolling_window
from model_new.jointCov2 import fit_HGP
from model_new.BayesGAM import bayesian_gam_with_splines
from model_new.BSTS import bsts_fit



class Log:
    def __init__(self, broker: Broker):
        self.resultPath = &#39;backTestResult/backtestLog&#39;
        self.logs = []
        self.broker = broker

    def logging(self, bars: dict):
        data = {}
        for symbol in bars:
            data[f&#34;close_{symbol}&#34;] = bars[symbol].close
            pos = self.broker.positions.get(symbol, 0)
            if pos != 0:
                data[f&#34;position_{symbol}&#34;] = self.broker.positions[symbol].volume
                data[f&#34;position_{symbol}_worth&#34;] = self.broker.positions[symbol].volume * bars[symbol].close

            data[&#39;time&#39;] = bars[symbol].time

        equity = self.broker.calculate_total_account_equity(bars)
        data[&#34;equity&#34;] = equity
        data[&#39;cash&#39;] = self.broker.cash
        self.logs.append(data)

    def save_logs(self):
        df = pd.DataFrame(self.logs)
        # df.to_csv(self.resultPath &#43; &#39;.csv&#39;, index=False)


class BacktestorPairTrading(Backtestor):
    def __init__(self, broker: Broker, strategy, log, start, end):
        super().__init__(broker, strategy, log, start, end)
        self.log: Log = log

    def run_backtest(self):
        for i in range(self.data_length):
            bars = {}
            for symbol in self.symbols:
                data = self.data[f&#39;{symbol}&#39;].iloc[i]
                bar = BarData(data[&#39;timestamp&#39;], data[&#39;open&#39;], data[&#39;high&#39;], data[&#39;low&#39;], ((data[&#39;close&#39;])),
                              data[&#39;volume&#39;])
                bars[symbol] = bar
            self.strategy.processBar(bars)
            self.log.logging(bars)
            equity = self.broker.calculate_total_account_equity(bars)
            accountPNL = equity - self.strategy.initial_balance
            if accountPNL/self.strategy.initial_balance &lt; -self.strategy.stop_loss:
                print(f&#34;stop loss at {self.strategy.stop_loss} !!!&#34;)
                break

        self.on_close(bars)
        self.log.save_logs()

    def on_close(self, bars):
        if self.strategy.is_open:
            print(&#39;out of time force close&#39;)
            self.strategy.close_position_new(bars, ignore_diff=True)


class Cointegration:
    def __init__(self, broker: Broker, setting: dict):
        self.short_leg = setting[&#39;short_leg&#39;]
        self.long_leg = setting[&#39;long_leg&#39;]
        self.open_margin = setting[&#39;open_margin&#39;]
        self.close_margin = setting[&#39;close_margin&#39;]
        self.grid_amount = setting[&#39;grid_amount&#39;]
        self.array_len = setting[&#39;array_len&#39;]
        self.stop_loss = setting[&#39;stop_loss&#39;]
        self.pValue = setting[&#39;pValue&#39;]
        self.initial_balance = broker.cash
        self.maximum_holding_period = setting[&#39;maximum_holding_period&#39;]
        self.broker = broker
        self.beta = None
        self.intercept = None
        self.mean = None
        self.dev = None
        self.start = False
        self.open_diff = None
        self.bar_array = deque(maxlen=self.array_len)
        self.spread_array = deque(maxlen=self.array_len)
        self.is_open = False
        self.holding_count = 0

    def get_model(self):
        pass

    def get_legs(self):
        long_legs = []
        short_legs = []
        for i in range(self.array_len):

            bar = self.bar_array[i]
            long_legs.append(np.log(bar[self.long_leg]))
            short_legs.append(np.log(bar[self.short_leg]))

        return long_legs, short_legs

    def get_beta(self):
        long_legs, short_legs = self.get_legs()

        # 使用 scikit-learn 回归模型计算 Beta（不带截距）
        long_legs = np.array(long_legs).reshape(-1, 1)
        short_legs = np.array(short_legs)
        model = LinearRegression(fit_intercept=True).fit(long_legs, short_legs)
        beta = model.coef_[0]
        intercept = model.intercept_
        return beta, intercept

    def get_beta_BayesRegression(self):
        long_legs, short_legs = self.get_legs()
        result = bayesian_rolling_window(long_legs, short_legs, window_size=20)

        y_values = result[&#39;y&#39;]
        beta_values = result[&#39;beta&#39;]
        mu_values = result[&#39;mu&#39;]
        epsilon_values = result[&#39;epsilon&#39;]

        y_pred_mean = y_values[&#39;mean&#39;]
        y_pred_upper = y_values[&#39;upper&#39;]
        y_pred_lower = y_values[&#39;lower&#39;]

        beta_posterior = beta_values[&#39;mean&#39;]
        beta_upper = beta_values[&#39;upper&#39;]
        beta_lower = beta_values[&#39;lower&#39;]

        mu_posterior = mu_values[&#39;mean&#39;]
        mu_upper = mu_values[&#39;upper&#39;]
        mu_lower = mu_values[&#39;lower&#39;]

        epsilon_mean = epsilon_values[&#39;mean&#39;]
        epsilon_upper = epsilon_values[&#39;upper&#39;]
        epsilon_lower = epsilon_values[&#39;lower&#39;]

        return beta_posterior[-1], mu_posterior[-1]

    def get_beta_GPs(self):
        long_legs, short_legs = self.get_legs()
        long_legs = np.array(long_legs)
        short_legs = np.array(short_legs)
        result = fit_HGP(long_legs, short_legs)

        y_values = result[&#39;y&#39;]
        beta_values = result[&#39;beta&#39;]
        mu_values = result[&#39;mu&#39;]
        epsilon_values = result[&#39;epsilon&#39;]

        y_pred_mean = y_values[&#39;mean&#39;]
        y_pred_upper = y_values[&#39;upper&#39;]
        y_pred_lower = y_values[&#39;lower&#39;]

        beta_posterior = beta_values[&#39;mean&#39;]
        beta_upper = beta_values[&#39;upper&#39;]
        beta_lower = beta_values[&#39;lower&#39;]

        mu_posterior = mu_values[&#39;mean&#39;]
        mu_upper = mu_values[&#39;upper&#39;]
        mu_lower = mu_values[&#39;lower&#39;]

        epsilon_mean = epsilon_values[&#39;mean&#39;]
        epsilon_upper = epsilon_values[&#39;upper&#39;]
        epsilon_lower = epsilon_values[&#39;lower&#39;]

        return np.float64(beta_posterior[-1]), np.float64(mu_posterior[-1])

    def get_beta_BSTS(self):
        pass

    def get_beta_GAM(self):
        long_legs = []
        short_legs = []
        for i in range(self.array_len):
            bar = self.bar_array[i]
            long_legs.append(bar[self.long_leg])
            short_legs.append(bar[self.short_leg])
        long_legs = np.array(long_legs)
        short_legs = np.array(short_legs)

        result = bayesian_gam_with_splines(long_legs,short_legs,df=10)
        y_values = result[&#39;y&#39;]
        beta_values = result[&#39;beta&#39;]
        mu_values = result[&#39;mu&#39;]
        epsilon_values = result[&#39;epsilon&#39;]

        y_pred_mean = y_values[&#39;mean&#39;]
        y_pred_upper = y_values[&#39;upper&#39;]
        y_pred_lower = y_values[&#39;lower&#39;]

        beta_posterior = beta_values[&#39;mean&#39;]
        beta_upper = beta_values[&#39;upper&#39;]
        beta_lower = beta_values[&#39;lower&#39;]

        mu_posterior = mu_values[&#39;mean&#39;]
        mu_upper = mu_values[&#39;upper&#39;]
        mu_lower = mu_values[&#39;lower&#39;]

        epsilon_mean = epsilon_values[&#39;mean&#39;]
        epsilon_upper = epsilon_values[&#39;upper&#39;]
        epsilon_lower = epsilon_values[&#39;lower&#39;]

        return beta_posterior[-1], mu_posterior[-1]


    def processBar(self, bars: dict):
        from math import log
        # append log data
        bar = {
            self.short_leg: (bars[self.short_leg].close),
            self.long_leg: (bars[self.long_leg].close),
        }
        self.bar_array.append(bar)
        if len(self.bar_array) &lt; self.array_len:
            return

        p_value = self.coin_test()

        spread, _ = self.spread(bars)
        self.spread_array.append(spread)
        if len(self.spread_array) &lt; self.array_len/5:
            return

        if self.is_open:
            self.holding_count &#43;= 1
            spread, _ = self.spread(bars)
            diff = (spread - self.mean) / self.dev
            if self.holding_count &gt;= self.maximum_holding_period:
                print(&#39;holding too long force quit&#39;)
                self.close_position_new(bars, ignore_diff=True)
                self.holding_count = 0
                return

        if self.mean:
            diff = (spread - self.mean) / self.dev
            # print(f&#34;current diff {diff}&#34;)

        adf_center = adfuller(self.spread_array, regression=&#39;c&#39;)[1]
        adf_trend = adfuller(self.spread_array, regression=&#39;ct&#39;)[1]

        if adf_center &lt; self.pValue:
            self.is_stationary = True
        else:
            self.is_stationary = False

        # if adf_trend &lt; 0.05:
        #     print(f&#39;adf ct test result {adf_trend}, has a trend, not enter trading&#39;)
        #     return

        # if p_value &lt;= self.pValue:
        if self.is_stationary:
            self.hedge(bars)
        elif self.is_open:
            self.close_position_new(bars)

    def hedge(self, bars: dict):
        if not self.is_open:
            # self.open_position(bars)
            self.open_position_new(bars)
        else:
            self.close_position_new(bars)

    def open_position_new(self, bars: dict):
        spread, _ = self.spread(bars)
        self.mean, self.dev = self.get_diff(spread)
        diff = (spread - self.mean) / self.dev
        long_leg_price = (bars[self.long_leg].close)
        short_leg_price = (bars[self.short_leg].close)
        time = bars[self.short_leg].time
        short_leg_qty = self.grid_amount/(long_leg_price*abs(self.beta) &#43; short_leg_price)
        long_leg_qty = short_leg_qty*abs(self.beta)
        if abs(diff) &gt; 2:
            print(
                f&#39;open parameter beta: {self.beta}, intercept: {self.intercept}, spread mean:{self.mean}, spread dev {self.dev}, diff:{diff} , time:{time}&#39;)
            self.open_diff = diff
            if self.beta &lt; 0:

                if diff &gt; 0:

                    self.broker.short(
                        price=long_leg_price,
                        symbol=self.long_leg,
                        vol=long_leg_qty,
                        leverage=1,
                        time=time)

                    self.broker.short(
                        price=short_leg_price,
                        symbol=self.short_leg,
                        vol=short_leg_qty,
                        leverage=1,
                        time=time)

                    self.is_open = True

                else:
                    self.broker.long(
                        price=long_leg_price,
                        symbol=self.long_leg,
                        vol=long_leg_qty,
                        leverage=1,
                        time=time)

                    self.broker.long(
                        price=short_leg_price,
                        symbol=self.short_leg,
                        vol=short_leg_qty,
                        leverage=1,
                        time=time)

                    self.is_open = True

            else:
                if diff &gt; 0:
                    self.broker.long(
                        price=long_leg_price,
                        symbol=self.long_leg,
                        vol=long_leg_qty,
                        leverage=1,
                        time=time)

                    self.broker.short(
                        price=short_leg_price,
                        symbol=self.short_leg,
                        vol=short_leg_qty,
                        leverage=1,
                        time=time)

                    self.is_open = True

                else:
                    self.broker.long(
                        price=short_leg_price,
                        symbol=self.short_leg,
                        vol=short_leg_qty,
                        leverage=1,
                        time=time)

                    self.broker.short(
                        price=long_leg_price,
                        symbol=self.long_leg,
                        vol=long_leg_qty,
                        leverage=1,
                        time=time)

                    self.is_open = True


    def close_position_new(self, bars: dict, ignore_diff=False):
        spread, _ = self.spread(bars)
        diff = (spread - self.mean) / self.dev
        # calculate position pnl
        long_leg_price = (bars[self.long_leg].close)
        short_leg_price = (bars[self.short_leg].close)
        time = bars[self.short_leg].time
        long_leg_pos: Position = self.broker.positions[self.long_leg]
        short_leg_pos: Position = self.broker.positions[self.short_leg]


        # Close the position when the unrealize loss is too much !!!
        # profit_rate = self.broker.get_current_pos_profit_rate(bars)
        # if profit_rate &lt; -0.1:
        #     print(&#39;position profit rate is too low, force quit&#39;)
        #     ignore_diff = True
        if (self.open_diff &gt; 0 and diff &lt; 0) or (self.open_diff &lt; 0 and diff &gt; 0) or ignore_diff:

        # if abs(diff) &lt; -2 or ignore_diff:
            self.holding_count = 0
            print(
                f&#39;close parameter beta: {self.beta}, intercept: {self.intercept}, spread mean:{self.mean}, spread dev {self.dev}, diff:{diff} , time:{time}&#39;)

            if short_leg_pos.direction == &#39;short&#39;:
                self.broker.cover_short(
                    price=short_leg_price,
                    symbol=self.short_leg,
                    vol=short_leg_pos.volume,
                    time=time)
            else:
                self.broker.cover_long(
                    price=short_leg_price,
                    symbol=self.short_leg,
                    vol=short_leg_pos.volume,
                    time=time)

            if long_leg_pos.direction == &#39;short&#39;:
                self.broker.cover_short(
                    price=long_leg_price,
                    symbol=self.long_leg,
                    vol=long_leg_pos.volume,
                    time=time)
            else:
                self.broker.cover_long(
                    price=long_leg_price,
                    symbol=self.long_leg,
                    vol=long_leg_pos.volume,
                    time=time)

            self.is_open = False
            self.beta, self.intercept = None, None

    def spread(self, bars: dict):
        long: BarData = bars[self.long_leg]
        short: BarData = bars[self.short_leg]

        long_price = (long.close)
        short_price = (short.close)

        spread = short_price - (self.beta * long_price &#43; self.intercept)
        diff = spread / (self.beta * long_price &#43; self.intercept)
        return spread, diff

    def get_diff(self, spread):
        mean = np.mean(self.spread_array)
        dev = np.std(self.spread_array)
        return mean, dev

    def coin_test(self):
        long_legs = []
        short_legs = []
        for i in range(self.array_len):
            bar = self.bar_array[i]
            long_legs.append(bar[self.long_leg])
            short_legs.append(bar[self.short_leg])

        if not self.beta:
            self.beta, self.intercept = self.get_beta_GPs()

        long_legs_modify = []

        for i in range(self.array_len):
            new_long_leg = long_legs[i] * self.beta &#43; self.intercept
            long_legs_modify.append(new_long_leg)

        _, p_value, _ = coint(long_legs_modify, short_legs)
        return p_value


def generate_combinations(symbols):
    return list(combinations(symbols, 2))


p_value = 0.99
stop_loss = 0.5


def main(selected_symbols):
    cash = 1000000
    transactionFeeRate = 0
    start = &#39;2023-01-01&#39;
    end = &#39;2024-10-31&#39;
    broker = Broker(cash, transactionFeeRate, selected_symbols)
    setting = {
        &#39;short_leg&#39;: selected_symbols[0],
        &#39;long_leg&#39;: selected_symbols[1],
        &#39;open_margin&#39;: 0.05,
        &#39;close_margin&#39;: 0.02,
        &#39;stop_loss&#39;: stop_loss,
        &#39;pValue&#39;: 0.05,
        &#39;grid_amount&#39;: cash * 0.2,
        &#39;array_len&#39;: 300,
        &#39;maximum_holding_period&#39;: 300,
    }

    strategy = Cointegration(broker, setting)
    log = Log(broker)
    backtestor = BacktestorPairTrading(broker, strategy, log, start, end)
    backtestor.load_data()
    backtestor.run_backtest()
    result = backtestor.performance()
    msg_df = pd.DataFrame(broker.msg)
    profit, loss, winrate = analyze_arbitrage_cycles(msg_df)
    # msg_df.to_csv(&#39;backTestResult/msg_df.csv&#39;)
    pnl_ratio = profit / loss
    result[&#39;pnl_ratio&#39;] = pnl_ratio
    result[&#39;win_rate&#39;] = winrate
    return result
    # msg_df = pd.DataFrame(broker.msg)
    # msg_df.to_csv(&#39;backTestResult/msg_df.csv&#39;)






if __name__ == &#39;__main__&#39;:
    from backTestResult.cointegration_analysis import analyze_arbitrage_cycles

    cash = 1000000
    transactionFeeRate = 0.00025
    start = &#39;2023-01-01&#39;
    end = &#39;2024-10-31&#39;
    long_leg = &#39;DOGE&#39;
    short_leg = &#39;XRP&#39;
    selected_symbols = [long_leg, short_leg]
    broker = Broker(cash, transactionFeeRate, selected_symbols)
    setting = {
        &#39;short_leg&#39;: short_leg,
        &#39;long_leg&#39;: long_leg,
        &#39;open_margin&#39;: 0.05,
        &#39;close_margin&#39;: 0.04,
        &#39;stop_loss&#39;: 0.4,
        &#39;pValue&#39;: 0.05,
        &#39;grid_amount&#39;: cash * 0.2,
        &#39;array_len&#39;: 200,
        &#39;maximum_holding_period&#39;: 24* 30,
    }

    strategy = Cointegration(broker, setting)
    log = Log(broker)
    backtestor = BacktestorPairTrading(broker, strategy, log, start, end)
    backtestor.load_data()
    backtestor.run_backtest()
    result = backtestor.performance()
    msg_df = pd.DataFrame(broker.msg)
    analyze_arbitrage_cycles(msg_df)
    msg_df.to_csv(&#39;backTestResult/msg_df.csv&#39;)
Bayesian regression
def bayesian_rolling_window(X_t, Y_t, window_size=30):
    T = len(X_t)
    beta_t_est = np.zeros(T)
    mu_t_est = np.zeros(T)
    beta_var_est = np.zeros(T)
    mu_var_est = np.zeros(T)
    residual_var_est = np.zeros(T)
    Y_pred = np.zeros(T)
    Y_std_est = np.zeros(T)

    # Prior parameters
    beta_mean_prior = 0
    beta_var_prior = 1
    mu_mean_prior = 0
    mu_var_prior = 1
    sigma_prior = 1

    for t in range(window_size, T):
        # Get rolling window data
        X_window = np.float64(X_t[t - window_size:t])
        Y_window = np.float64(Y_t[t - window_size:t])

        # Posterior parameters for beta
        XTX = np.sum(X_window ** 2)
        XTY = np.sum(X_window * (Y_window - np.mean(Y_window)))
        beta_var_post = 1 / (1 / beta_var_prior &#43; XTX / sigma_prior)
        beta_mean_post = beta_var_post * (beta_mean_prior / beta_var_prior &#43; XTY / sigma_prior)

        # Posterior parameters for mu
        mu_var_post = 1 / (1 / mu_var_prior &#43; window_size / sigma_prior)
        mu_mean_post = mu_var_post * (mu_mean_prior / mu_var_prior &#43; np.sum(Y_window - beta_mean_post * X_window) / sigma_prior)

        # Estimate residual variance
        residuals_window = Y_window - (beta_mean_post * X_window &#43; mu_mean_post)
        residual_var_est[t] = np.var(residuals_window)

        # Store estimates
        beta_t_est[t] = beta_mean_post
        mu_t_est[t] = mu_mean_post
        beta_var_est[t] = beta_var_post
        mu_var_est[t] = mu_var_post

        # Predict Y_t and its credible interval
        Y_pred[t] = beta_t_est[t] * X_t[t] &#43; mu_t_est[t]
        Y_var_est = (X_t[t] ** 2) * (beta_var_est[t]) &#43; (mu_var_est[t]) &#43; (1 / sigma_prior)
        Y_std_est[t] = np.sqrt(Y_var_est)


        # Prior parameters
        beta_mean_prior = beta_mean_post
        beta_var_prior = beta_var_post
        mu_mean_prior = mu_mean_post
        mu_var_prior = mu_var_post

    residuals = Y_t - Y_pred

    data = {
        &#39;y&#39;: {
            &#39;mean&#39;: Y_pred,
            &#39;upper&#39;: Y_pred &#43; 1.96 * Y_std_est,
            &#39;lower&#39;: Y_pred - 1.96 * Y_std_est
        },
        &#39;beta&#39;: {
            &#39;mean&#39;: beta_t_est,
            &#39;upper&#39;:  beta_t_est &#43; 1.96 * np.sqrt(beta_var_est),
            &#39;lower&#39;: beta_t_est - 1.96 * np.sqrt(beta_var_est)
        },
        &#39;mu&#39;: {
            &#39;mean&#39;: mu_t_est,
            &#39;upper&#39;: mu_t_est &#43; 1.96 * np.sqrt(mu_var_est),
            &#39;lower&#39;: mu_t_est - 1.96 * np.sqrt(mu_var_est)
        },
        &#39;epsilon&#39;: {
            &#39;mean&#39;: residuals,
            &#39;upper&#39;: residuals &#43; 1.96 * np.sqrt(residual_var_est),
            &#39;lower&#39;: residuals - 1.96 * np.sqrt(residual_var_est)
        },
    }

    return data
Bayesian GAM
def bayesian_gam_with_splines(X_t, Y_t, df=10):
    T = len(X_t)
    time = np.linspace(0, 1, T)

    # Design matrices for splines
    design_matrix = patsy.dmatrix(f&#34;bs(time, df={df}, degree=3)&#34;, {&#34;time&#34;: time}, return_type=&#39;dataframe&#39;)

    # Joint Bayesian Ridge Regression for beta_t and mu_t
    X_joint = np.hstack([np.multiply(design_matrix.values, X_t[:, None]), design_matrix.values])
    model_joint = BayesianRidge()
    model_joint.fit(X_joint, Y_t)

    # Predict values with uncertainties
    Y_pred, Y_std = model_joint.predict(X_joint, return_std=True)

    # Separate beta_t and mu_t
    beta_t_est = design_matrix.values @ model_joint.coef_[:design_matrix.shape[1]]
    mu_t_est = design_matrix.values @ model_joint.coef_[design_matrix.shape[1]:]

    # Compute standard deviations for beta and mu
    coef_cov = np.linalg.inv(model_joint.alpha_ * np.eye(X_joint.shape[1]) &#43; model_joint.lambda_ * X_joint.T @ X_joint)
    beta_std_est = np.sqrt(np.sum((design_matrix.values @ coef_cov[:design_matrix.shape[1], :design_matrix.shape[1]]) * design_matrix.values, axis=1))
    mu_std_est = np.sqrt(np.sum((design_matrix.values @ coef_cov[design_matrix.shape[1]:, design_matrix.shape[1]:]) * design_matrix.values, axis=1))

    # Posterior variance of noise
    residual_var_est = 1 / model_joint.alpha_  # Posterior noise variance

    residuals = Y_t - Y_pred

    data = {
        &#39;y&#39;: {
            &#39;mean&#39;: Y_pred,
            &#39;upper&#39;: Y_pred &#43; 1.96 * Y_std,
            &#39;lower&#39;: Y_pred - 1.96 * Y_std
        },
        &#39;beta&#39;: {
            &#39;mean&#39;: beta_t_est,
            &#39;upper&#39;: beta_t_est &#43; 1.96 * beta_std_est,
            &#39;lower&#39;: beta_t_est - 1.96 * beta_std_est
        },
        &#39;mu&#39;: {
            &#39;mean&#39;: mu_t_est,
            &#39;upper&#39;: mu_t_est &#43; 1.96 * mu_std_est,
            &#39;lower&#39;: mu_t_est - 1.96 * mu_std_est
        },
        &#39;epsilon&#39;: {
            &#39;mean&#39;: residuals,
            &#39;upper&#39;: residuals &#43; 1.96 * np.sqrt(residual_var_est),
            &#39;lower&#39;: residuals - 1.96 * np.sqrt(residual_var_est)
        },
    }

    return data
Gaussian Process
class TimeVaryingGP(ExactGP):
    def __init__(self, train_x, train_y, likelihood):
        super(TimeVaryingGP, self).__init__(train_x, train_y, likelihood)

        # Separate kernels for each component
        self.beta_kernel = ScaleKernel(RBFKernel())
        # self.beta_kernel.base_kernel.register_prior(
        #     &#39;lengthscale_prior&#39;,
        #     gpytorch.priors.GammaPrior(10.0, 20.0),
        #     &#39;lengthscale&#39;
        # )
        self.mu_kernel = ScaleKernel(RBFKernel())
        self.eps_kernel = ScaleKernel(RBFKernel())

        self.mean = ZeroMean()

    def forward(self, x):
        # Extract time and covariates
        t = x[:, 0]  # time index
        X = x[:, 1]  # covariate

        # Compute kernel matrices
        K_beta = self.beta_kernel(t)
        K_mu = self.mu_kernel(t)
        K_eps = self.eps_kernel(t)

        # Compute covariance matrix
        covar = X.unsqueeze(1) * K_beta * X.unsqueeze(0) &#43; K_mu &#43; K_eps

        mean = self.mean(x)
        return MultivariateNormal(mean, covar)


def train_model(X, y, n_iter=100):
    if not isinstance(X, torch.Tensor):
        X = torch.from_numpy(X).clone().detach().float()
        y = torch.from_numpy(y).clone().detach().float()
    else:
        X = X.clone().detach().float()
        y = y.clone().detach().float()

    # Initialize model
    likelihood = gpytorch.likelihoods.GaussianLikelihood()
    model = TimeVaryingGP(X, y, likelihood)

    # Use the adam optimizer
    optimizer = torch.optim.Adam([
        {&#39;params&#39;: model.parameters()},
    ], lr=0.1)

    # &#34;Loss&#34; for GPs - the marginal log likelihood
    mll = gpytorch.mlls.ExactMarginalLogLikelihood(likelihood, model)

    # Training loop
    model.train()
    likelihood.train()

    for i in range(n_iter):
        optimizer.zero_grad()
        output = model(X)
        loss = -mll(output, y)
        loss.backward()
        optimizer.step()

    return model, likelihood


def predict_latent(model, X_train, y_train, X_new):
    model.eval()
    jitter = 1e-6

    with torch.no_grad():
        t_train = X_train[:, 0]
        x_train = X_train[:, 1]
        t_new = X_new[:, 0]
        x_new = X_new[:, 1]

        K_beta = model.beta_kernel(t_new, t_train).evaluate()
        K_mu = model.mu_kernel(t_new, t_train).evaluate()
        K_eps = model.eps_kernel(t_new, t_train).evaluate()

        K_total = x_train * model.beta_kernel(t_train).evaluate() * x_train.unsqueeze(-1) &#43; \
                  model.mu_kernel(t_train).evaluate() &#43; \
                  model.eps_kernel(t_train).evaluate() &#43; \
                  model.likelihood.noise * torch.eye(len(t_train)) &#43; \
                  jitter * torch.eye(len(t_train))

        K_new_beta = model.beta_kernel(t_new).evaluate() &#43; jitter * torch.eye(len(t_new))
        K_new_mu = model.mu_kernel(t_new).evaluate() &#43; jitter * torch.eye(len(t_new))
        K_new_eps = model.eps_kernel(t_new).evaluate() &#43; jitter * torch.eye(len(t_new))

        # Compute posterior mean using Cholesky
        L = torch.linalg.cholesky(K_total)
        alpha = torch.linalg.solve_triangular(L, y_train.unsqueeze(1), upper=False)
        alpha = torch.linalg.solve_triangular(L.T, alpha, upper=True)

        K_stacked = torch.stack([
            x_new.unsqueeze(-1) * K_beta,
            K_mu,
            K_eps
        ])
        posterior_mean = K_stacked @ alpha

        # Compute posterior variance using Cholesky
        v_beta = torch.linalg.solve_triangular(L, (x_train * K_beta.T).T, upper=False)
        v_mu = torch.linalg.solve_triangular(L, K_mu.T, upper=False)
        v_eps = torch.linalg.solve_triangular(L, K_eps.T, upper=False)

        post_var_beta = K_new_beta - v_beta.T @ v_beta
        post_var_mu = K_new_mu - v_mu.T @ v_mu
        post_var_eps = K_new_eps - v_eps.T @ v_eps

        return {
            &#39;mean&#39;: {
                &#39;beta&#39;: posterior_mean[0].squeeze(),
                &#39;mu&#39;: posterior_mean[1].squeeze(),
                &#39;epsilon&#39;: posterior_mean[2].squeeze()
            },
            &#39;variance&#39;: {
                &#39;beta&#39;: post_var_beta.diag(),
                &#39;mu&#39;: post_var_mu.diag(),
                &#39;epsilon&#39;: post_var_eps.diag()
            }
        }


def predict(model, likelihood, X_new, X_train=None, y_train=None):
    model.eval()
    likelihood.eval()

    if X_train is None:
        X_train = model.train_inputs[0]
    if y_train is None:
        y_train = model.train_targets

    with torch.no_grad(), gpytorch.settings.fast_pred_var():
        observed_pred = likelihood(model(X_new))

    latent_values = predict_latent(model, X_train, y_train, X_new)
    return observed_pred.mean, observed_pred.variance, latent_values
BSTS
def bsts_fit(x,y):
    with pm.Model() as model:
        # Priors for variances

        # sigma = pm.HalfCauchy(&#39;sigma&#39;, beta=1)
        # Random walk for log volatility
        log_sigma = pm.GaussianRandomWalk(&#39;log_sigma&#39;,
                                          sigma=0.1,
                                          shape=len(y),
                                          init_dist=pm.Normal.dist(mu=0, sigma=1))
        sigma = pm.Deterministic(&#39;sigma&#39;, pm.math.exp(log_sigma))

        sigma_beta = pm.HalfCauchy(&#39;sigma_beta&#39;, beta=1)
        sigma_mu = pm.HalfCauchy(&#39;sigma_mu&#39;, beta=1)

        # Gaussian Random Walks for beta and mu
        beta = pm.GaussianRandomWalk(&#39;beta&#39;, sigma=sigma_beta, init_dist=pm.Normal.dist(0, 10), shape=len(y))
        mu = pm.GaussianRandomWalk(&#39;mu&#39;, sigma=sigma_mu, init_dist=pm.Normal.dist(0, 10), shape=len(y))

        # Observation model
        Y_obs = pm.Normal(&#39;Y_obs&#39;, mu=beta * x &#43; mu, sigma=sigma, observed=y)

        # ---- 3. MCMC Sampling ----
        trace = pm.sample(1000, tune=1000, chains=2, target_accept=0.9)
        ppc = pm.sample_posterior_predictive(trace, var_names=[&#34;Y_obs&#34;], random_seed=42)

        # Extract posterior mean and 95% credible intervals
        beta_posterior = trace.posterior[&#39;beta&#39;].mean(dim=(&#34;chain&#34;, &#34;draw&#34;))
        beta_lower = trace.posterior[&#39;beta&#39;].quantile(0.025, dim=(&#34;chain&#34;, &#34;draw&#34;))
        beta_upper = trace.posterior[&#39;beta&#39;].quantile(0.975, dim=(&#34;chain&#34;, &#34;draw&#34;))

        mu_posterior = trace.posterior[&#39;mu&#39;].mean(dim=(&#34;chain&#34;, &#34;draw&#34;))
        mu_lower = trace.posterior[&#39;mu&#39;].quantile(0.025, dim=(&#34;chain&#34;, &#34;draw&#34;))
        mu_upper = trace.posterior[&#39;mu&#39;].quantile(0.975, dim=(&#34;chain&#34;, &#34;draw&#34;))

        # Extract posterior predictive samples
        y_pred_samples = ppc.posterior_predictive[&#39;Y_obs&#39;]

        # Calculate mean and 95% prediction interval
        y_pred_mean = y_pred_samples.mean(dim=(&#39;chain&#39;, &#39;draw&#39;)).values
        y_pred_lower = np.percentile(y_pred_samples.values, 2.5, axis=(0, 1))  # 2.5% quantile
        y_pred_upper = np.percentile(y_pred_samples.values, 97.5, axis=(0, 1))  # 97.5% quantile

        epsilon_samples = y - y_pred_samples.values  # Shape: (chains, draws, time)

        # ---- 3. Calculate Mean and Intervals ----
        # Mean residuals
        epsilon_mean = epsilon_samples.mean(axis=(0, 1))  # Average over chains and draws

        # 95% prediction intervals
        epsilon_lower = np.percentile(epsilon_samples, 2.5, axis=(0, 1))
        epsilon_upper = np.percentile(epsilon_samples, 97.5, axis=(0, 1))

        data = {
            &#39;y&#39;: {
                &#39;mean&#39;: y_pred_mean,
                &#39;upper&#39;: y_pred_upper,
                &#39;lower&#39;: y_pred_lower
            },
            &#39;beta&#39;: {
                &#39;mean&#39;: beta_posterior,
                &#39;upper&#39;: beta_upper,
                &#39;lower&#39;: beta_lower
            },
            &#39;mu&#39;: {
                &#39;mean&#39;: mu_posterior,
                &#39;upper&#39;: mu_upper,
                &#39;lower&#39;: mu_lower
            },
            &#39;epsilon&#39;: {
                &#39;mean&#39;: epsilon_mean,
                &#39;upper&#39;: epsilon_upper,
                &#39;lower&#39;: epsilon_lower
            },
        }

        return data
Gaussian Process clustering
import pandas as pd
import numpy as np
from sklearn.cluster import KMeans
import gpytorch
import torch


class SparseGPModel(gpytorch.models.ApproximateGP):
    def __init__(self, inducing_points):
        variational_distribution = gpytorch.variational.CholeskyVariationalDistribution(inducing_points.size(0))
        variational_strategy = gpytorch.variational.VariationalStrategy(
            self, inducing_points, variational_distribution, learn_inducing_locations=True
        )
        super().__init__(variational_strategy)
        # Define kernel: RBF kernel with constant mean
        self.mean_module = gpytorch.means.ConstantMean()
        self.covar_module = gpytorch.kernels.ScaleKernel(gpytorch.kernels.RBFKernel())

    def forward(self, x):
        mean_x = self.mean_module(x)
        covar_x = self.covar_module(x)
        return gpytorch.distributions.MultivariateNormal(mean_x, covar_x)


def sparse_gpr_hyperparameter_clustering(data, n_clusters=3, num_inducing=10, verbose=True):

    symbols = data.iloc[:, 0].values
    time_points = torch.tensor(np.arange(data.shape[1] - 1), dtype=torch.float32)  # Time indices
    time_series = torch.tensor(data.iloc[:, 1:].values, dtype=torch.float32)  # Time series values

    # Initialize list to store hyperparameters
    hyperparameters = []

    if verbose:
        print(&#34;Starting Sparse Gaussian Process Regression for each stock...\n&#34;)

    for idx, ts in enumerate(time_series):
        ts = ts.unsqueeze(-1)  # Add a dimension for compatibility (n_samples, 1)

        inducing_points = time_points[::len(time_points) // num_inducing][:num_inducing].unsqueeze(-1)

        model = SparseGPModel(inducing_points)
        likelihood = gpytorch.likelihoods.GaussianLikelihood()

        model.train()
        likelihood.train()
        optimizer = torch.optim.Adam(model.parameters(), lr=0.1)
        mll = gpytorch.mlls.VariationalELBO(likelihood, model, num_data=len(time_points))

        # Training loop (simple with fixed iterations for now)
        training_iter = 100  # You can adjust this
        for i in range(training_iter):
            optimizer.zero_grad()
            output = model(time_points.unsqueeze(-1))
            loss = -mll(output, ts).sum()
            loss.backward()
            optimizer.step()

        # Extract learned hyperparameters
        kernel_params = model.covar_module.base_kernel.lengthscale.item()
        outputscale = model.covar_module.outputscale.item()
        noise = likelihood.noise.item()

        hyperparameters.append([outputscale, kernel_params, noise])

        if verbose:
            print(f&#34;Processed {idx &#43; 1}/{len(time_series)}: Symbol = {symbols[idx]}, &#34;
                  f&#34;Output Scale = {outputscale:.3f}, Length Scale = {kernel_params:.3f}, noise = {noise:.3f}&#34;)

    if verbose:
        print(&#34;\nFinished Sparse Gaussian Process Regression.&#34;)
        print(&#34;Starting clustering on hyperparameters...\n&#34;)

    # Perform clustering on hyperparameters
    hyperparameters = np.array(hyperparameters)
    kmeans = KMeans(n_clusters=n_clusters, random_state=0)
    labels = kmeans.fit_predict(hyperparameters)

    clusters = {}
    for cluster_id in range(n_clusters):
        clusters[f&#39;Cluster{cluster_id&#43;1}&#39;] = symbols[labels == cluster_id].tolist()

        if verbose:
            print(f&#34;Cluster {cluster_id &#43; 1}: {len(clusters[f&#39;Cluster{cluster_id&#43;1}&#39;])} symbols&#34;)

    if verbose:
        print(&#34;\nClustering complete. Summary:&#34;)
        for cluster, symbols in clusters.items():
            print(f&#34;{cluster}: {symbols}&#34;)

    return clusters


df = pd.read_csv(&#39;Quantitative_Research/model_new/bayesian_clustering/transposed_stock_data.csv&#39;)
clusters = sparse_gpr_hyperparameter_clustering(df, n_clusters=10, verbose=True)
print(clusters)
Appendix
broker object
class Broker:
    def __init__(self, cash: float, feeRate: float, symbols: list):
        self.positions = {}
        self.wallet = {}
        for symbol in symbols:
            self.wallet[symbol] = 0
        self.cash = cash
        self.feeRate = feeRate
        self.totalFee = 0
        self.symbols = symbols
        self.msg = []

    def buy(self, price, symbol, vol):
        # cash = self.cash
        # if cash - price * vol * (1 &#43; self.feeRate) &lt; 0:
        #     # print(&#34;not enough cash, but amount that minus fees&#34;)
        #     vol -= price * vol * self.feeRate / price
        self.cash -= price * vol * (1 &#43; self.feeRate)
        self.wallet[symbol] &#43;= vol
        self.totalFee &#43;= price * vol * self.feeRate
        msg = f&#34;Buy {symbol} at price: {price} for {vol} amount&#34;
        print(msg)
        msg_dict = {
            &#34;symbol&#34;: symbol,
            &#34;price&#34;: price,
            &#34;vol&#34;: vol,
            &#34;action&#34;: &#34;buy&#34;

        }
        self.msg.append(msg_dict)

    def sell(self, price, symbol, vol):
        self.cash &#43;= price * vol * (1 - self.feeRate)
        self.wallet[symbol] -= vol
        self.totalFee &#43;= price * vol * self.feeRate
        msg = f&#34;Sell {symbol} at price: {price} for {vol} amount&#34;
        print(msg)
        msg_dict = {
            &#34;symbol&#34;: symbol,
            &#34;price&#34;: price,
            &#34;vol&#34;: vol,
            &#34;action&#34;: &#34;sell&#34;
        }
        self.msg.append(msg_dict)

    def _update_position(self, symbol, price, vol, direction, time):
        if symbol in self.positions:
            position = self.positions[symbol]
            if position.direction == direction:
                # 加仓，计算新的加权平均价格
                new_volume = position.volume &#43; vol
                new_avg_price = (position.avg_price * position.volume &#43; price * vol) / new_volume
                position.avg_price = new_avg_price
                position.volume = new_volume
                position.time = time
            else:
                # 如果方向相反，考虑部分平仓或完全平仓的情况
                if abs(position.volume) &gt; vol:
                    # 部分平仓
                    position.volume -= vol
                elif abs(position.volume) == vol:
                    # 完全平仓，删除仓位
                    del self.positions[symbol]
                else:
                    # 平掉原仓位并开立新方向的仓位
                    new_vol = vol - abs(position.volume)
                    position.direction = direction
                    position.avg_price = price
                    position.volume = new_vol
                    position.time = time
        else:
            # 开立新仓位
            self.positions[symbol] = Position(time=time, avg_price=price, symbol=symbol, direction=direction,
                                              volume=vol)

    def long(self, price, symbol, vol, leverage, time):
        &#34;&#34;&#34;
        开立多头仓位，使用杠杆购买资产。
        :param price: 当前资产价格
        :param symbol: 资产符号
        :param vol: 购买的资产数量
        :param leverage: 杠杆倍数
        :param time: 当前时间
        &#34;&#34;&#34;
        margin_required = (price * vol) / leverage
        # if self.cash &lt; margin_required:
        #     print(&#34;Not enough cash to open long position with leverage.&#34;)
        #     return

        self.cash -= margin_required
        fee = price * vol * self.feeRate
        self.totalFee &#43;= fee
        self._update_position(symbol, price, vol * leverage, &#39;long&#39;, time)
        msg = f&#34;Long {symbol} at price: {price} for {vol} amount with leverage {leverage}&#34;
        print(msg)
        msg_dict = {
            &#34;symbol&#34;: symbol,
            &#34;price&#34;: price,
            &#34;vol&#34;: vol,
            &#34;action&#34;: &#34;long&#34;
        }
        self.msg.append(msg_dict)

    def short(self, price, symbol, vol, leverage, time):
        &#34;&#34;&#34;
        开立空头仓位，使用杠杆卖出资产。
        :param price: 当前资产价格
        :param symbol: 资产符号
        :param vol: 卖出的资产数量
        :param leverage: 杠杆倍数
        :param time: 当前时间
        &#34;&#34;&#34;
        margin_required = (price * vol) / leverage
        # if self.cash &lt; margin_required:
        #     print(&#34;Not enough cash to open short position with leverage.&#34;)
        #     return

        self.cash -= margin_required
        fee = price * vol * self.feeRate
        self.totalFee &#43;= fee
        self._update_position(symbol, price, vol * leverage, &#39;short&#39;, time)
        msg = f&#34;Short {symbol} at price: {price} for {vol} amount with leverage {leverage}&#34;
        print(msg)
        msg_dict = {
            &#34;symbol&#34;: symbol,
            &#34;price&#34;: price,
            &#34;vol&#34;: vol,
            &#34;action&#34;: &#34;short&#34;
        }
        self.msg.append(msg_dict)

    def cover_long(self, price, symbol, vol, time):
        &#34;&#34;&#34;
        平掉多头仓位。
        :param price: 当前资产价格
        :param symbol: 资产符号
        :param vol: 平仓的资产数量
        :param time: 当前时间
        &#34;&#34;&#34;
        if symbol not in self.positions or self.positions[symbol].direction != &#39;long&#39;:
            print(&#34;No long position to cover.&#34;)
            return
        fee = price * vol * self.feeRate
        self.totalFee &#43;= fee
        position_worth = self.positions[symbol].avg_price * vol
        pnl = (price - self.positions[symbol].avg_price) * vol
        self.cash &#43;= pnl &#43; position_worth - fee
        self._update_position(symbol, price, vol, &#39;cover_long&#39;, time)
        msg = f&#34;Cover long {symbol} at price: {price} for {vol} amount&#34;
        print(msg)
        msg_dict = {
            &#34;symbol&#34;: symbol,
            &#34;price&#34;: price,
            &#34;vol&#34;: vol,
            &#34;action&#34;: &#34;cover long&#34;
        }
        self.msg.append(msg_dict)

    def cover_short(self, price, symbol, vol, time):
        &#34;&#34;&#34;
        平掉空头仓位。
        :param price: 当前资产价格
        :param symbol: 资产符号
        :param vol: 平仓的资产数量
        :param time: 当前时间
        &#34;&#34;&#34;
        if symbol not in self.positions or self.positions[symbol].direction != &#39;short&#39;:
            print(&#34;No short position to cover.&#34;)
            return
        fee = price * vol * self.feeRate
        self.totalFee &#43;= fee
        position_worth = self.positions[symbol].avg_price * vol
        pnl = (self.positions[symbol].avg_price - price) * vol
        self.cash &#43;= pnl &#43; position_worth - fee
        self._update_position(symbol, price, vol, &#39;cover_short&#39;, time)
        msg = f&#34;Cover short {symbol} at price: {price} for {vol} amount&#34;
        print(msg)
        msg_dict = {
            &#34;symbol&#34;: symbol,
            &#34;price&#34;: price,
            &#34;vol&#34;: vol,
            &#34;action&#34;: &#34;cover short&#34;
        }
        self.msg.append(msg_dict)

    def calculate_total_account_equity(self, current_prices: dict):
        &#34;&#34;&#34;
        计算当前账户的总净值，包括现金和所有持仓的浮动盈亏。
        :param current_prices: dict，包含每个资产的当前价格，例如：{&#34;BTC&#34;: 40000, &#34;ETH&#34;: 3000}
        &#34;&#34;&#34;
        total_pnl = 0
        position_worth = 0
        for symbol, position in self.positions.items():
            if symbol in current_prices:
                current_price: BarData = current_prices[symbol]

                if position.direction == &#39;long&#39;:
                    pnl = (current_price.close - position.avg_price) * position.volume
                elif position.direction == &#39;short&#39;:
                    pnl = (position.avg_price - current_price.close) * position.volume
                position_worth &#43;= position.volume * position.avg_price
                total_pnl &#43;= pnl
        total_equity = self.cash &#43; total_pnl &#43; position_worth
        # print(f&#34;Total Account Equity: {total_equity:.2f} USD&#34;)
        return total_equity

    def get_current_pos_profit_rate(self, current_prices:dict):
        total_pnl = 0
        position_worth = 0
        for symbol, position in self.positions.items():
            if symbol in current_prices:
                current_price: BarData = current_prices[symbol]

                if position.direction == &#39;long&#39;:
                    pnl = (current_price.close - position.avg_price) * position.volume
                elif position.direction == &#39;short&#39;:
                    pnl = (position.avg_price - current_price.close) * position.volume
                position_worth &#43;= position.volume * position.avg_price
                total_pnl &#43;= pnl

        profit_rate = total_pnl / position_worth
        return profit_rate
">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://oldhuntor.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Bayesian Cointegration codes",
      "item": "https://oldhuntor.github.io/posts/codesnippets/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Bayesian Cointegration codes",
  "name": "Bayesian Cointegration codes",
  "description": "Cointegration strategy backtesting framework from backtest_multi_symbols import Broker, BarData, Backtestor, Position, DailyBar from collections import deque from statsmodels.tsa.stattools import coint import pandas as pd import numpy as np from itertools import combinations from sklearn.linear_model import LinearRegression from statsmodels.tsa.stattools import adfuller from model_new.bayesian_regression import bayesian_rolling_window from model_new.jointCov2 import fit_HGP from model_new.BayesGAM import bayesian_gam_with_splines from model_new.BSTS import bsts_fit class Log: def __init__(self, broker: Broker): self.resultPath = \u0026#39;backTestResult/backtestLog\u0026#39; self.logs = [] self.broker = broker def logging(self, bars: dict): data = {} for symbol in bars: data[f\u0026#34;close_{symbol}\u0026#34;] = bars[symbol].close pos = self.broker.positions.get(symbol, 0) if pos != 0: data[f\u0026#34;position_{symbol}\u0026#34;] = self.broker.positions[symbol].volume data[f\u0026#34;position_{symbol}_worth\u0026#34;] = self.broker.positions[symbol].volume * bars[symbol].close data[\u0026#39;time\u0026#39;] = bars[symbol].time equity = self.broker.calculate_total_account_equity(bars) data[\u0026#34;equity\u0026#34;] = equity data[\u0026#39;cash\u0026#39;] = self.broker.cash self.logs.append(data) def save_logs(self): df = pd.DataFrame(self.logs) # df.to_csv(self.resultPath + \u0026#39;.csv\u0026#39;, index=False) class BacktestorPairTrading(Backtestor): def __init__(self, broker: Broker, strategy, log, start, end): super().__init__(broker, strategy, log, start, end) self.log: Log = log def run_backtest(self): for i in range(self.data_length): bars = {} for symbol in self.symbols: data = self.data[f\u0026#39;{symbol}\u0026#39;].iloc[i] bar = BarData(data[\u0026#39;timestamp\u0026#39;], data[\u0026#39;open\u0026#39;], data[\u0026#39;high\u0026#39;], data[\u0026#39;low\u0026#39;], ((data[\u0026#39;close\u0026#39;])), data[\u0026#39;volume\u0026#39;]) bars[symbol] = bar self.strategy.processBar(bars) self.log.logging(bars) equity = self.broker.calculate_total_account_equity(bars) accountPNL = equity - self.strategy.initial_balance if accountPNL/self.strategy.initial_balance \u0026lt; -self.strategy.stop_loss: print(f\u0026#34;stop loss at {self.strategy.stop_loss} !!!\u0026#34;) break self.on_close(bars) self.log.save_logs() def on_close(self, bars): if self.strategy.is_open: print(\u0026#39;out of time force close\u0026#39;) self.strategy.close_position_new(bars, ignore_diff=True) class Cointegration: def __init__(self, broker: Broker, setting: dict): self.short_leg = setting[\u0026#39;short_leg\u0026#39;] self.long_leg = setting[\u0026#39;long_leg\u0026#39;] self.open_margin = setting[\u0026#39;open_margin\u0026#39;] self.close_margin = setting[\u0026#39;close_margin\u0026#39;] self.grid_amount = setting[\u0026#39;grid_amount\u0026#39;] self.array_len = setting[\u0026#39;array_len\u0026#39;] self.stop_loss = setting[\u0026#39;stop_loss\u0026#39;] self.pValue = setting[\u0026#39;pValue\u0026#39;] self.initial_balance = broker.cash self.maximum_holding_period = setting[\u0026#39;maximum_holding_period\u0026#39;] self.broker = broker self.beta = None self.intercept = None self.mean = None self.dev = None self.start = False self.open_diff = None self.bar_array = deque(maxlen=self.array_len) self.spread_array = deque(maxlen=self.array_len) self.is_open = False self.holding_count = 0 def get_model(self): pass def get_legs(self): long_legs = [] short_legs = [] for i in range(self.array_len): bar = self.bar_array[i] long_legs.append(np.log(bar[self.long_leg])) short_legs.append(np.log(bar[self.short_leg])) return long_legs, short_legs def get_beta(self): long_legs, short_legs = self.get_legs() # 使用 scikit-learn 回归模型计算 Beta（不带截距） long_legs = np.array(long_legs).reshape(-1, 1) short_legs = np.array(short_legs) model = LinearRegression(fit_intercept=True).fit(long_legs, short_legs) beta = model.coef_[0] intercept = model.intercept_ return beta, intercept def get_beta_BayesRegression(self): long_legs, short_legs = self.get_legs() result = bayesian_rolling_window(long_legs, short_legs, window_size=20) y_values = result[\u0026#39;y\u0026#39;] beta_values = result[\u0026#39;beta\u0026#39;] mu_values = result[\u0026#39;mu\u0026#39;] epsilon_values = result[\u0026#39;epsilon\u0026#39;] y_pred_mean = y_values[\u0026#39;mean\u0026#39;] y_pred_upper = y_values[\u0026#39;upper\u0026#39;] y_pred_lower = y_values[\u0026#39;lower\u0026#39;] beta_posterior = beta_values[\u0026#39;mean\u0026#39;] beta_upper = beta_values[\u0026#39;upper\u0026#39;] beta_lower = beta_values[\u0026#39;lower\u0026#39;] mu_posterior = mu_values[\u0026#39;mean\u0026#39;] mu_upper = mu_values[\u0026#39;upper\u0026#39;] mu_lower = mu_values[\u0026#39;lower\u0026#39;] epsilon_mean = epsilon_values[\u0026#39;mean\u0026#39;] epsilon_upper = epsilon_values[\u0026#39;upper\u0026#39;] epsilon_lower = epsilon_values[\u0026#39;lower\u0026#39;] return beta_posterior[-1], mu_posterior[-1] def get_beta_GPs(self): long_legs, short_legs = self.get_legs() long_legs = np.array(long_legs) short_legs = np.array(short_legs) result = fit_HGP(long_legs, short_legs) y_values = result[\u0026#39;y\u0026#39;] beta_values = result[\u0026#39;beta\u0026#39;] mu_values = result[\u0026#39;mu\u0026#39;] epsilon_values = result[\u0026#39;epsilon\u0026#39;] y_pred_mean = y_values[\u0026#39;mean\u0026#39;] y_pred_upper = y_values[\u0026#39;upper\u0026#39;] y_pred_lower = y_values[\u0026#39;lower\u0026#39;] beta_posterior = beta_values[\u0026#39;mean\u0026#39;] beta_upper = beta_values[\u0026#39;upper\u0026#39;] beta_lower = beta_values[\u0026#39;lower\u0026#39;] mu_posterior = mu_values[\u0026#39;mean\u0026#39;] mu_upper = mu_values[\u0026#39;upper\u0026#39;] mu_lower = mu_values[\u0026#39;lower\u0026#39;] epsilon_mean = epsilon_values[\u0026#39;mean\u0026#39;] epsilon_upper = epsilon_values[\u0026#39;upper\u0026#39;] epsilon_lower = epsilon_values[\u0026#39;lower\u0026#39;] return np.float64(beta_posterior[-1]), np.float64(mu_posterior[-1]) def get_beta_BSTS(self): pass def get_beta_GAM(self): long_legs = [] short_legs = [] for i in range(self.array_len): bar = self.bar_array[i] long_legs.append(bar[self.long_leg]) short_legs.append(bar[self.short_leg]) long_legs = np.array(long_legs) short_legs = np.array(short_legs) result = bayesian_gam_with_splines(long_legs,short_legs,df=10) y_values = result[\u0026#39;y\u0026#39;] beta_values = result[\u0026#39;beta\u0026#39;] mu_values = result[\u0026#39;mu\u0026#39;] epsilon_values = result[\u0026#39;epsilon\u0026#39;] y_pred_mean = y_values[\u0026#39;mean\u0026#39;] y_pred_upper = y_values[\u0026#39;upper\u0026#39;] y_pred_lower = y_values[\u0026#39;lower\u0026#39;] beta_posterior = beta_values[\u0026#39;mean\u0026#39;] beta_upper = beta_values[\u0026#39;upper\u0026#39;] beta_lower = beta_values[\u0026#39;lower\u0026#39;] mu_posterior = mu_values[\u0026#39;mean\u0026#39;] mu_upper = mu_values[\u0026#39;upper\u0026#39;] mu_lower = mu_values[\u0026#39;lower\u0026#39;] epsilon_mean = epsilon_values[\u0026#39;mean\u0026#39;] epsilon_upper = epsilon_values[\u0026#39;upper\u0026#39;] epsilon_lower = epsilon_values[\u0026#39;lower\u0026#39;] return beta_posterior[-1], mu_posterior[-1] def processBar(self, bars: dict): from math import log # append log data bar = { self.short_leg: (bars[self.short_leg].close), self.long_leg: (bars[self.long_leg].close), } self.bar_array.append(bar) if len(self.bar_array) \u0026lt; self.array_len: return p_value = self.coin_test() spread, _ = self.spread(bars) self.spread_array.append(spread) if len(self.spread_array) \u0026lt; self.array_len/5: return if self.is_open: self.holding_count += 1 spread, _ = self.spread(bars) diff = (spread - self.mean) / self.dev if self.holding_count \u0026gt;= self.maximum_holding_period: print(\u0026#39;holding too long force quit\u0026#39;) self.close_position_new(bars, ignore_diff=True) self.holding_count = 0 return if self.mean: diff = (spread - self.mean) / self.dev # print(f\u0026#34;current diff {diff}\u0026#34;) adf_center = adfuller(self.spread_array, regression=\u0026#39;c\u0026#39;)[1] adf_trend = adfuller(self.spread_array, regression=\u0026#39;ct\u0026#39;)[1] if adf_center \u0026lt; self.pValue: self.is_stationary = True else: self.is_stationary = False # if adf_trend \u0026lt; 0.05: # print(f\u0026#39;adf ct test result {adf_trend}, has a trend, not enter trading\u0026#39;) # return # if p_value \u0026lt;= self.pValue: if self.is_stationary: self.hedge(bars) elif self.is_open: self.close_position_new(bars) def hedge(self, bars: dict): if not self.is_open: # self.open_position(bars) self.open_position_new(bars) else: self.close_position_new(bars) def open_position_new(self, bars: dict): spread, _ = self.spread(bars) self.mean, self.dev = self.get_diff(spread) diff = (spread - self.mean) / self.dev long_leg_price = (bars[self.long_leg].close) short_leg_price = (bars[self.short_leg].close) time = bars[self.short_leg].time short_leg_qty = self.grid_amount/(long_leg_price*abs(self.beta) + short_leg_price) long_leg_qty = short_leg_qty*abs(self.beta) if abs(diff) \u0026gt; 2: print( f\u0026#39;open parameter beta: {self.beta}, intercept: {self.intercept}, spread mean:{self.mean}, spread dev {self.dev}, diff:{diff} , time:{time}\u0026#39;) self.open_diff = diff if self.beta \u0026lt; 0: if diff \u0026gt; 0: self.broker.short( price=long_leg_price, symbol=self.long_leg, vol=long_leg_qty, leverage=1, time=time) self.broker.short( price=short_leg_price, symbol=self.short_leg, vol=short_leg_qty, leverage=1, time=time) self.is_open = True else: self.broker.long( price=long_leg_price, symbol=self.long_leg, vol=long_leg_qty, leverage=1, time=time) self.broker.long( price=short_leg_price, symbol=self.short_leg, vol=short_leg_qty, leverage=1, time=time) self.is_open = True else: if diff \u0026gt; 0: self.broker.long( price=long_leg_price, symbol=self.long_leg, vol=long_leg_qty, leverage=1, time=time) self.broker.short( price=short_leg_price, symbol=self.short_leg, vol=short_leg_qty, leverage=1, time=time) self.is_open = True else: self.broker.long( price=short_leg_price, symbol=self.short_leg, vol=short_leg_qty, leverage=1, time=time) self.broker.short( price=long_leg_price, symbol=self.long_leg, vol=long_leg_qty, leverage=1, time=time) self.is_open = True def close_position_new(self, bars: dict, ignore_diff=False): spread, _ = self.spread(bars) diff = (spread - self.mean) / self.dev # calculate position pnl long_leg_price = (bars[self.long_leg].close) short_leg_price = (bars[self.short_leg].close) time = bars[self.short_leg].time long_leg_pos: Position = self.broker.positions[self.long_leg] short_leg_pos: Position = self.broker.positions[self.short_leg] # Close the position when the unrealize loss is too much !!! # profit_rate = self.broker.get_current_pos_profit_rate(bars) # if profit_rate \u0026lt; -0.1: # print(\u0026#39;position profit rate is too low, force quit\u0026#39;) # ignore_diff = True if (self.open_diff \u0026gt; 0 and diff \u0026lt; 0) or (self.open_diff \u0026lt; 0 and diff \u0026gt; 0) or ignore_diff: # if abs(diff) \u0026lt; -2 or ignore_diff: self.holding_count = 0 print( f\u0026#39;close parameter beta: {self.beta}, intercept: {self.intercept}, spread mean:{self.mean}, spread dev {self.dev}, diff:{diff} , time:{time}\u0026#39;) if short_leg_pos.direction == \u0026#39;short\u0026#39;: self.broker.cover_short( price=short_leg_price, symbol=self.short_leg, vol=short_leg_pos.volume, time=time) else: self.broker.cover_long( price=short_leg_price, symbol=self.short_leg, vol=short_leg_pos.volume, time=time) if long_leg_pos.direction == \u0026#39;short\u0026#39;: self.broker.cover_short( price=long_leg_price, symbol=self.long_leg, vol=long_leg_pos.volume, time=time) else: self.broker.cover_long( price=long_leg_price, symbol=self.long_leg, vol=long_leg_pos.volume, time=time) self.is_open = False self.beta, self.intercept = None, None def spread(self, bars: dict): long: BarData = bars[self.long_leg] short: BarData = bars[self.short_leg] long_price = (long.close) short_price = (short.close) spread = short_price - (self.beta * long_price + self.intercept) diff = spread / (self.beta * long_price + self.intercept) return spread, diff def get_diff(self, spread): mean = np.mean(self.spread_array) dev = np.std(self.spread_array) return mean, dev def coin_test(self): long_legs = [] short_legs = [] for i in range(self.array_len): bar = self.bar_array[i] long_legs.append(bar[self.long_leg]) short_legs.append(bar[self.short_leg]) if not self.beta: self.beta, self.intercept = self.get_beta_GPs() long_legs_modify = [] for i in range(self.array_len): new_long_leg = long_legs[i] * self.beta + self.intercept long_legs_modify.append(new_long_leg) _, p_value, _ = coint(long_legs_modify, short_legs) return p_value def generate_combinations(symbols): return list(combinations(symbols, 2)) p_value = 0.99 stop_loss = 0.5 def main(selected_symbols): cash = 1000000 transactionFeeRate = 0 start = \u0026#39;2023-01-01\u0026#39; end = \u0026#39;2024-10-31\u0026#39; broker = Broker(cash, transactionFeeRate, selected_symbols) setting = { \u0026#39;short_leg\u0026#39;: selected_symbols[0], \u0026#39;long_leg\u0026#39;: selected_symbols[1], \u0026#39;open_margin\u0026#39;: 0.05, \u0026#39;close_margin\u0026#39;: 0.02, \u0026#39;stop_loss\u0026#39;: stop_loss, \u0026#39;pValue\u0026#39;: 0.05, \u0026#39;grid_amount\u0026#39;: cash * 0.2, \u0026#39;array_len\u0026#39;: 300, \u0026#39;maximum_holding_period\u0026#39;: 300, } strategy = Cointegration(broker, setting) log = Log(broker) backtestor = BacktestorPairTrading(broker, strategy, log, start, end) backtestor.load_data() backtestor.run_backtest() result = backtestor.performance() msg_df = pd.DataFrame(broker.msg) profit, loss, winrate = analyze_arbitrage_cycles(msg_df) # msg_df.to_csv(\u0026#39;backTestResult/msg_df.csv\u0026#39;) pnl_ratio = profit / loss result[\u0026#39;pnl_ratio\u0026#39;] = pnl_ratio result[\u0026#39;win_rate\u0026#39;] = winrate return result # msg_df = pd.DataFrame(broker.msg) # msg_df.to_csv(\u0026#39;backTestResult/msg_df.csv\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: from backTestResult.cointegration_analysis import analyze_arbitrage_cycles cash = 1000000 transactionFeeRate = 0.00025 start = \u0026#39;2023-01-01\u0026#39; end = \u0026#39;2024-10-31\u0026#39; long_leg = \u0026#39;DOGE\u0026#39; short_leg = \u0026#39;XRP\u0026#39; selected_symbols = [long_leg, short_leg] broker = Broker(cash, transactionFeeRate, selected_symbols) setting = { \u0026#39;short_leg\u0026#39;: short_leg, \u0026#39;long_leg\u0026#39;: long_leg, \u0026#39;open_margin\u0026#39;: 0.05, \u0026#39;close_margin\u0026#39;: 0.04, \u0026#39;stop_loss\u0026#39;: 0.4, \u0026#39;pValue\u0026#39;: 0.05, \u0026#39;grid_amount\u0026#39;: cash * 0.2, \u0026#39;array_len\u0026#39;: 200, \u0026#39;maximum_holding_period\u0026#39;: 24* 30, } strategy = Cointegration(broker, setting) log = Log(broker) backtestor = BacktestorPairTrading(broker, strategy, log, start, end) backtestor.load_data() backtestor.run_backtest() result = backtestor.performance() msg_df = pd.DataFrame(broker.msg) analyze_arbitrage_cycles(msg_df) msg_df.to_csv(\u0026#39;backTestResult/msg_df.csv\u0026#39;) Bayesian regression def bayesian_rolling_window(X_t, Y_t, window_size=30): T = len(X_t) beta_t_est = np.zeros(T) mu_t_est = np.zeros(T) beta_var_est = np.zeros(T) mu_var_est = np.zeros(T) residual_var_est = np.zeros(T) Y_pred = np.zeros(T) Y_std_est = np.zeros(T) # Prior parameters beta_mean_prior = 0 beta_var_prior = 1 mu_mean_prior = 0 mu_var_prior = 1 sigma_prior = 1 for t in range(window_size, T): # Get rolling window data X_window = np.float64(X_t[t - window_size:t]) Y_window = np.float64(Y_t[t - window_size:t]) # Posterior parameters for beta XTX = np.sum(X_window ** 2) XTY = np.sum(X_window * (Y_window - np.mean(Y_window))) beta_var_post = 1 / (1 / beta_var_prior + XTX / sigma_prior) beta_mean_post = beta_var_post * (beta_mean_prior / beta_var_prior + XTY / sigma_prior) # Posterior parameters for mu mu_var_post = 1 / (1 / mu_var_prior + window_size / sigma_prior) mu_mean_post = mu_var_post * (mu_mean_prior / mu_var_prior + np.sum(Y_window - beta_mean_post * X_window) / sigma_prior) # Estimate residual variance residuals_window = Y_window - (beta_mean_post * X_window + mu_mean_post) residual_var_est[t] = np.var(residuals_window) # Store estimates beta_t_est[t] = beta_mean_post mu_t_est[t] = mu_mean_post beta_var_est[t] = beta_var_post mu_var_est[t] = mu_var_post # Predict Y_t and its credible interval Y_pred[t] = beta_t_est[t] * X_t[t] + mu_t_est[t] Y_var_est = (X_t[t] ** 2) * (beta_var_est[t]) + (mu_var_est[t]) + (1 / sigma_prior) Y_std_est[t] = np.sqrt(Y_var_est) # Prior parameters beta_mean_prior = beta_mean_post beta_var_prior = beta_var_post mu_mean_prior = mu_mean_post mu_var_prior = mu_var_post residuals = Y_t - Y_pred data = { \u0026#39;y\u0026#39;: { \u0026#39;mean\u0026#39;: Y_pred, \u0026#39;upper\u0026#39;: Y_pred + 1.96 * Y_std_est, \u0026#39;lower\u0026#39;: Y_pred - 1.96 * Y_std_est }, \u0026#39;beta\u0026#39;: { \u0026#39;mean\u0026#39;: beta_t_est, \u0026#39;upper\u0026#39;: beta_t_est + 1.96 * np.sqrt(beta_var_est), \u0026#39;lower\u0026#39;: beta_t_est - 1.96 * np.sqrt(beta_var_est) }, \u0026#39;mu\u0026#39;: { \u0026#39;mean\u0026#39;: mu_t_est, \u0026#39;upper\u0026#39;: mu_t_est + 1.96 * np.sqrt(mu_var_est), \u0026#39;lower\u0026#39;: mu_t_est - 1.96 * np.sqrt(mu_var_est) }, \u0026#39;epsilon\u0026#39;: { \u0026#39;mean\u0026#39;: residuals, \u0026#39;upper\u0026#39;: residuals + 1.96 * np.sqrt(residual_var_est), \u0026#39;lower\u0026#39;: residuals - 1.96 * np.sqrt(residual_var_est) }, } return data Bayesian GAM def bayesian_gam_with_splines(X_t, Y_t, df=10): T = len(X_t) time = np.linspace(0, 1, T) # Design matrices for splines design_matrix = patsy.dmatrix(f\u0026#34;bs(time, df={df}, degree=3)\u0026#34;, {\u0026#34;time\u0026#34;: time}, return_type=\u0026#39;dataframe\u0026#39;) # Joint Bayesian Ridge Regression for beta_t and mu_t X_joint = np.hstack([np.multiply(design_matrix.values, X_t[:, None]), design_matrix.values]) model_joint = BayesianRidge() model_joint.fit(X_joint, Y_t) # Predict values with uncertainties Y_pred, Y_std = model_joint.predict(X_joint, return_std=True) # Separate beta_t and mu_t beta_t_est = design_matrix.values @ model_joint.coef_[:design_matrix.shape[1]] mu_t_est = design_matrix.values @ model_joint.coef_[design_matrix.shape[1]:] # Compute standard deviations for beta and mu coef_cov = np.linalg.inv(model_joint.alpha_ * np.eye(X_joint.shape[1]) + model_joint.lambda_ * X_joint.T @ X_joint) beta_std_est = np.sqrt(np.sum((design_matrix.values @ coef_cov[:design_matrix.shape[1], :design_matrix.shape[1]]) * design_matrix.values, axis=1)) mu_std_est = np.sqrt(np.sum((design_matrix.values @ coef_cov[design_matrix.shape[1]:, design_matrix.shape[1]:]) * design_matrix.values, axis=1)) # Posterior variance of noise residual_var_est = 1 / model_joint.alpha_ # Posterior noise variance residuals = Y_t - Y_pred data = { \u0026#39;y\u0026#39;: { \u0026#39;mean\u0026#39;: Y_pred, \u0026#39;upper\u0026#39;: Y_pred + 1.96 * Y_std, \u0026#39;lower\u0026#39;: Y_pred - 1.96 * Y_std }, \u0026#39;beta\u0026#39;: { \u0026#39;mean\u0026#39;: beta_t_est, \u0026#39;upper\u0026#39;: beta_t_est + 1.96 * beta_std_est, \u0026#39;lower\u0026#39;: beta_t_est - 1.96 * beta_std_est }, \u0026#39;mu\u0026#39;: { \u0026#39;mean\u0026#39;: mu_t_est, \u0026#39;upper\u0026#39;: mu_t_est + 1.96 * mu_std_est, \u0026#39;lower\u0026#39;: mu_t_est - 1.96 * mu_std_est }, \u0026#39;epsilon\u0026#39;: { \u0026#39;mean\u0026#39;: residuals, \u0026#39;upper\u0026#39;: residuals + 1.96 * np.sqrt(residual_var_est), \u0026#39;lower\u0026#39;: residuals - 1.96 * np.sqrt(residual_var_est) }, } return data Gaussian Process class TimeVaryingGP(ExactGP): def __init__(self, train_x, train_y, likelihood): super(TimeVaryingGP, self).__init__(train_x, train_y, likelihood) # Separate kernels for each component self.beta_kernel = ScaleKernel(RBFKernel()) # self.beta_kernel.base_kernel.register_prior( # \u0026#39;lengthscale_prior\u0026#39;, # gpytorch.priors.GammaPrior(10.0, 20.0), # \u0026#39;lengthscale\u0026#39; # ) self.mu_kernel = ScaleKernel(RBFKernel()) self.eps_kernel = ScaleKernel(RBFKernel()) self.mean = ZeroMean() def forward(self, x): # Extract time and covariates t = x[:, 0] # time index X = x[:, 1] # covariate # Compute kernel matrices K_beta = self.beta_kernel(t) K_mu = self.mu_kernel(t) K_eps = self.eps_kernel(t) # Compute covariance matrix covar = X.unsqueeze(1) * K_beta * X.unsqueeze(0) + K_mu + K_eps mean = self.mean(x) return MultivariateNormal(mean, covar) def train_model(X, y, n_iter=100): if not isinstance(X, torch.Tensor): X = torch.from_numpy(X).clone().detach().float() y = torch.from_numpy(y).clone().detach().float() else: X = X.clone().detach().float() y = y.clone().detach().float() # Initialize model likelihood = gpytorch.likelihoods.GaussianLikelihood() model = TimeVaryingGP(X, y, likelihood) # Use the adam optimizer optimizer = torch.optim.Adam([ {\u0026#39;params\u0026#39;: model.parameters()}, ], lr=0.1) # \u0026#34;Loss\u0026#34; for GPs - the marginal log likelihood mll = gpytorch.mlls.ExactMarginalLogLikelihood(likelihood, model) # Training loop model.train() likelihood.train() for i in range(n_iter): optimizer.zero_grad() output = model(X) loss = -mll(output, y) loss.backward() optimizer.step() return model, likelihood def predict_latent(model, X_train, y_train, X_new): model.eval() jitter = 1e-6 with torch.no_grad(): t_train = X_train[:, 0] x_train = X_train[:, 1] t_new = X_new[:, 0] x_new = X_new[:, 1] K_beta = model.beta_kernel(t_new, t_train).evaluate() K_mu = model.mu_kernel(t_new, t_train).evaluate() K_eps = model.eps_kernel(t_new, t_train).evaluate() K_total = x_train * model.beta_kernel(t_train).evaluate() * x_train.unsqueeze(-1) + \\ model.mu_kernel(t_train).evaluate() + \\ model.eps_kernel(t_train).evaluate() + \\ model.likelihood.noise * torch.eye(len(t_train)) + \\ jitter * torch.eye(len(t_train)) K_new_beta = model.beta_kernel(t_new).evaluate() + jitter * torch.eye(len(t_new)) K_new_mu = model.mu_kernel(t_new).evaluate() + jitter * torch.eye(len(t_new)) K_new_eps = model.eps_kernel(t_new).evaluate() + jitter * torch.eye(len(t_new)) # Compute posterior mean using Cholesky L = torch.linalg.cholesky(K_total) alpha = torch.linalg.solve_triangular(L, y_train.unsqueeze(1), upper=False) alpha = torch.linalg.solve_triangular(L.T, alpha, upper=True) K_stacked = torch.stack([ x_new.unsqueeze(-1) * K_beta, K_mu, K_eps ]) posterior_mean = K_stacked @ alpha # Compute posterior variance using Cholesky v_beta = torch.linalg.solve_triangular(L, (x_train * K_beta.T).T, upper=False) v_mu = torch.linalg.solve_triangular(L, K_mu.T, upper=False) v_eps = torch.linalg.solve_triangular(L, K_eps.T, upper=False) post_var_beta = K_new_beta - v_beta.T @ v_beta post_var_mu = K_new_mu - v_mu.T @ v_mu post_var_eps = K_new_eps - v_eps.T @ v_eps return { \u0026#39;mean\u0026#39;: { \u0026#39;beta\u0026#39;: posterior_mean[0].squeeze(), \u0026#39;mu\u0026#39;: posterior_mean[1].squeeze(), \u0026#39;epsilon\u0026#39;: posterior_mean[2].squeeze() }, \u0026#39;variance\u0026#39;: { \u0026#39;beta\u0026#39;: post_var_beta.diag(), \u0026#39;mu\u0026#39;: post_var_mu.diag(), \u0026#39;epsilon\u0026#39;: post_var_eps.diag() } } def predict(model, likelihood, X_new, X_train=None, y_train=None): model.eval() likelihood.eval() if X_train is None: X_train = model.train_inputs[0] if y_train is None: y_train = model.train_targets with torch.no_grad(), gpytorch.settings.fast_pred_var(): observed_pred = likelihood(model(X_new)) latent_values = predict_latent(model, X_train, y_train, X_new) return observed_pred.mean, observed_pred.variance, latent_values BSTS def bsts_fit(x,y): with pm.Model() as model: # Priors for variances # sigma = pm.HalfCauchy(\u0026#39;sigma\u0026#39;, beta=1) # Random walk for log volatility log_sigma = pm.GaussianRandomWalk(\u0026#39;log_sigma\u0026#39;, sigma=0.1, shape=len(y), init_dist=pm.Normal.dist(mu=0, sigma=1)) sigma = pm.Deterministic(\u0026#39;sigma\u0026#39;, pm.math.exp(log_sigma)) sigma_beta = pm.HalfCauchy(\u0026#39;sigma_beta\u0026#39;, beta=1) sigma_mu = pm.HalfCauchy(\u0026#39;sigma_mu\u0026#39;, beta=1) # Gaussian Random Walks for beta and mu beta = pm.GaussianRandomWalk(\u0026#39;beta\u0026#39;, sigma=sigma_beta, init_dist=pm.Normal.dist(0, 10), shape=len(y)) mu = pm.GaussianRandomWalk(\u0026#39;mu\u0026#39;, sigma=sigma_mu, init_dist=pm.Normal.dist(0, 10), shape=len(y)) # Observation model Y_obs = pm.Normal(\u0026#39;Y_obs\u0026#39;, mu=beta * x + mu, sigma=sigma, observed=y) # ---- 3. MCMC Sampling ---- trace = pm.sample(1000, tune=1000, chains=2, target_accept=0.9) ppc = pm.sample_posterior_predictive(trace, var_names=[\u0026#34;Y_obs\u0026#34;], random_seed=42) # Extract posterior mean and 95% credible intervals beta_posterior = trace.posterior[\u0026#39;beta\u0026#39;].mean(dim=(\u0026#34;chain\u0026#34;, \u0026#34;draw\u0026#34;)) beta_lower = trace.posterior[\u0026#39;beta\u0026#39;].quantile(0.025, dim=(\u0026#34;chain\u0026#34;, \u0026#34;draw\u0026#34;)) beta_upper = trace.posterior[\u0026#39;beta\u0026#39;].quantile(0.975, dim=(\u0026#34;chain\u0026#34;, \u0026#34;draw\u0026#34;)) mu_posterior = trace.posterior[\u0026#39;mu\u0026#39;].mean(dim=(\u0026#34;chain\u0026#34;, \u0026#34;draw\u0026#34;)) mu_lower = trace.posterior[\u0026#39;mu\u0026#39;].quantile(0.025, dim=(\u0026#34;chain\u0026#34;, \u0026#34;draw\u0026#34;)) mu_upper = trace.posterior[\u0026#39;mu\u0026#39;].quantile(0.975, dim=(\u0026#34;chain\u0026#34;, \u0026#34;draw\u0026#34;)) # Extract posterior predictive samples y_pred_samples = ppc.posterior_predictive[\u0026#39;Y_obs\u0026#39;] # Calculate mean and 95% prediction interval y_pred_mean = y_pred_samples.mean(dim=(\u0026#39;chain\u0026#39;, \u0026#39;draw\u0026#39;)).values y_pred_lower = np.percentile(y_pred_samples.values, 2.5, axis=(0, 1)) # 2.5% quantile y_pred_upper = np.percentile(y_pred_samples.values, 97.5, axis=(0, 1)) # 97.5% quantile epsilon_samples = y - y_pred_samples.values # Shape: (chains, draws, time) # ---- 3. Calculate Mean and Intervals ---- # Mean residuals epsilon_mean = epsilon_samples.mean(axis=(0, 1)) # Average over chains and draws # 95% prediction intervals epsilon_lower = np.percentile(epsilon_samples, 2.5, axis=(0, 1)) epsilon_upper = np.percentile(epsilon_samples, 97.5, axis=(0, 1)) data = { \u0026#39;y\u0026#39;: { \u0026#39;mean\u0026#39;: y_pred_mean, \u0026#39;upper\u0026#39;: y_pred_upper, \u0026#39;lower\u0026#39;: y_pred_lower }, \u0026#39;beta\u0026#39;: { \u0026#39;mean\u0026#39;: beta_posterior, \u0026#39;upper\u0026#39;: beta_upper, \u0026#39;lower\u0026#39;: beta_lower }, \u0026#39;mu\u0026#39;: { \u0026#39;mean\u0026#39;: mu_posterior, \u0026#39;upper\u0026#39;: mu_upper, \u0026#39;lower\u0026#39;: mu_lower }, \u0026#39;epsilon\u0026#39;: { \u0026#39;mean\u0026#39;: epsilon_mean, \u0026#39;upper\u0026#39;: epsilon_upper, \u0026#39;lower\u0026#39;: epsilon_lower }, } return data Gaussian Process clustering import pandas as pd import numpy as np from sklearn.cluster import KMeans import gpytorch import torch class SparseGPModel(gpytorch.models.ApproximateGP): def __init__(self, inducing_points): variational_distribution = gpytorch.variational.CholeskyVariationalDistribution(inducing_points.size(0)) variational_strategy = gpytorch.variational.VariationalStrategy( self, inducing_points, variational_distribution, learn_inducing_locations=True ) super().__init__(variational_strategy) # Define kernel: RBF kernel with constant mean self.mean_module = gpytorch.means.ConstantMean() self.covar_module = gpytorch.kernels.ScaleKernel(gpytorch.kernels.RBFKernel()) def forward(self, x): mean_x = self.mean_module(x) covar_x = self.covar_module(x) return gpytorch.distributions.MultivariateNormal(mean_x, covar_x) def sparse_gpr_hyperparameter_clustering(data, n_clusters=3, num_inducing=10, verbose=True): symbols = data.iloc[:, 0].values time_points = torch.tensor(np.arange(data.shape[1] - 1), dtype=torch.float32) # Time indices time_series = torch.tensor(data.iloc[:, 1:].values, dtype=torch.float32) # Time series values # Initialize list to store hyperparameters hyperparameters = [] if verbose: print(\u0026#34;Starting Sparse Gaussian Process Regression for each stock...\\n\u0026#34;) for idx, ts in enumerate(time_series): ts = ts.unsqueeze(-1) # Add a dimension for compatibility (n_samples, 1) inducing_points = time_points[::len(time_points) // num_inducing][:num_inducing].unsqueeze(-1) model = SparseGPModel(inducing_points) likelihood = gpytorch.likelihoods.GaussianLikelihood() model.train() likelihood.train() optimizer = torch.optim.Adam(model.parameters(), lr=0.1) mll = gpytorch.mlls.VariationalELBO(likelihood, model, num_data=len(time_points)) # Training loop (simple with fixed iterations for now) training_iter = 100 # You can adjust this for i in range(training_iter): optimizer.zero_grad() output = model(time_points.unsqueeze(-1)) loss = -mll(output, ts).sum() loss.backward() optimizer.step() # Extract learned hyperparameters kernel_params = model.covar_module.base_kernel.lengthscale.item() outputscale = model.covar_module.outputscale.item() noise = likelihood.noise.item() hyperparameters.append([outputscale, kernel_params, noise]) if verbose: print(f\u0026#34;Processed {idx + 1}/{len(time_series)}: Symbol = {symbols[idx]}, \u0026#34; f\u0026#34;Output Scale = {outputscale:.3f}, Length Scale = {kernel_params:.3f}, noise = {noise:.3f}\u0026#34;) if verbose: print(\u0026#34;\\nFinished Sparse Gaussian Process Regression.\u0026#34;) print(\u0026#34;Starting clustering on hyperparameters...\\n\u0026#34;) # Perform clustering on hyperparameters hyperparameters = np.array(hyperparameters) kmeans = KMeans(n_clusters=n_clusters, random_state=0) labels = kmeans.fit_predict(hyperparameters) clusters = {} for cluster_id in range(n_clusters): clusters[f\u0026#39;Cluster{cluster_id+1}\u0026#39;] = symbols[labels == cluster_id].tolist() if verbose: print(f\u0026#34;Cluster {cluster_id + 1}: {len(clusters[f\u0026#39;Cluster{cluster_id+1}\u0026#39;])} symbols\u0026#34;) if verbose: print(\u0026#34;\\nClustering complete. Summary:\u0026#34;) for cluster, symbols in clusters.items(): print(f\u0026#34;{cluster}: {symbols}\u0026#34;) return clusters df = pd.read_csv(\u0026#39;Quantitative_Research/model_new/bayesian_clustering/transposed_stock_data.csv\u0026#39;) clusters = sparse_gpr_hyperparameter_clustering(df, n_clusters=10, verbose=True) print(clusters) Appendix broker object class Broker: def __init__(self, cash: float, feeRate: float, symbols: list): self.positions = {} self.wallet = {} for symbol in symbols: self.wallet[symbol] = 0 self.cash = cash self.feeRate = feeRate self.totalFee = 0 self.symbols = symbols self.msg = [] def buy(self, price, symbol, vol): # cash = self.cash # if cash - price * vol * (1 + self.feeRate) \u0026lt; 0: # # print(\u0026#34;not enough cash, but amount that minus fees\u0026#34;) # vol -= price * vol * self.feeRate / price self.cash -= price * vol * (1 + self.feeRate) self.wallet[symbol] += vol self.totalFee += price * vol * self.feeRate msg = f\u0026#34;Buy {symbol} at price: {price} for {vol} amount\u0026#34; print(msg) msg_dict = { \u0026#34;symbol\u0026#34;: symbol, \u0026#34;price\u0026#34;: price, \u0026#34;vol\u0026#34;: vol, \u0026#34;action\u0026#34;: \u0026#34;buy\u0026#34; } self.msg.append(msg_dict) def sell(self, price, symbol, vol): self.cash += price * vol * (1 - self.feeRate) self.wallet[symbol] -= vol self.totalFee += price * vol * self.feeRate msg = f\u0026#34;Sell {symbol} at price: {price} for {vol} amount\u0026#34; print(msg) msg_dict = { \u0026#34;symbol\u0026#34;: symbol, \u0026#34;price\u0026#34;: price, \u0026#34;vol\u0026#34;: vol, \u0026#34;action\u0026#34;: \u0026#34;sell\u0026#34; } self.msg.append(msg_dict) def _update_position(self, symbol, price, vol, direction, time): if symbol in self.positions: position = self.positions[symbol] if position.direction == direction: # 加仓，计算新的加权平均价格 new_volume = position.volume + vol new_avg_price = (position.avg_price * position.volume + price * vol) / new_volume position.avg_price = new_avg_price position.volume = new_volume position.time = time else: # 如果方向相反，考虑部分平仓或完全平仓的情况 if abs(position.volume) \u0026gt; vol: # 部分平仓 position.volume -= vol elif abs(position.volume) == vol: # 完全平仓，删除仓位 del self.positions[symbol] else: # 平掉原仓位并开立新方向的仓位 new_vol = vol - abs(position.volume) position.direction = direction position.avg_price = price position.volume = new_vol position.time = time else: # 开立新仓位 self.positions[symbol] = Position(time=time, avg_price=price, symbol=symbol, direction=direction, volume=vol) def long(self, price, symbol, vol, leverage, time): \u0026#34;\u0026#34;\u0026#34; 开立多头仓位，使用杠杆购买资产。 :param price: 当前资产价格 :param symbol: 资产符号 :param vol: 购买的资产数量 :param leverage: 杠杆倍数 :param time: 当前时间 \u0026#34;\u0026#34;\u0026#34; margin_required = (price * vol) / leverage # if self.cash \u0026lt; margin_required: # print(\u0026#34;Not enough cash to open long position with leverage.\u0026#34;) # return self.cash -= margin_required fee = price * vol * self.feeRate self.totalFee += fee self._update_position(symbol, price, vol * leverage, \u0026#39;long\u0026#39;, time) msg = f\u0026#34;Long {symbol} at price: {price} for {vol} amount with leverage {leverage}\u0026#34; print(msg) msg_dict = { \u0026#34;symbol\u0026#34;: symbol, \u0026#34;price\u0026#34;: price, \u0026#34;vol\u0026#34;: vol, \u0026#34;action\u0026#34;: \u0026#34;long\u0026#34; } self.msg.append(msg_dict) def short(self, price, symbol, vol, leverage, time): \u0026#34;\u0026#34;\u0026#34; 开立空头仓位，使用杠杆卖出资产。 :param price: 当前资产价格 :param symbol: 资产符号 :param vol: 卖出的资产数量 :param leverage: 杠杆倍数 :param time: 当前时间 \u0026#34;\u0026#34;\u0026#34; margin_required = (price * vol) / leverage # if self.cash \u0026lt; margin_required: # print(\u0026#34;Not enough cash to open short position with leverage.\u0026#34;) # return self.cash -= margin_required fee = price * vol * self.feeRate self.totalFee += fee self._update_position(symbol, price, vol * leverage, \u0026#39;short\u0026#39;, time) msg = f\u0026#34;Short {symbol} at price: {price} for {vol} amount with leverage {leverage}\u0026#34; print(msg) msg_dict = { \u0026#34;symbol\u0026#34;: symbol, \u0026#34;price\u0026#34;: price, \u0026#34;vol\u0026#34;: vol, \u0026#34;action\u0026#34;: \u0026#34;short\u0026#34; } self.msg.append(msg_dict) def cover_long(self, price, symbol, vol, time): \u0026#34;\u0026#34;\u0026#34; 平掉多头仓位。 :param price: 当前资产价格 :param symbol: 资产符号 :param vol: 平仓的资产数量 :param time: 当前时间 \u0026#34;\u0026#34;\u0026#34; if symbol not in self.positions or self.positions[symbol].direction != \u0026#39;long\u0026#39;: print(\u0026#34;No long position to cover.\u0026#34;) return fee = price * vol * self.feeRate self.totalFee += fee position_worth = self.positions[symbol].avg_price * vol pnl = (price - self.positions[symbol].avg_price) * vol self.cash += pnl + position_worth - fee self._update_position(symbol, price, vol, \u0026#39;cover_long\u0026#39;, time) msg = f\u0026#34;Cover long {symbol} at price: {price} for {vol} amount\u0026#34; print(msg) msg_dict = { \u0026#34;symbol\u0026#34;: symbol, \u0026#34;price\u0026#34;: price, \u0026#34;vol\u0026#34;: vol, \u0026#34;action\u0026#34;: \u0026#34;cover long\u0026#34; } self.msg.append(msg_dict) def cover_short(self, price, symbol, vol, time): \u0026#34;\u0026#34;\u0026#34; 平掉空头仓位。 :param price: 当前资产价格 :param symbol: 资产符号 :param vol: 平仓的资产数量 :param time: 当前时间 \u0026#34;\u0026#34;\u0026#34; if symbol not in self.positions or self.positions[symbol].direction != \u0026#39;short\u0026#39;: print(\u0026#34;No short position to cover.\u0026#34;) return fee = price * vol * self.feeRate self.totalFee += fee position_worth = self.positions[symbol].avg_price * vol pnl = (self.positions[symbol].avg_price - price) * vol self.cash += pnl + position_worth - fee self._update_position(symbol, price, vol, \u0026#39;cover_short\u0026#39;, time) msg = f\u0026#34;Cover short {symbol} at price: {price} for {vol} amount\u0026#34; print(msg) msg_dict = { \u0026#34;symbol\u0026#34;: symbol, \u0026#34;price\u0026#34;: price, \u0026#34;vol\u0026#34;: vol, \u0026#34;action\u0026#34;: \u0026#34;cover short\u0026#34; } self.msg.append(msg_dict) def calculate_total_account_equity(self, current_prices: dict): \u0026#34;\u0026#34;\u0026#34; 计算当前账户的总净值，包括现金和所有持仓的浮动盈亏。 :param current_prices: dict，包含每个资产的当前价格，例如：{\u0026#34;BTC\u0026#34;: 40000, \u0026#34;ETH\u0026#34;: 3000} \u0026#34;\u0026#34;\u0026#34; total_pnl = 0 position_worth = 0 for symbol, position in self.positions.items(): if symbol in current_prices: current_price: BarData = current_prices[symbol] if position.direction == \u0026#39;long\u0026#39;: pnl = (current_price.close - position.avg_price) * position.volume elif position.direction == \u0026#39;short\u0026#39;: pnl = (position.avg_price - current_price.close) * position.volume position_worth += position.volume * position.avg_price total_pnl += pnl total_equity = self.cash + total_pnl + position_worth # print(f\u0026#34;Total Account Equity: {total_equity:.2f} USD\u0026#34;) return total_equity def get_current_pos_profit_rate(self, current_prices:dict): total_pnl = 0 position_worth = 0 for symbol, position in self.positions.items(): if symbol in current_prices: current_price: BarData = current_prices[symbol] if position.direction == \u0026#39;long\u0026#39;: pnl = (current_price.close - position.avg_price) * position.volume elif position.direction == \u0026#39;short\u0026#39;: pnl = (position.avg_price - current_price.close) * position.volume position_worth += position.volume * position.avg_price total_pnl += pnl profit_rate = total_pnl / position_worth return profit_rate ",
  "keywords": [
    
  ],
  "articleBody": "Cointegration strategy backtesting framework from backtest_multi_symbols import Broker, BarData, Backtestor, Position, DailyBar from collections import deque from statsmodels.tsa.stattools import coint import pandas as pd import numpy as np from itertools import combinations from sklearn.linear_model import LinearRegression from statsmodels.tsa.stattools import adfuller from model_new.bayesian_regression import bayesian_rolling_window from model_new.jointCov2 import fit_HGP from model_new.BayesGAM import bayesian_gam_with_splines from model_new.BSTS import bsts_fit class Log: def __init__(self, broker: Broker): self.resultPath = 'backTestResult/backtestLog' self.logs = [] self.broker = broker def logging(self, bars: dict): data = {} for symbol in bars: data[f\"close_{symbol}\"] = bars[symbol].close pos = self.broker.positions.get(symbol, 0) if pos != 0: data[f\"position_{symbol}\"] = self.broker.positions[symbol].volume data[f\"position_{symbol}_worth\"] = self.broker.positions[symbol].volume * bars[symbol].close data['time'] = bars[symbol].time equity = self.broker.calculate_total_account_equity(bars) data[\"equity\"] = equity data['cash'] = self.broker.cash self.logs.append(data) def save_logs(self): df = pd.DataFrame(self.logs) # df.to_csv(self.resultPath + '.csv', index=False) class BacktestorPairTrading(Backtestor): def __init__(self, broker: Broker, strategy, log, start, end): super().__init__(broker, strategy, log, start, end) self.log: Log = log def run_backtest(self): for i in range(self.data_length): bars = {} for symbol in self.symbols: data = self.data[f'{symbol}'].iloc[i] bar = BarData(data['timestamp'], data['open'], data['high'], data['low'], ((data['close'])), data['volume']) bars[symbol] = bar self.strategy.processBar(bars) self.log.logging(bars) equity = self.broker.calculate_total_account_equity(bars) accountPNL = equity - self.strategy.initial_balance if accountPNL/self.strategy.initial_balance \u003c -self.strategy.stop_loss: print(f\"stop loss at {self.strategy.stop_loss} !!!\") break self.on_close(bars) self.log.save_logs() def on_close(self, bars): if self.strategy.is_open: print('out of time force close') self.strategy.close_position_new(bars, ignore_diff=True) class Cointegration: def __init__(self, broker: Broker, setting: dict): self.short_leg = setting['short_leg'] self.long_leg = setting['long_leg'] self.open_margin = setting['open_margin'] self.close_margin = setting['close_margin'] self.grid_amount = setting['grid_amount'] self.array_len = setting['array_len'] self.stop_loss = setting['stop_loss'] self.pValue = setting['pValue'] self.initial_balance = broker.cash self.maximum_holding_period = setting['maximum_holding_period'] self.broker = broker self.beta = None self.intercept = None self.mean = None self.dev = None self.start = False self.open_diff = None self.bar_array = deque(maxlen=self.array_len) self.spread_array = deque(maxlen=self.array_len) self.is_open = False self.holding_count = 0 def get_model(self): pass def get_legs(self): long_legs = [] short_legs = [] for i in range(self.array_len): bar = self.bar_array[i] long_legs.append(np.log(bar[self.long_leg])) short_legs.append(np.log(bar[self.short_leg])) return long_legs, short_legs def get_beta(self): long_legs, short_legs = self.get_legs() # 使用 scikit-learn 回归模型计算 Beta（不带截距） long_legs = np.array(long_legs).reshape(-1, 1) short_legs = np.array(short_legs) model = LinearRegression(fit_intercept=True).fit(long_legs, short_legs) beta = model.coef_[0] intercept = model.intercept_ return beta, intercept def get_beta_BayesRegression(self): long_legs, short_legs = self.get_legs() result = bayesian_rolling_window(long_legs, short_legs, window_size=20) y_values = result['y'] beta_values = result['beta'] mu_values = result['mu'] epsilon_values = result['epsilon'] y_pred_mean = y_values['mean'] y_pred_upper = y_values['upper'] y_pred_lower = y_values['lower'] beta_posterior = beta_values['mean'] beta_upper = beta_values['upper'] beta_lower = beta_values['lower'] mu_posterior = mu_values['mean'] mu_upper = mu_values['upper'] mu_lower = mu_values['lower'] epsilon_mean = epsilon_values['mean'] epsilon_upper = epsilon_values['upper'] epsilon_lower = epsilon_values['lower'] return beta_posterior[-1], mu_posterior[-1] def get_beta_GPs(self): long_legs, short_legs = self.get_legs() long_legs = np.array(long_legs) short_legs = np.array(short_legs) result = fit_HGP(long_legs, short_legs) y_values = result['y'] beta_values = result['beta'] mu_values = result['mu'] epsilon_values = result['epsilon'] y_pred_mean = y_values['mean'] y_pred_upper = y_values['upper'] y_pred_lower = y_values['lower'] beta_posterior = beta_values['mean'] beta_upper = beta_values['upper'] beta_lower = beta_values['lower'] mu_posterior = mu_values['mean'] mu_upper = mu_values['upper'] mu_lower = mu_values['lower'] epsilon_mean = epsilon_values['mean'] epsilon_upper = epsilon_values['upper'] epsilon_lower = epsilon_values['lower'] return np.float64(beta_posterior[-1]), np.float64(mu_posterior[-1]) def get_beta_BSTS(self): pass def get_beta_GAM(self): long_legs = [] short_legs = [] for i in range(self.array_len): bar = self.bar_array[i] long_legs.append(bar[self.long_leg]) short_legs.append(bar[self.short_leg]) long_legs = np.array(long_legs) short_legs = np.array(short_legs) result = bayesian_gam_with_splines(long_legs,short_legs,df=10) y_values = result['y'] beta_values = result['beta'] mu_values = result['mu'] epsilon_values = result['epsilon'] y_pred_mean = y_values['mean'] y_pred_upper = y_values['upper'] y_pred_lower = y_values['lower'] beta_posterior = beta_values['mean'] beta_upper = beta_values['upper'] beta_lower = beta_values['lower'] mu_posterior = mu_values['mean'] mu_upper = mu_values['upper'] mu_lower = mu_values['lower'] epsilon_mean = epsilon_values['mean'] epsilon_upper = epsilon_values['upper'] epsilon_lower = epsilon_values['lower'] return beta_posterior[-1], mu_posterior[-1] def processBar(self, bars: dict): from math import log # append log data bar = { self.short_leg: (bars[self.short_leg].close), self.long_leg: (bars[self.long_leg].close), } self.bar_array.append(bar) if len(self.bar_array) \u003c self.array_len: return p_value = self.coin_test() spread, _ = self.spread(bars) self.spread_array.append(spread) if len(self.spread_array) \u003c self.array_len/5: return if self.is_open: self.holding_count += 1 spread, _ = self.spread(bars) diff = (spread - self.mean) / self.dev if self.holding_count \u003e= self.maximum_holding_period: print('holding too long force quit') self.close_position_new(bars, ignore_diff=True) self.holding_count = 0 return if self.mean: diff = (spread - self.mean) / self.dev # print(f\"current diff {diff}\") adf_center = adfuller(self.spread_array, regression='c')[1] adf_trend = adfuller(self.spread_array, regression='ct')[1] if adf_center \u003c self.pValue: self.is_stationary = True else: self.is_stationary = False # if adf_trend \u003c 0.05: # print(f'adf ct test result {adf_trend}, has a trend, not enter trading') # return # if p_value \u003c= self.pValue: if self.is_stationary: self.hedge(bars) elif self.is_open: self.close_position_new(bars) def hedge(self, bars: dict): if not self.is_open: # self.open_position(bars) self.open_position_new(bars) else: self.close_position_new(bars) def open_position_new(self, bars: dict): spread, _ = self.spread(bars) self.mean, self.dev = self.get_diff(spread) diff = (spread - self.mean) / self.dev long_leg_price = (bars[self.long_leg].close) short_leg_price = (bars[self.short_leg].close) time = bars[self.short_leg].time short_leg_qty = self.grid_amount/(long_leg_price*abs(self.beta) + short_leg_price) long_leg_qty = short_leg_qty*abs(self.beta) if abs(diff) \u003e 2: print( f'open parameter beta: {self.beta}, intercept: {self.intercept}, spread mean:{self.mean}, spread dev {self.dev}, diff:{diff} , time:{time}') self.open_diff = diff if self.beta \u003c 0: if diff \u003e 0: self.broker.short( price=long_leg_price, symbol=self.long_leg, vol=long_leg_qty, leverage=1, time=time) self.broker.short( price=short_leg_price, symbol=self.short_leg, vol=short_leg_qty, leverage=1, time=time) self.is_open = True else: self.broker.long( price=long_leg_price, symbol=self.long_leg, vol=long_leg_qty, leverage=1, time=time) self.broker.long( price=short_leg_price, symbol=self.short_leg, vol=short_leg_qty, leverage=1, time=time) self.is_open = True else: if diff \u003e 0: self.broker.long( price=long_leg_price, symbol=self.long_leg, vol=long_leg_qty, leverage=1, time=time) self.broker.short( price=short_leg_price, symbol=self.short_leg, vol=short_leg_qty, leverage=1, time=time) self.is_open = True else: self.broker.long( price=short_leg_price, symbol=self.short_leg, vol=short_leg_qty, leverage=1, time=time) self.broker.short( price=long_leg_price, symbol=self.long_leg, vol=long_leg_qty, leverage=1, time=time) self.is_open = True def close_position_new(self, bars: dict, ignore_diff=False): spread, _ = self.spread(bars) diff = (spread - self.mean) / self.dev # calculate position pnl long_leg_price = (bars[self.long_leg].close) short_leg_price = (bars[self.short_leg].close) time = bars[self.short_leg].time long_leg_pos: Position = self.broker.positions[self.long_leg] short_leg_pos: Position = self.broker.positions[self.short_leg] # Close the position when the unrealize loss is too much !!! # profit_rate = self.broker.get_current_pos_profit_rate(bars) # if profit_rate \u003c -0.1: # print('position profit rate is too low, force quit') # ignore_diff = True if (self.open_diff \u003e 0 and diff \u003c 0) or (self.open_diff \u003c 0 and diff \u003e 0) or ignore_diff: # if abs(diff) \u003c -2 or ignore_diff: self.holding_count = 0 print( f'close parameter beta: {self.beta}, intercept: {self.intercept}, spread mean:{self.mean}, spread dev {self.dev}, diff:{diff} , time:{time}') if short_leg_pos.direction == 'short': self.broker.cover_short( price=short_leg_price, symbol=self.short_leg, vol=short_leg_pos.volume, time=time) else: self.broker.cover_long( price=short_leg_price, symbol=self.short_leg, vol=short_leg_pos.volume, time=time) if long_leg_pos.direction == 'short': self.broker.cover_short( price=long_leg_price, symbol=self.long_leg, vol=long_leg_pos.volume, time=time) else: self.broker.cover_long( price=long_leg_price, symbol=self.long_leg, vol=long_leg_pos.volume, time=time) self.is_open = False self.beta, self.intercept = None, None def spread(self, bars: dict): long: BarData = bars[self.long_leg] short: BarData = bars[self.short_leg] long_price = (long.close) short_price = (short.close) spread = short_price - (self.beta * long_price + self.intercept) diff = spread / (self.beta * long_price + self.intercept) return spread, diff def get_diff(self, spread): mean = np.mean(self.spread_array) dev = np.std(self.spread_array) return mean, dev def coin_test(self): long_legs = [] short_legs = [] for i in range(self.array_len): bar = self.bar_array[i] long_legs.append(bar[self.long_leg]) short_legs.append(bar[self.short_leg]) if not self.beta: self.beta, self.intercept = self.get_beta_GPs() long_legs_modify = [] for i in range(self.array_len): new_long_leg = long_legs[i] * self.beta + self.intercept long_legs_modify.append(new_long_leg) _, p_value, _ = coint(long_legs_modify, short_legs) return p_value def generate_combinations(symbols): return list(combinations(symbols, 2)) p_value = 0.99 stop_loss = 0.5 def main(selected_symbols): cash = 1000000 transactionFeeRate = 0 start = '2023-01-01' end = '2024-10-31' broker = Broker(cash, transactionFeeRate, selected_symbols) setting = { 'short_leg': selected_symbols[0], 'long_leg': selected_symbols[1], 'open_margin': 0.05, 'close_margin': 0.02, 'stop_loss': stop_loss, 'pValue': 0.05, 'grid_amount': cash * 0.2, 'array_len': 300, 'maximum_holding_period': 300, } strategy = Cointegration(broker, setting) log = Log(broker) backtestor = BacktestorPairTrading(broker, strategy, log, start, end) backtestor.load_data() backtestor.run_backtest() result = backtestor.performance() msg_df = pd.DataFrame(broker.msg) profit, loss, winrate = analyze_arbitrage_cycles(msg_df) # msg_df.to_csv('backTestResult/msg_df.csv') pnl_ratio = profit / loss result['pnl_ratio'] = pnl_ratio result['win_rate'] = winrate return result # msg_df = pd.DataFrame(broker.msg) # msg_df.to_csv('backTestResult/msg_df.csv') if __name__ == '__main__': from backTestResult.cointegration_analysis import analyze_arbitrage_cycles cash = 1000000 transactionFeeRate = 0.00025 start = '2023-01-01' end = '2024-10-31' long_leg = 'DOGE' short_leg = 'XRP' selected_symbols = [long_leg, short_leg] broker = Broker(cash, transactionFeeRate, selected_symbols) setting = { 'short_leg': short_leg, 'long_leg': long_leg, 'open_margin': 0.05, 'close_margin': 0.04, 'stop_loss': 0.4, 'pValue': 0.05, 'grid_amount': cash * 0.2, 'array_len': 200, 'maximum_holding_period': 24* 30, } strategy = Cointegration(broker, setting) log = Log(broker) backtestor = BacktestorPairTrading(broker, strategy, log, start, end) backtestor.load_data() backtestor.run_backtest() result = backtestor.performance() msg_df = pd.DataFrame(broker.msg) analyze_arbitrage_cycles(msg_df) msg_df.to_csv('backTestResult/msg_df.csv') Bayesian regression def bayesian_rolling_window(X_t, Y_t, window_size=30): T = len(X_t) beta_t_est = np.zeros(T) mu_t_est = np.zeros(T) beta_var_est = np.zeros(T) mu_var_est = np.zeros(T) residual_var_est = np.zeros(T) Y_pred = np.zeros(T) Y_std_est = np.zeros(T) # Prior parameters beta_mean_prior = 0 beta_var_prior = 1 mu_mean_prior = 0 mu_var_prior = 1 sigma_prior = 1 for t in range(window_size, T): # Get rolling window data X_window = np.float64(X_t[t - window_size:t]) Y_window = np.float64(Y_t[t - window_size:t]) # Posterior parameters for beta XTX = np.sum(X_window ** 2) XTY = np.sum(X_window * (Y_window - np.mean(Y_window))) beta_var_post = 1 / (1 / beta_var_prior + XTX / sigma_prior) beta_mean_post = beta_var_post * (beta_mean_prior / beta_var_prior + XTY / sigma_prior) # Posterior parameters for mu mu_var_post = 1 / (1 / mu_var_prior + window_size / sigma_prior) mu_mean_post = mu_var_post * (mu_mean_prior / mu_var_prior + np.sum(Y_window - beta_mean_post * X_window) / sigma_prior) # Estimate residual variance residuals_window = Y_window - (beta_mean_post * X_window + mu_mean_post) residual_var_est[t] = np.var(residuals_window) # Store estimates beta_t_est[t] = beta_mean_post mu_t_est[t] = mu_mean_post beta_var_est[t] = beta_var_post mu_var_est[t] = mu_var_post # Predict Y_t and its credible interval Y_pred[t] = beta_t_est[t] * X_t[t] + mu_t_est[t] Y_var_est = (X_t[t] ** 2) * (beta_var_est[t]) + (mu_var_est[t]) + (1 / sigma_prior) Y_std_est[t] = np.sqrt(Y_var_est) # Prior parameters beta_mean_prior = beta_mean_post beta_var_prior = beta_var_post mu_mean_prior = mu_mean_post mu_var_prior = mu_var_post residuals = Y_t - Y_pred data = { 'y': { 'mean': Y_pred, 'upper': Y_pred + 1.96 * Y_std_est, 'lower': Y_pred - 1.96 * Y_std_est }, 'beta': { 'mean': beta_t_est, 'upper': beta_t_est + 1.96 * np.sqrt(beta_var_est), 'lower': beta_t_est - 1.96 * np.sqrt(beta_var_est) }, 'mu': { 'mean': mu_t_est, 'upper': mu_t_est + 1.96 * np.sqrt(mu_var_est), 'lower': mu_t_est - 1.96 * np.sqrt(mu_var_est) }, 'epsilon': { 'mean': residuals, 'upper': residuals + 1.96 * np.sqrt(residual_var_est), 'lower': residuals - 1.96 * np.sqrt(residual_var_est) }, } return data Bayesian GAM def bayesian_gam_with_splines(X_t, Y_t, df=10): T = len(X_t) time = np.linspace(0, 1, T) # Design matrices for splines design_matrix = patsy.dmatrix(f\"bs(time, df={df}, degree=3)\", {\"time\": time}, return_type='dataframe') # Joint Bayesian Ridge Regression for beta_t and mu_t X_joint = np.hstack([np.multiply(design_matrix.values, X_t[:, None]), design_matrix.values]) model_joint = BayesianRidge() model_joint.fit(X_joint, Y_t) # Predict values with uncertainties Y_pred, Y_std = model_joint.predict(X_joint, return_std=True) # Separate beta_t and mu_t beta_t_est = design_matrix.values @ model_joint.coef_[:design_matrix.shape[1]] mu_t_est = design_matrix.values @ model_joint.coef_[design_matrix.shape[1]:] # Compute standard deviations for beta and mu coef_cov = np.linalg.inv(model_joint.alpha_ * np.eye(X_joint.shape[1]) + model_joint.lambda_ * X_joint.T @ X_joint) beta_std_est = np.sqrt(np.sum((design_matrix.values @ coef_cov[:design_matrix.shape[1], :design_matrix.shape[1]]) * design_matrix.values, axis=1)) mu_std_est = np.sqrt(np.sum((design_matrix.values @ coef_cov[design_matrix.shape[1]:, design_matrix.shape[1]:]) * design_matrix.values, axis=1)) # Posterior variance of noise residual_var_est = 1 / model_joint.alpha_ # Posterior noise variance residuals = Y_t - Y_pred data = { 'y': { 'mean': Y_pred, 'upper': Y_pred + 1.96 * Y_std, 'lower': Y_pred - 1.96 * Y_std }, 'beta': { 'mean': beta_t_est, 'upper': beta_t_est + 1.96 * beta_std_est, 'lower': beta_t_est - 1.96 * beta_std_est }, 'mu': { 'mean': mu_t_est, 'upper': mu_t_est + 1.96 * mu_std_est, 'lower': mu_t_est - 1.96 * mu_std_est }, 'epsilon': { 'mean': residuals, 'upper': residuals + 1.96 * np.sqrt(residual_var_est), 'lower': residuals - 1.96 * np.sqrt(residual_var_est) }, } return data Gaussian Process class TimeVaryingGP(ExactGP): def __init__(self, train_x, train_y, likelihood): super(TimeVaryingGP, self).__init__(train_x, train_y, likelihood) # Separate kernels for each component self.beta_kernel = ScaleKernel(RBFKernel()) # self.beta_kernel.base_kernel.register_prior( # 'lengthscale_prior', # gpytorch.priors.GammaPrior(10.0, 20.0), # 'lengthscale' # ) self.mu_kernel = ScaleKernel(RBFKernel()) self.eps_kernel = ScaleKernel(RBFKernel()) self.mean = ZeroMean() def forward(self, x): # Extract time and covariates t = x[:, 0] # time index X = x[:, 1] # covariate # Compute kernel matrices K_beta = self.beta_kernel(t) K_mu = self.mu_kernel(t) K_eps = self.eps_kernel(t) # Compute covariance matrix covar = X.unsqueeze(1) * K_beta * X.unsqueeze(0) + K_mu + K_eps mean = self.mean(x) return MultivariateNormal(mean, covar) def train_model(X, y, n_iter=100): if not isinstance(X, torch.Tensor): X = torch.from_numpy(X).clone().detach().float() y = torch.from_numpy(y).clone().detach().float() else: X = X.clone().detach().float() y = y.clone().detach().float() # Initialize model likelihood = gpytorch.likelihoods.GaussianLikelihood() model = TimeVaryingGP(X, y, likelihood) # Use the adam optimizer optimizer = torch.optim.Adam([ {'params': model.parameters()}, ], lr=0.1) # \"Loss\" for GPs - the marginal log likelihood mll = gpytorch.mlls.ExactMarginalLogLikelihood(likelihood, model) # Training loop model.train() likelihood.train() for i in range(n_iter): optimizer.zero_grad() output = model(X) loss = -mll(output, y) loss.backward() optimizer.step() return model, likelihood def predict_latent(model, X_train, y_train, X_new): model.eval() jitter = 1e-6 with torch.no_grad(): t_train = X_train[:, 0] x_train = X_train[:, 1] t_new = X_new[:, 0] x_new = X_new[:, 1] K_beta = model.beta_kernel(t_new, t_train).evaluate() K_mu = model.mu_kernel(t_new, t_train).evaluate() K_eps = model.eps_kernel(t_new, t_train).evaluate() K_total = x_train * model.beta_kernel(t_train).evaluate() * x_train.unsqueeze(-1) + \\ model.mu_kernel(t_train).evaluate() + \\ model.eps_kernel(t_train).evaluate() + \\ model.likelihood.noise * torch.eye(len(t_train)) + \\ jitter * torch.eye(len(t_train)) K_new_beta = model.beta_kernel(t_new).evaluate() + jitter * torch.eye(len(t_new)) K_new_mu = model.mu_kernel(t_new).evaluate() + jitter * torch.eye(len(t_new)) K_new_eps = model.eps_kernel(t_new).evaluate() + jitter * torch.eye(len(t_new)) # Compute posterior mean using Cholesky L = torch.linalg.cholesky(K_total) alpha = torch.linalg.solve_triangular(L, y_train.unsqueeze(1), upper=False) alpha = torch.linalg.solve_triangular(L.T, alpha, upper=True) K_stacked = torch.stack([ x_new.unsqueeze(-1) * K_beta, K_mu, K_eps ]) posterior_mean = K_stacked @ alpha # Compute posterior variance using Cholesky v_beta = torch.linalg.solve_triangular(L, (x_train * K_beta.T).T, upper=False) v_mu = torch.linalg.solve_triangular(L, K_mu.T, upper=False) v_eps = torch.linalg.solve_triangular(L, K_eps.T, upper=False) post_var_beta = K_new_beta - v_beta.T @ v_beta post_var_mu = K_new_mu - v_mu.T @ v_mu post_var_eps = K_new_eps - v_eps.T @ v_eps return { 'mean': { 'beta': posterior_mean[0].squeeze(), 'mu': posterior_mean[1].squeeze(), 'epsilon': posterior_mean[2].squeeze() }, 'variance': { 'beta': post_var_beta.diag(), 'mu': post_var_mu.diag(), 'epsilon': post_var_eps.diag() } } def predict(model, likelihood, X_new, X_train=None, y_train=None): model.eval() likelihood.eval() if X_train is None: X_train = model.train_inputs[0] if y_train is None: y_train = model.train_targets with torch.no_grad(), gpytorch.settings.fast_pred_var(): observed_pred = likelihood(model(X_new)) latent_values = predict_latent(model, X_train, y_train, X_new) return observed_pred.mean, observed_pred.variance, latent_values BSTS def bsts_fit(x,y): with pm.Model() as model: # Priors for variances # sigma = pm.HalfCauchy('sigma', beta=1) # Random walk for log volatility log_sigma = pm.GaussianRandomWalk('log_sigma', sigma=0.1, shape=len(y), init_dist=pm.Normal.dist(mu=0, sigma=1)) sigma = pm.Deterministic('sigma', pm.math.exp(log_sigma)) sigma_beta = pm.HalfCauchy('sigma_beta', beta=1) sigma_mu = pm.HalfCauchy('sigma_mu', beta=1) # Gaussian Random Walks for beta and mu beta = pm.GaussianRandomWalk('beta', sigma=sigma_beta, init_dist=pm.Normal.dist(0, 10), shape=len(y)) mu = pm.GaussianRandomWalk('mu', sigma=sigma_mu, init_dist=pm.Normal.dist(0, 10), shape=len(y)) # Observation model Y_obs = pm.Normal('Y_obs', mu=beta * x + mu, sigma=sigma, observed=y) # ---- 3. MCMC Sampling ---- trace = pm.sample(1000, tune=1000, chains=2, target_accept=0.9) ppc = pm.sample_posterior_predictive(trace, var_names=[\"Y_obs\"], random_seed=42) # Extract posterior mean and 95% credible intervals beta_posterior = trace.posterior['beta'].mean(dim=(\"chain\", \"draw\")) beta_lower = trace.posterior['beta'].quantile(0.025, dim=(\"chain\", \"draw\")) beta_upper = trace.posterior['beta'].quantile(0.975, dim=(\"chain\", \"draw\")) mu_posterior = trace.posterior['mu'].mean(dim=(\"chain\", \"draw\")) mu_lower = trace.posterior['mu'].quantile(0.025, dim=(\"chain\", \"draw\")) mu_upper = trace.posterior['mu'].quantile(0.975, dim=(\"chain\", \"draw\")) # Extract posterior predictive samples y_pred_samples = ppc.posterior_predictive['Y_obs'] # Calculate mean and 95% prediction interval y_pred_mean = y_pred_samples.mean(dim=('chain', 'draw')).values y_pred_lower = np.percentile(y_pred_samples.values, 2.5, axis=(0, 1)) # 2.5% quantile y_pred_upper = np.percentile(y_pred_samples.values, 97.5, axis=(0, 1)) # 97.5% quantile epsilon_samples = y - y_pred_samples.values # Shape: (chains, draws, time) # ---- 3. Calculate Mean and Intervals ---- # Mean residuals epsilon_mean = epsilon_samples.mean(axis=(0, 1)) # Average over chains and draws # 95% prediction intervals epsilon_lower = np.percentile(epsilon_samples, 2.5, axis=(0, 1)) epsilon_upper = np.percentile(epsilon_samples, 97.5, axis=(0, 1)) data = { 'y': { 'mean': y_pred_mean, 'upper': y_pred_upper, 'lower': y_pred_lower }, 'beta': { 'mean': beta_posterior, 'upper': beta_upper, 'lower': beta_lower }, 'mu': { 'mean': mu_posterior, 'upper': mu_upper, 'lower': mu_lower }, 'epsilon': { 'mean': epsilon_mean, 'upper': epsilon_upper, 'lower': epsilon_lower }, } return data Gaussian Process clustering import pandas as pd import numpy as np from sklearn.cluster import KMeans import gpytorch import torch class SparseGPModel(gpytorch.models.ApproximateGP): def __init__(self, inducing_points): variational_distribution = gpytorch.variational.CholeskyVariationalDistribution(inducing_points.size(0)) variational_strategy = gpytorch.variational.VariationalStrategy( self, inducing_points, variational_distribution, learn_inducing_locations=True ) super().__init__(variational_strategy) # Define kernel: RBF kernel with constant mean self.mean_module = gpytorch.means.ConstantMean() self.covar_module = gpytorch.kernels.ScaleKernel(gpytorch.kernels.RBFKernel()) def forward(self, x): mean_x = self.mean_module(x) covar_x = self.covar_module(x) return gpytorch.distributions.MultivariateNormal(mean_x, covar_x) def sparse_gpr_hyperparameter_clustering(data, n_clusters=3, num_inducing=10, verbose=True): symbols = data.iloc[:, 0].values time_points = torch.tensor(np.arange(data.shape[1] - 1), dtype=torch.float32) # Time indices time_series = torch.tensor(data.iloc[:, 1:].values, dtype=torch.float32) # Time series values # Initialize list to store hyperparameters hyperparameters = [] if verbose: print(\"Starting Sparse Gaussian Process Regression for each stock...\\n\") for idx, ts in enumerate(time_series): ts = ts.unsqueeze(-1) # Add a dimension for compatibility (n_samples, 1) inducing_points = time_points[::len(time_points) // num_inducing][:num_inducing].unsqueeze(-1) model = SparseGPModel(inducing_points) likelihood = gpytorch.likelihoods.GaussianLikelihood() model.train() likelihood.train() optimizer = torch.optim.Adam(model.parameters(), lr=0.1) mll = gpytorch.mlls.VariationalELBO(likelihood, model, num_data=len(time_points)) # Training loop (simple with fixed iterations for now) training_iter = 100 # You can adjust this for i in range(training_iter): optimizer.zero_grad() output = model(time_points.unsqueeze(-1)) loss = -mll(output, ts).sum() loss.backward() optimizer.step() # Extract learned hyperparameters kernel_params = model.covar_module.base_kernel.lengthscale.item() outputscale = model.covar_module.outputscale.item() noise = likelihood.noise.item() hyperparameters.append([outputscale, kernel_params, noise]) if verbose: print(f\"Processed {idx + 1}/{len(time_series)}: Symbol = {symbols[idx]}, \" f\"Output Scale = {outputscale:.3f}, Length Scale = {kernel_params:.3f}, noise = {noise:.3f}\") if verbose: print(\"\\nFinished Sparse Gaussian Process Regression.\") print(\"Starting clustering on hyperparameters...\\n\") # Perform clustering on hyperparameters hyperparameters = np.array(hyperparameters) kmeans = KMeans(n_clusters=n_clusters, random_state=0) labels = kmeans.fit_predict(hyperparameters) clusters = {} for cluster_id in range(n_clusters): clusters[f'Cluster{cluster_id+1}'] = symbols[labels == cluster_id].tolist() if verbose: print(f\"Cluster {cluster_id + 1}: {len(clusters[f'Cluster{cluster_id+1}'])} symbols\") if verbose: print(\"\\nClustering complete. Summary:\") for cluster, symbols in clusters.items(): print(f\"{cluster}: {symbols}\") return clusters df = pd.read_csv('Quantitative_Research/model_new/bayesian_clustering/transposed_stock_data.csv') clusters = sparse_gpr_hyperparameter_clustering(df, n_clusters=10, verbose=True) print(clusters) Appendix broker object class Broker: def __init__(self, cash: float, feeRate: float, symbols: list): self.positions = {} self.wallet = {} for symbol in symbols: self.wallet[symbol] = 0 self.cash = cash self.feeRate = feeRate self.totalFee = 0 self.symbols = symbols self.msg = [] def buy(self, price, symbol, vol): # cash = self.cash # if cash - price * vol * (1 + self.feeRate) \u003c 0: # # print(\"not enough cash, but amount that minus fees\") # vol -= price * vol * self.feeRate / price self.cash -= price * vol * (1 + self.feeRate) self.wallet[symbol] += vol self.totalFee += price * vol * self.feeRate msg = f\"Buy {symbol} at price: {price} for {vol} amount\" print(msg) msg_dict = { \"symbol\": symbol, \"price\": price, \"vol\": vol, \"action\": \"buy\" } self.msg.append(msg_dict) def sell(self, price, symbol, vol): self.cash += price * vol * (1 - self.feeRate) self.wallet[symbol] -= vol self.totalFee += price * vol * self.feeRate msg = f\"Sell {symbol} at price: {price} for {vol} amount\" print(msg) msg_dict = { \"symbol\": symbol, \"price\": price, \"vol\": vol, \"action\": \"sell\" } self.msg.append(msg_dict) def _update_position(self, symbol, price, vol, direction, time): if symbol in self.positions: position = self.positions[symbol] if position.direction == direction: # 加仓，计算新的加权平均价格 new_volume = position.volume + vol new_avg_price = (position.avg_price * position.volume + price * vol) / new_volume position.avg_price = new_avg_price position.volume = new_volume position.time = time else: # 如果方向相反，考虑部分平仓或完全平仓的情况 if abs(position.volume) \u003e vol: # 部分平仓 position.volume -= vol elif abs(position.volume) == vol: # 完全平仓，删除仓位 del self.positions[symbol] else: # 平掉原仓位并开立新方向的仓位 new_vol = vol - abs(position.volume) position.direction = direction position.avg_price = price position.volume = new_vol position.time = time else: # 开立新仓位 self.positions[symbol] = Position(time=time, avg_price=price, symbol=symbol, direction=direction, volume=vol) def long(self, price, symbol, vol, leverage, time): \"\"\" 开立多头仓位，使用杠杆购买资产。 :param price: 当前资产价格 :param symbol: 资产符号 :param vol: 购买的资产数量 :param leverage: 杠杆倍数 :param time: 当前时间 \"\"\" margin_required = (price * vol) / leverage # if self.cash \u003c margin_required: # print(\"Not enough cash to open long position with leverage.\") # return self.cash -= margin_required fee = price * vol * self.feeRate self.totalFee += fee self._update_position(symbol, price, vol * leverage, 'long', time) msg = f\"Long {symbol} at price: {price} for {vol} amount with leverage {leverage}\" print(msg) msg_dict = { \"symbol\": symbol, \"price\": price, \"vol\": vol, \"action\": \"long\" } self.msg.append(msg_dict) def short(self, price, symbol, vol, leverage, time): \"\"\" 开立空头仓位，使用杠杆卖出资产。 :param price: 当前资产价格 :param symbol: 资产符号 :param vol: 卖出的资产数量 :param leverage: 杠杆倍数 :param time: 当前时间 \"\"\" margin_required = (price * vol) / leverage # if self.cash \u003c margin_required: # print(\"Not enough cash to open short position with leverage.\") # return self.cash -= margin_required fee = price * vol * self.feeRate self.totalFee += fee self._update_position(symbol, price, vol * leverage, 'short', time) msg = f\"Short {symbol} at price: {price} for {vol} amount with leverage {leverage}\" print(msg) msg_dict = { \"symbol\": symbol, \"price\": price, \"vol\": vol, \"action\": \"short\" } self.msg.append(msg_dict) def cover_long(self, price, symbol, vol, time): \"\"\" 平掉多头仓位。 :param price: 当前资产价格 :param symbol: 资产符号 :param vol: 平仓的资产数量 :param time: 当前时间 \"\"\" if symbol not in self.positions or self.positions[symbol].direction != 'long': print(\"No long position to cover.\") return fee = price * vol * self.feeRate self.totalFee += fee position_worth = self.positions[symbol].avg_price * vol pnl = (price - self.positions[symbol].avg_price) * vol self.cash += pnl + position_worth - fee self._update_position(symbol, price, vol, 'cover_long', time) msg = f\"Cover long {symbol} at price: {price} for {vol} amount\" print(msg) msg_dict = { \"symbol\": symbol, \"price\": price, \"vol\": vol, \"action\": \"cover long\" } self.msg.append(msg_dict) def cover_short(self, price, symbol, vol, time): \"\"\" 平掉空头仓位。 :param price: 当前资产价格 :param symbol: 资产符号 :param vol: 平仓的资产数量 :param time: 当前时间 \"\"\" if symbol not in self.positions or self.positions[symbol].direction != 'short': print(\"No short position to cover.\") return fee = price * vol * self.feeRate self.totalFee += fee position_worth = self.positions[symbol].avg_price * vol pnl = (self.positions[symbol].avg_price - price) * vol self.cash += pnl + position_worth - fee self._update_position(symbol, price, vol, 'cover_short', time) msg = f\"Cover short {symbol} at price: {price} for {vol} amount\" print(msg) msg_dict = { \"symbol\": symbol, \"price\": price, \"vol\": vol, \"action\": \"cover short\" } self.msg.append(msg_dict) def calculate_total_account_equity(self, current_prices: dict): \"\"\" 计算当前账户的总净值，包括现金和所有持仓的浮动盈亏。 :param current_prices: dict，包含每个资产的当前价格，例如：{\"BTC\": 40000, \"ETH\": 3000} \"\"\" total_pnl = 0 position_worth = 0 for symbol, position in self.positions.items(): if symbol in current_prices: current_price: BarData = current_prices[symbol] if position.direction == 'long': pnl = (current_price.close - position.avg_price) * position.volume elif position.direction == 'short': pnl = (position.avg_price - current_price.close) * position.volume position_worth += position.volume * position.avg_price total_pnl += pnl total_equity = self.cash + total_pnl + position_worth # print(f\"Total Account Equity: {total_equity:.2f} USD\") return total_equity def get_current_pos_profit_rate(self, current_prices:dict): total_pnl = 0 position_worth = 0 for symbol, position in self.positions.items(): if symbol in current_prices: current_price: BarData = current_prices[symbol] if position.direction == 'long': pnl = (current_price.close - position.avg_price) * position.volume elif position.direction == 'short': pnl = (position.avg_price - current_price.close) * position.volume position_worth += position.volume * position.avg_price total_pnl += pnl profit_rate = total_pnl / position_worth return profit_rate ",
  "wordCount" : "3468",
  "inLanguage": "en",
  "datePublished": "2025-01-25T19:12:16+01:00",
  "dateModified": "2025-01-25T19:12:16+01:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://oldhuntor.github.io/posts/codesnippets/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Xuanhao's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://oldhuntor.github.io/favicon.ico"
    }
  }
}
</script>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.13/katex.min.css">
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.13/katex.min.js"></script>
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.13/contrib/auto-render.min.js"
            onload="renderMathInElement(document.body);"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "$", right: "$", display: false}
          ]
        });
      });
    </script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://oldhuntor.github.io/" accesskey="h" title="Xuanhao&#39;s Blog (Alt + H)">Xuanhao&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://oldhuntor.github.io/pdfs/xxx.pdf" title="My CV">
                    <span>My CV</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Bayesian Cointegration codes
    </h1>
    <div class="post-meta"><span title='2025-01-25 19:12:16 +0100 CET'>January 25, 2025</span>&nbsp;·&nbsp;17 min

</div>
  </header> 
  <div class="post-content"><h1 id="cointegration-strategy-backtesting-framework">Cointegration strategy backtesting framework<a hidden class="anchor" aria-hidden="true" href="#cointegration-strategy-backtesting-framework">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> backtest_multi_symbols <span style="color:#f92672">import</span> Broker, BarData, Backtestor, Position, DailyBar
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> collections <span style="color:#f92672">import</span> deque
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> statsmodels.tsa.stattools <span style="color:#f92672">import</span> coint
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> pandas <span style="color:#66d9ef">as</span> pd
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> itertools <span style="color:#f92672">import</span> combinations
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> sklearn.linear_model <span style="color:#f92672">import</span> LinearRegression
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> statsmodels.tsa.stattools <span style="color:#f92672">import</span> adfuller
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> model_new.bayesian_regression <span style="color:#f92672">import</span> bayesian_rolling_window
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> model_new.jointCov2 <span style="color:#f92672">import</span> fit_HGP
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> model_new.BayesGAM <span style="color:#f92672">import</span> bayesian_gam_with_splines
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> model_new.BSTS <span style="color:#f92672">import</span> bsts_fit
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Log</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, broker: Broker):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>resultPath <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;backTestResult/backtestLog&#39;</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>logs <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>broker <span style="color:#f92672">=</span> broker
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">logging</span>(self, bars: dict):
</span></span><span style="display:flex;"><span>        data <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> symbol <span style="color:#f92672">in</span> bars:
</span></span><span style="display:flex;"><span>            data[<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;close_</span><span style="color:#e6db74">{</span>symbol<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>] <span style="color:#f92672">=</span> bars[symbol]<span style="color:#f92672">.</span>close
</span></span><span style="display:flex;"><span>            pos <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>broker<span style="color:#f92672">.</span>positions<span style="color:#f92672">.</span>get(symbol, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> pos <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>                data[<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;position_</span><span style="color:#e6db74">{</span>symbol<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>] <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>broker<span style="color:#f92672">.</span>positions[symbol]<span style="color:#f92672">.</span>volume
</span></span><span style="display:flex;"><span>                data[<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;position_</span><span style="color:#e6db74">{</span>symbol<span style="color:#e6db74">}</span><span style="color:#e6db74">_worth&#34;</span>] <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>broker<span style="color:#f92672">.</span>positions[symbol]<span style="color:#f92672">.</span>volume <span style="color:#f92672">*</span> bars[symbol]<span style="color:#f92672">.</span>close
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            data[<span style="color:#e6db74">&#39;time&#39;</span>] <span style="color:#f92672">=</span> bars[symbol]<span style="color:#f92672">.</span>time
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        equity <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>broker<span style="color:#f92672">.</span>calculate_total_account_equity(bars)
</span></span><span style="display:flex;"><span>        data[<span style="color:#e6db74">&#34;equity&#34;</span>] <span style="color:#f92672">=</span> equity
</span></span><span style="display:flex;"><span>        data[<span style="color:#e6db74">&#39;cash&#39;</span>] <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>broker<span style="color:#f92672">.</span>cash
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>logs<span style="color:#f92672">.</span>append(data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">save_logs</span>(self):
</span></span><span style="display:flex;"><span>        df <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>DataFrame(self<span style="color:#f92672">.</span>logs)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># df.to_csv(self.resultPath + &#39;.csv&#39;, index=False)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BacktestorPairTrading</span>(Backtestor):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, broker: Broker, strategy, log, start, end):
</span></span><span style="display:flex;"><span>        super()<span style="color:#f92672">.</span>__init__(broker, strategy, log, start, end)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>log: Log <span style="color:#f92672">=</span> log
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">run_backtest</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>data_length):
</span></span><span style="display:flex;"><span>            bars <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> symbol <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>symbols:
</span></span><span style="display:flex;"><span>                data <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>data[<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>symbol<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>]<span style="color:#f92672">.</span>iloc[i]
</span></span><span style="display:flex;"><span>                bar <span style="color:#f92672">=</span> BarData(data[<span style="color:#e6db74">&#39;timestamp&#39;</span>], data[<span style="color:#e6db74">&#39;open&#39;</span>], data[<span style="color:#e6db74">&#39;high&#39;</span>], data[<span style="color:#e6db74">&#39;low&#39;</span>], ((data[<span style="color:#e6db74">&#39;close&#39;</span>])),
</span></span><span style="display:flex;"><span>                              data[<span style="color:#e6db74">&#39;volume&#39;</span>])
</span></span><span style="display:flex;"><span>                bars[symbol] <span style="color:#f92672">=</span> bar
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>strategy<span style="color:#f92672">.</span>processBar(bars)
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>log<span style="color:#f92672">.</span>logging(bars)
</span></span><span style="display:flex;"><span>            equity <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>broker<span style="color:#f92672">.</span>calculate_total_account_equity(bars)
</span></span><span style="display:flex;"><span>            accountPNL <span style="color:#f92672">=</span> equity <span style="color:#f92672">-</span> self<span style="color:#f92672">.</span>strategy<span style="color:#f92672">.</span>initial_balance
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> accountPNL<span style="color:#f92672">/</span>self<span style="color:#f92672">.</span>strategy<span style="color:#f92672">.</span>initial_balance <span style="color:#f92672">&lt;</span> <span style="color:#f92672">-</span>self<span style="color:#f92672">.</span>strategy<span style="color:#f92672">.</span>stop_loss:
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;stop loss at </span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>strategy<span style="color:#f92672">.</span>stop_loss<span style="color:#e6db74">}</span><span style="color:#e6db74"> !!!&#34;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>on_close(bars)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>log<span style="color:#f92672">.</span>save_logs()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">on_close</span>(self, bars):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>strategy<span style="color:#f92672">.</span>is_open:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#39;out of time force close&#39;</span>)
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>strategy<span style="color:#f92672">.</span>close_position_new(bars, ignore_diff<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cointegration</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, broker: Broker, setting: dict):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>short_leg <span style="color:#f92672">=</span> setting[<span style="color:#e6db74">&#39;short_leg&#39;</span>]
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>long_leg <span style="color:#f92672">=</span> setting[<span style="color:#e6db74">&#39;long_leg&#39;</span>]
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>open_margin <span style="color:#f92672">=</span> setting[<span style="color:#e6db74">&#39;open_margin&#39;</span>]
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>close_margin <span style="color:#f92672">=</span> setting[<span style="color:#e6db74">&#39;close_margin&#39;</span>]
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>grid_amount <span style="color:#f92672">=</span> setting[<span style="color:#e6db74">&#39;grid_amount&#39;</span>]
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>array_len <span style="color:#f92672">=</span> setting[<span style="color:#e6db74">&#39;array_len&#39;</span>]
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>stop_loss <span style="color:#f92672">=</span> setting[<span style="color:#e6db74">&#39;stop_loss&#39;</span>]
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>pValue <span style="color:#f92672">=</span> setting[<span style="color:#e6db74">&#39;pValue&#39;</span>]
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>initial_balance <span style="color:#f92672">=</span> broker<span style="color:#f92672">.</span>cash
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>maximum_holding_period <span style="color:#f92672">=</span> setting[<span style="color:#e6db74">&#39;maximum_holding_period&#39;</span>]
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>broker <span style="color:#f92672">=</span> broker
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>beta <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>intercept <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>mean <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>dev <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>start <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>open_diff <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>bar_array <span style="color:#f92672">=</span> deque(maxlen<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>array_len)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>spread_array <span style="color:#f92672">=</span> deque(maxlen<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>array_len)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>is_open <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>holding_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_model</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_legs</span>(self):
</span></span><span style="display:flex;"><span>        long_legs <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        short_legs <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>array_len):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            bar <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>bar_array[i]
</span></span><span style="display:flex;"><span>            long_legs<span style="color:#f92672">.</span>append(np<span style="color:#f92672">.</span>log(bar[self<span style="color:#f92672">.</span>long_leg]))
</span></span><span style="display:flex;"><span>            short_legs<span style="color:#f92672">.</span>append(np<span style="color:#f92672">.</span>log(bar[self<span style="color:#f92672">.</span>short_leg]))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> long_legs, short_legs
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_beta</span>(self):
</span></span><span style="display:flex;"><span>        long_legs, short_legs <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>get_legs()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 使用 scikit-learn 回归模型计算 Beta（不带截距）</span>
</span></span><span style="display:flex;"><span>        long_legs <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(long_legs)<span style="color:#f92672">.</span>reshape(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        short_legs <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(short_legs)
</span></span><span style="display:flex;"><span>        model <span style="color:#f92672">=</span> LinearRegression(fit_intercept<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)<span style="color:#f92672">.</span>fit(long_legs, short_legs)
</span></span><span style="display:flex;"><span>        beta <span style="color:#f92672">=</span> model<span style="color:#f92672">.</span>coef_[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>        intercept <span style="color:#f92672">=</span> model<span style="color:#f92672">.</span>intercept_
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> beta, intercept
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_beta_BayesRegression</span>(self):
</span></span><span style="display:flex;"><span>        long_legs, short_legs <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>get_legs()
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> bayesian_rolling_window(long_legs, short_legs, window_size<span style="color:#f92672">=</span><span style="color:#ae81ff">20</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        y_values <span style="color:#f92672">=</span> result[<span style="color:#e6db74">&#39;y&#39;</span>]
</span></span><span style="display:flex;"><span>        beta_values <span style="color:#f92672">=</span> result[<span style="color:#e6db74">&#39;beta&#39;</span>]
</span></span><span style="display:flex;"><span>        mu_values <span style="color:#f92672">=</span> result[<span style="color:#e6db74">&#39;mu&#39;</span>]
</span></span><span style="display:flex;"><span>        epsilon_values <span style="color:#f92672">=</span> result[<span style="color:#e6db74">&#39;epsilon&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        y_pred_mean <span style="color:#f92672">=</span> y_values[<span style="color:#e6db74">&#39;mean&#39;</span>]
</span></span><span style="display:flex;"><span>        y_pred_upper <span style="color:#f92672">=</span> y_values[<span style="color:#e6db74">&#39;upper&#39;</span>]
</span></span><span style="display:flex;"><span>        y_pred_lower <span style="color:#f92672">=</span> y_values[<span style="color:#e6db74">&#39;lower&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        beta_posterior <span style="color:#f92672">=</span> beta_values[<span style="color:#e6db74">&#39;mean&#39;</span>]
</span></span><span style="display:flex;"><span>        beta_upper <span style="color:#f92672">=</span> beta_values[<span style="color:#e6db74">&#39;upper&#39;</span>]
</span></span><span style="display:flex;"><span>        beta_lower <span style="color:#f92672">=</span> beta_values[<span style="color:#e6db74">&#39;lower&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        mu_posterior <span style="color:#f92672">=</span> mu_values[<span style="color:#e6db74">&#39;mean&#39;</span>]
</span></span><span style="display:flex;"><span>        mu_upper <span style="color:#f92672">=</span> mu_values[<span style="color:#e6db74">&#39;upper&#39;</span>]
</span></span><span style="display:flex;"><span>        mu_lower <span style="color:#f92672">=</span> mu_values[<span style="color:#e6db74">&#39;lower&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        epsilon_mean <span style="color:#f92672">=</span> epsilon_values[<span style="color:#e6db74">&#39;mean&#39;</span>]
</span></span><span style="display:flex;"><span>        epsilon_upper <span style="color:#f92672">=</span> epsilon_values[<span style="color:#e6db74">&#39;upper&#39;</span>]
</span></span><span style="display:flex;"><span>        epsilon_lower <span style="color:#f92672">=</span> epsilon_values[<span style="color:#e6db74">&#39;lower&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> beta_posterior[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], mu_posterior[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_beta_GPs</span>(self):
</span></span><span style="display:flex;"><span>        long_legs, short_legs <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>get_legs()
</span></span><span style="display:flex;"><span>        long_legs <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(long_legs)
</span></span><span style="display:flex;"><span>        short_legs <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(short_legs)
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> fit_HGP(long_legs, short_legs)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        y_values <span style="color:#f92672">=</span> result[<span style="color:#e6db74">&#39;y&#39;</span>]
</span></span><span style="display:flex;"><span>        beta_values <span style="color:#f92672">=</span> result[<span style="color:#e6db74">&#39;beta&#39;</span>]
</span></span><span style="display:flex;"><span>        mu_values <span style="color:#f92672">=</span> result[<span style="color:#e6db74">&#39;mu&#39;</span>]
</span></span><span style="display:flex;"><span>        epsilon_values <span style="color:#f92672">=</span> result[<span style="color:#e6db74">&#39;epsilon&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        y_pred_mean <span style="color:#f92672">=</span> y_values[<span style="color:#e6db74">&#39;mean&#39;</span>]
</span></span><span style="display:flex;"><span>        y_pred_upper <span style="color:#f92672">=</span> y_values[<span style="color:#e6db74">&#39;upper&#39;</span>]
</span></span><span style="display:flex;"><span>        y_pred_lower <span style="color:#f92672">=</span> y_values[<span style="color:#e6db74">&#39;lower&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        beta_posterior <span style="color:#f92672">=</span> beta_values[<span style="color:#e6db74">&#39;mean&#39;</span>]
</span></span><span style="display:flex;"><span>        beta_upper <span style="color:#f92672">=</span> beta_values[<span style="color:#e6db74">&#39;upper&#39;</span>]
</span></span><span style="display:flex;"><span>        beta_lower <span style="color:#f92672">=</span> beta_values[<span style="color:#e6db74">&#39;lower&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        mu_posterior <span style="color:#f92672">=</span> mu_values[<span style="color:#e6db74">&#39;mean&#39;</span>]
</span></span><span style="display:flex;"><span>        mu_upper <span style="color:#f92672">=</span> mu_values[<span style="color:#e6db74">&#39;upper&#39;</span>]
</span></span><span style="display:flex;"><span>        mu_lower <span style="color:#f92672">=</span> mu_values[<span style="color:#e6db74">&#39;lower&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        epsilon_mean <span style="color:#f92672">=</span> epsilon_values[<span style="color:#e6db74">&#39;mean&#39;</span>]
</span></span><span style="display:flex;"><span>        epsilon_upper <span style="color:#f92672">=</span> epsilon_values[<span style="color:#e6db74">&#39;upper&#39;</span>]
</span></span><span style="display:flex;"><span>        epsilon_lower <span style="color:#f92672">=</span> epsilon_values[<span style="color:#e6db74">&#39;lower&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>float64(beta_posterior[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]), np<span style="color:#f92672">.</span>float64(mu_posterior[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_beta_BSTS</span>(self):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_beta_GAM</span>(self):
</span></span><span style="display:flex;"><span>        long_legs <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        short_legs <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>array_len):
</span></span><span style="display:flex;"><span>            bar <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>bar_array[i]
</span></span><span style="display:flex;"><span>            long_legs<span style="color:#f92672">.</span>append(bar[self<span style="color:#f92672">.</span>long_leg])
</span></span><span style="display:flex;"><span>            short_legs<span style="color:#f92672">.</span>append(bar[self<span style="color:#f92672">.</span>short_leg])
</span></span><span style="display:flex;"><span>        long_legs <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(long_legs)
</span></span><span style="display:flex;"><span>        short_legs <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(short_legs)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        result <span style="color:#f92672">=</span> bayesian_gam_with_splines(long_legs,short_legs,df<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>        y_values <span style="color:#f92672">=</span> result[<span style="color:#e6db74">&#39;y&#39;</span>]
</span></span><span style="display:flex;"><span>        beta_values <span style="color:#f92672">=</span> result[<span style="color:#e6db74">&#39;beta&#39;</span>]
</span></span><span style="display:flex;"><span>        mu_values <span style="color:#f92672">=</span> result[<span style="color:#e6db74">&#39;mu&#39;</span>]
</span></span><span style="display:flex;"><span>        epsilon_values <span style="color:#f92672">=</span> result[<span style="color:#e6db74">&#39;epsilon&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        y_pred_mean <span style="color:#f92672">=</span> y_values[<span style="color:#e6db74">&#39;mean&#39;</span>]
</span></span><span style="display:flex;"><span>        y_pred_upper <span style="color:#f92672">=</span> y_values[<span style="color:#e6db74">&#39;upper&#39;</span>]
</span></span><span style="display:flex;"><span>        y_pred_lower <span style="color:#f92672">=</span> y_values[<span style="color:#e6db74">&#39;lower&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        beta_posterior <span style="color:#f92672">=</span> beta_values[<span style="color:#e6db74">&#39;mean&#39;</span>]
</span></span><span style="display:flex;"><span>        beta_upper <span style="color:#f92672">=</span> beta_values[<span style="color:#e6db74">&#39;upper&#39;</span>]
</span></span><span style="display:flex;"><span>        beta_lower <span style="color:#f92672">=</span> beta_values[<span style="color:#e6db74">&#39;lower&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        mu_posterior <span style="color:#f92672">=</span> mu_values[<span style="color:#e6db74">&#39;mean&#39;</span>]
</span></span><span style="display:flex;"><span>        mu_upper <span style="color:#f92672">=</span> mu_values[<span style="color:#e6db74">&#39;upper&#39;</span>]
</span></span><span style="display:flex;"><span>        mu_lower <span style="color:#f92672">=</span> mu_values[<span style="color:#e6db74">&#39;lower&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        epsilon_mean <span style="color:#f92672">=</span> epsilon_values[<span style="color:#e6db74">&#39;mean&#39;</span>]
</span></span><span style="display:flex;"><span>        epsilon_upper <span style="color:#f92672">=</span> epsilon_values[<span style="color:#e6db74">&#39;upper&#39;</span>]
</span></span><span style="display:flex;"><span>        epsilon_lower <span style="color:#f92672">=</span> epsilon_values[<span style="color:#e6db74">&#39;lower&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> beta_posterior[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], mu_posterior[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">processBar</span>(self, bars: dict):
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">from</span> math <span style="color:#f92672">import</span> log
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># append log data</span>
</span></span><span style="display:flex;"><span>        bar <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>short_leg: (bars[self<span style="color:#f92672">.</span>short_leg]<span style="color:#f92672">.</span>close),
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>long_leg: (bars[self<span style="color:#f92672">.</span>long_leg]<span style="color:#f92672">.</span>close),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>bar_array<span style="color:#f92672">.</span>append(bar)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(self<span style="color:#f92672">.</span>bar_array) <span style="color:#f92672">&lt;</span> self<span style="color:#f92672">.</span>array_len:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        p_value <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>coin_test()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        spread, _ <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>spread(bars)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>spread_array<span style="color:#f92672">.</span>append(spread)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(self<span style="color:#f92672">.</span>spread_array) <span style="color:#f92672">&lt;</span> self<span style="color:#f92672">.</span>array_len<span style="color:#f92672">/</span><span style="color:#ae81ff">5</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>is_open:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>holding_count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            spread, _ <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>spread(bars)
</span></span><span style="display:flex;"><span>            diff <span style="color:#f92672">=</span> (spread <span style="color:#f92672">-</span> self<span style="color:#f92672">.</span>mean) <span style="color:#f92672">/</span> self<span style="color:#f92672">.</span>dev
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>holding_count <span style="color:#f92672">&gt;=</span> self<span style="color:#f92672">.</span>maximum_holding_period:
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">&#39;holding too long force quit&#39;</span>)
</span></span><span style="display:flex;"><span>                self<span style="color:#f92672">.</span>close_position_new(bars, ignore_diff<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>                self<span style="color:#f92672">.</span>holding_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>mean:
</span></span><span style="display:flex;"><span>            diff <span style="color:#f92672">=</span> (spread <span style="color:#f92672">-</span> self<span style="color:#f92672">.</span>mean) <span style="color:#f92672">/</span> self<span style="color:#f92672">.</span>dev
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># print(f&#34;current diff {diff}&#34;)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        adf_center <span style="color:#f92672">=</span> adfuller(self<span style="color:#f92672">.</span>spread_array, regression<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;c&#39;</span>)[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>        adf_trend <span style="color:#f92672">=</span> adfuller(self<span style="color:#f92672">.</span>spread_array, regression<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;ct&#39;</span>)[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> adf_center <span style="color:#f92672">&lt;</span> self<span style="color:#f92672">.</span>pValue:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>is_stationary <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>is_stationary <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if adf_trend &lt; 0.05:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#     print(f&#39;adf ct test result {adf_trend}, has a trend, not enter trading&#39;)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#     return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if p_value &lt;= self.pValue:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>is_stationary:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>hedge(bars)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> self<span style="color:#f92672">.</span>is_open:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>close_position_new(bars)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hedge</span>(self, bars: dict):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> self<span style="color:#f92672">.</span>is_open:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># self.open_position(bars)</span>
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>open_position_new(bars)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>close_position_new(bars)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">open_position_new</span>(self, bars: dict):
</span></span><span style="display:flex;"><span>        spread, _ <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>spread(bars)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>mean, self<span style="color:#f92672">.</span>dev <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>get_diff(spread)
</span></span><span style="display:flex;"><span>        diff <span style="color:#f92672">=</span> (spread <span style="color:#f92672">-</span> self<span style="color:#f92672">.</span>mean) <span style="color:#f92672">/</span> self<span style="color:#f92672">.</span>dev
</span></span><span style="display:flex;"><span>        long_leg_price <span style="color:#f92672">=</span> (bars[self<span style="color:#f92672">.</span>long_leg]<span style="color:#f92672">.</span>close)
</span></span><span style="display:flex;"><span>        short_leg_price <span style="color:#f92672">=</span> (bars[self<span style="color:#f92672">.</span>short_leg]<span style="color:#f92672">.</span>close)
</span></span><span style="display:flex;"><span>        time <span style="color:#f92672">=</span> bars[self<span style="color:#f92672">.</span>short_leg]<span style="color:#f92672">.</span>time
</span></span><span style="display:flex;"><span>        short_leg_qty <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>grid_amount<span style="color:#f92672">/</span>(long_leg_price<span style="color:#f92672">*</span>abs(self<span style="color:#f92672">.</span>beta) <span style="color:#f92672">+</span> short_leg_price)
</span></span><span style="display:flex;"><span>        long_leg_qty <span style="color:#f92672">=</span> short_leg_qty<span style="color:#f92672">*</span>abs(self<span style="color:#f92672">.</span>beta)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> abs(diff) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">2</span>:
</span></span><span style="display:flex;"><span>            print(
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;open parameter beta: </span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>beta<span style="color:#e6db74">}</span><span style="color:#e6db74">, intercept: </span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>intercept<span style="color:#e6db74">}</span><span style="color:#e6db74">, spread mean:</span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>mean<span style="color:#e6db74">}</span><span style="color:#e6db74">, spread dev </span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>dev<span style="color:#e6db74">}</span><span style="color:#e6db74">, diff:</span><span style="color:#e6db74">{</span>diff<span style="color:#e6db74">}</span><span style="color:#e6db74"> , time:</span><span style="color:#e6db74">{</span>time<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>open_diff <span style="color:#f92672">=</span> diff
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>beta <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> diff <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    self<span style="color:#f92672">.</span>broker<span style="color:#f92672">.</span>short(
</span></span><span style="display:flex;"><span>                        price<span style="color:#f92672">=</span>long_leg_price,
</span></span><span style="display:flex;"><span>                        symbol<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>long_leg,
</span></span><span style="display:flex;"><span>                        vol<span style="color:#f92672">=</span>long_leg_qty,
</span></span><span style="display:flex;"><span>                        leverage<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>                        time<span style="color:#f92672">=</span>time)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    self<span style="color:#f92672">.</span>broker<span style="color:#f92672">.</span>short(
</span></span><span style="display:flex;"><span>                        price<span style="color:#f92672">=</span>short_leg_price,
</span></span><span style="display:flex;"><span>                        symbol<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>short_leg,
</span></span><span style="display:flex;"><span>                        vol<span style="color:#f92672">=</span>short_leg_qty,
</span></span><span style="display:flex;"><span>                        leverage<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>                        time<span style="color:#f92672">=</span>time)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    self<span style="color:#f92672">.</span>is_open <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                    self<span style="color:#f92672">.</span>broker<span style="color:#f92672">.</span>long(
</span></span><span style="display:flex;"><span>                        price<span style="color:#f92672">=</span>long_leg_price,
</span></span><span style="display:flex;"><span>                        symbol<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>long_leg,
</span></span><span style="display:flex;"><span>                        vol<span style="color:#f92672">=</span>long_leg_qty,
</span></span><span style="display:flex;"><span>                        leverage<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>                        time<span style="color:#f92672">=</span>time)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    self<span style="color:#f92672">.</span>broker<span style="color:#f92672">.</span>long(
</span></span><span style="display:flex;"><span>                        price<span style="color:#f92672">=</span>short_leg_price,
</span></span><span style="display:flex;"><span>                        symbol<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>short_leg,
</span></span><span style="display:flex;"><span>                        vol<span style="color:#f92672">=</span>short_leg_qty,
</span></span><span style="display:flex;"><span>                        leverage<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>                        time<span style="color:#f92672">=</span>time)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    self<span style="color:#f92672">.</span>is_open <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> diff <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>                    self<span style="color:#f92672">.</span>broker<span style="color:#f92672">.</span>long(
</span></span><span style="display:flex;"><span>                        price<span style="color:#f92672">=</span>long_leg_price,
</span></span><span style="display:flex;"><span>                        symbol<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>long_leg,
</span></span><span style="display:flex;"><span>                        vol<span style="color:#f92672">=</span>long_leg_qty,
</span></span><span style="display:flex;"><span>                        leverage<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>                        time<span style="color:#f92672">=</span>time)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    self<span style="color:#f92672">.</span>broker<span style="color:#f92672">.</span>short(
</span></span><span style="display:flex;"><span>                        price<span style="color:#f92672">=</span>short_leg_price,
</span></span><span style="display:flex;"><span>                        symbol<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>short_leg,
</span></span><span style="display:flex;"><span>                        vol<span style="color:#f92672">=</span>short_leg_qty,
</span></span><span style="display:flex;"><span>                        leverage<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>                        time<span style="color:#f92672">=</span>time)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    self<span style="color:#f92672">.</span>is_open <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                    self<span style="color:#f92672">.</span>broker<span style="color:#f92672">.</span>long(
</span></span><span style="display:flex;"><span>                        price<span style="color:#f92672">=</span>short_leg_price,
</span></span><span style="display:flex;"><span>                        symbol<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>short_leg,
</span></span><span style="display:flex;"><span>                        vol<span style="color:#f92672">=</span>short_leg_qty,
</span></span><span style="display:flex;"><span>                        leverage<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>                        time<span style="color:#f92672">=</span>time)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    self<span style="color:#f92672">.</span>broker<span style="color:#f92672">.</span>short(
</span></span><span style="display:flex;"><span>                        price<span style="color:#f92672">=</span>long_leg_price,
</span></span><span style="display:flex;"><span>                        symbol<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>long_leg,
</span></span><span style="display:flex;"><span>                        vol<span style="color:#f92672">=</span>long_leg_qty,
</span></span><span style="display:flex;"><span>                        leverage<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>                        time<span style="color:#f92672">=</span>time)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    self<span style="color:#f92672">.</span>is_open <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">close_position_new</span>(self, bars: dict, ignore_diff<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>):
</span></span><span style="display:flex;"><span>        spread, _ <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>spread(bars)
</span></span><span style="display:flex;"><span>        diff <span style="color:#f92672">=</span> (spread <span style="color:#f92672">-</span> self<span style="color:#f92672">.</span>mean) <span style="color:#f92672">/</span> self<span style="color:#f92672">.</span>dev
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># calculate position pnl</span>
</span></span><span style="display:flex;"><span>        long_leg_price <span style="color:#f92672">=</span> (bars[self<span style="color:#f92672">.</span>long_leg]<span style="color:#f92672">.</span>close)
</span></span><span style="display:flex;"><span>        short_leg_price <span style="color:#f92672">=</span> (bars[self<span style="color:#f92672">.</span>short_leg]<span style="color:#f92672">.</span>close)
</span></span><span style="display:flex;"><span>        time <span style="color:#f92672">=</span> bars[self<span style="color:#f92672">.</span>short_leg]<span style="color:#f92672">.</span>time
</span></span><span style="display:flex;"><span>        long_leg_pos: Position <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>broker<span style="color:#f92672">.</span>positions[self<span style="color:#f92672">.</span>long_leg]
</span></span><span style="display:flex;"><span>        short_leg_pos: Position <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>broker<span style="color:#f92672">.</span>positions[self<span style="color:#f92672">.</span>short_leg]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Close the position when the unrealize loss is too much !!!</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># profit_rate = self.broker.get_current_pos_profit_rate(bars)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if profit_rate &lt; -0.1:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#     print(&#39;position profit rate is too low, force quit&#39;)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#     ignore_diff = True</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (self<span style="color:#f92672">.</span>open_diff <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> diff <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">or</span> (self<span style="color:#f92672">.</span>open_diff <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> diff <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">or</span> ignore_diff:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if abs(diff) &lt; -2 or ignore_diff:</span>
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>holding_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>            print(
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;close parameter beta: </span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>beta<span style="color:#e6db74">}</span><span style="color:#e6db74">, intercept: </span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>intercept<span style="color:#e6db74">}</span><span style="color:#e6db74">, spread mean:</span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>mean<span style="color:#e6db74">}</span><span style="color:#e6db74">, spread dev </span><span style="color:#e6db74">{</span>self<span style="color:#f92672">.</span>dev<span style="color:#e6db74">}</span><span style="color:#e6db74">, diff:</span><span style="color:#e6db74">{</span>diff<span style="color:#e6db74">}</span><span style="color:#e6db74"> , time:</span><span style="color:#e6db74">{</span>time<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> short_leg_pos<span style="color:#f92672">.</span>direction <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;short&#39;</span>:
</span></span><span style="display:flex;"><span>                self<span style="color:#f92672">.</span>broker<span style="color:#f92672">.</span>cover_short(
</span></span><span style="display:flex;"><span>                    price<span style="color:#f92672">=</span>short_leg_price,
</span></span><span style="display:flex;"><span>                    symbol<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>short_leg,
</span></span><span style="display:flex;"><span>                    vol<span style="color:#f92672">=</span>short_leg_pos<span style="color:#f92672">.</span>volume,
</span></span><span style="display:flex;"><span>                    time<span style="color:#f92672">=</span>time)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                self<span style="color:#f92672">.</span>broker<span style="color:#f92672">.</span>cover_long(
</span></span><span style="display:flex;"><span>                    price<span style="color:#f92672">=</span>short_leg_price,
</span></span><span style="display:flex;"><span>                    symbol<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>short_leg,
</span></span><span style="display:flex;"><span>                    vol<span style="color:#f92672">=</span>short_leg_pos<span style="color:#f92672">.</span>volume,
</span></span><span style="display:flex;"><span>                    time<span style="color:#f92672">=</span>time)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> long_leg_pos<span style="color:#f92672">.</span>direction <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;short&#39;</span>:
</span></span><span style="display:flex;"><span>                self<span style="color:#f92672">.</span>broker<span style="color:#f92672">.</span>cover_short(
</span></span><span style="display:flex;"><span>                    price<span style="color:#f92672">=</span>long_leg_price,
</span></span><span style="display:flex;"><span>                    symbol<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>long_leg,
</span></span><span style="display:flex;"><span>                    vol<span style="color:#f92672">=</span>long_leg_pos<span style="color:#f92672">.</span>volume,
</span></span><span style="display:flex;"><span>                    time<span style="color:#f92672">=</span>time)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                self<span style="color:#f92672">.</span>broker<span style="color:#f92672">.</span>cover_long(
</span></span><span style="display:flex;"><span>                    price<span style="color:#f92672">=</span>long_leg_price,
</span></span><span style="display:flex;"><span>                    symbol<span style="color:#f92672">=</span>self<span style="color:#f92672">.</span>long_leg,
</span></span><span style="display:flex;"><span>                    vol<span style="color:#f92672">=</span>long_leg_pos<span style="color:#f92672">.</span>volume,
</span></span><span style="display:flex;"><span>                    time<span style="color:#f92672">=</span>time)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>is_open <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>beta, self<span style="color:#f92672">.</span>intercept <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>, <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">spread</span>(self, bars: dict):
</span></span><span style="display:flex;"><span>        long: BarData <span style="color:#f92672">=</span> bars[self<span style="color:#f92672">.</span>long_leg]
</span></span><span style="display:flex;"><span>        short: BarData <span style="color:#f92672">=</span> bars[self<span style="color:#f92672">.</span>short_leg]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        long_price <span style="color:#f92672">=</span> (long<span style="color:#f92672">.</span>close)
</span></span><span style="display:flex;"><span>        short_price <span style="color:#f92672">=</span> (short<span style="color:#f92672">.</span>close)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        spread <span style="color:#f92672">=</span> short_price <span style="color:#f92672">-</span> (self<span style="color:#f92672">.</span>beta <span style="color:#f92672">*</span> long_price <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>intercept)
</span></span><span style="display:flex;"><span>        diff <span style="color:#f92672">=</span> spread <span style="color:#f92672">/</span> (self<span style="color:#f92672">.</span>beta <span style="color:#f92672">*</span> long_price <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>intercept)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> spread, diff
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_diff</span>(self, spread):
</span></span><span style="display:flex;"><span>        mean <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>mean(self<span style="color:#f92672">.</span>spread_array)
</span></span><span style="display:flex;"><span>        dev <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>std(self<span style="color:#f92672">.</span>spread_array)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> mean, dev
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">coin_test</span>(self):
</span></span><span style="display:flex;"><span>        long_legs <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        short_legs <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>array_len):
</span></span><span style="display:flex;"><span>            bar <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>bar_array[i]
</span></span><span style="display:flex;"><span>            long_legs<span style="color:#f92672">.</span>append(bar[self<span style="color:#f92672">.</span>long_leg])
</span></span><span style="display:flex;"><span>            short_legs<span style="color:#f92672">.</span>append(bar[self<span style="color:#f92672">.</span>short_leg])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> self<span style="color:#f92672">.</span>beta:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>beta, self<span style="color:#f92672">.</span>intercept <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>get_beta_GPs()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        long_legs_modify <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(self<span style="color:#f92672">.</span>array_len):
</span></span><span style="display:flex;"><span>            new_long_leg <span style="color:#f92672">=</span> long_legs[i] <span style="color:#f92672">*</span> self<span style="color:#f92672">.</span>beta <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>intercept
</span></span><span style="display:flex;"><span>            long_legs_modify<span style="color:#f92672">.</span>append(new_long_leg)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        _, p_value, _ <span style="color:#f92672">=</span> coint(long_legs_modify, short_legs)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> p_value
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">generate_combinations</span>(symbols):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> list(combinations(symbols, <span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p_value <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.99</span>
</span></span><span style="display:flex;"><span>stop_loss <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.5</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>(selected_symbols):
</span></span><span style="display:flex;"><span>    cash <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>    transactionFeeRate <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;2023-01-01&#39;</span>
</span></span><span style="display:flex;"><span>    end <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;2024-10-31&#39;</span>
</span></span><span style="display:flex;"><span>    broker <span style="color:#f92672">=</span> Broker(cash, transactionFeeRate, selected_symbols)
</span></span><span style="display:flex;"><span>    setting <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;short_leg&#39;</span>: selected_symbols[<span style="color:#ae81ff">0</span>],
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;long_leg&#39;</span>: selected_symbols[<span style="color:#ae81ff">1</span>],
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;open_margin&#39;</span>: <span style="color:#ae81ff">0.05</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;close_margin&#39;</span>: <span style="color:#ae81ff">0.02</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;stop_loss&#39;</span>: stop_loss,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;pValue&#39;</span>: <span style="color:#ae81ff">0.05</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;grid_amount&#39;</span>: cash <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.2</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;array_len&#39;</span>: <span style="color:#ae81ff">300</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;maximum_holding_period&#39;</span>: <span style="color:#ae81ff">300</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    strategy <span style="color:#f92672">=</span> Cointegration(broker, setting)
</span></span><span style="display:flex;"><span>    log <span style="color:#f92672">=</span> Log(broker)
</span></span><span style="display:flex;"><span>    backtestor <span style="color:#f92672">=</span> BacktestorPairTrading(broker, strategy, log, start, end)
</span></span><span style="display:flex;"><span>    backtestor<span style="color:#f92672">.</span>load_data()
</span></span><span style="display:flex;"><span>    backtestor<span style="color:#f92672">.</span>run_backtest()
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> backtestor<span style="color:#f92672">.</span>performance()
</span></span><span style="display:flex;"><span>    msg_df <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>DataFrame(broker<span style="color:#f92672">.</span>msg)
</span></span><span style="display:flex;"><span>    profit, loss, winrate <span style="color:#f92672">=</span> analyze_arbitrage_cycles(msg_df)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># msg_df.to_csv(&#39;backTestResult/msg_df.csv&#39;)</span>
</span></span><span style="display:flex;"><span>    pnl_ratio <span style="color:#f92672">=</span> profit <span style="color:#f92672">/</span> loss
</span></span><span style="display:flex;"><span>    result[<span style="color:#e6db74">&#39;pnl_ratio&#39;</span>] <span style="color:#f92672">=</span> pnl_ratio
</span></span><span style="display:flex;"><span>    result[<span style="color:#e6db74">&#39;win_rate&#39;</span>] <span style="color:#f92672">=</span> winrate
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> result
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># msg_df = pd.DataFrame(broker.msg)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># msg_df.to_csv(&#39;backTestResult/msg_df.csv&#39;)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">from</span> backTestResult.cointegration_analysis <span style="color:#f92672">import</span> analyze_arbitrage_cycles
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    cash <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000000</span>
</span></span><span style="display:flex;"><span>    transactionFeeRate <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.00025</span>
</span></span><span style="display:flex;"><span>    start <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;2023-01-01&#39;</span>
</span></span><span style="display:flex;"><span>    end <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;2024-10-31&#39;</span>
</span></span><span style="display:flex;"><span>    long_leg <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;DOGE&#39;</span>
</span></span><span style="display:flex;"><span>    short_leg <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;XRP&#39;</span>
</span></span><span style="display:flex;"><span>    selected_symbols <span style="color:#f92672">=</span> [long_leg, short_leg]
</span></span><span style="display:flex;"><span>    broker <span style="color:#f92672">=</span> Broker(cash, transactionFeeRate, selected_symbols)
</span></span><span style="display:flex;"><span>    setting <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;short_leg&#39;</span>: short_leg,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;long_leg&#39;</span>: long_leg,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;open_margin&#39;</span>: <span style="color:#ae81ff">0.05</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;close_margin&#39;</span>: <span style="color:#ae81ff">0.04</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;stop_loss&#39;</span>: <span style="color:#ae81ff">0.4</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;pValue&#39;</span>: <span style="color:#ae81ff">0.05</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;grid_amount&#39;</span>: cash <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.2</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;array_len&#39;</span>: <span style="color:#ae81ff">200</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;maximum_holding_period&#39;</span>: <span style="color:#ae81ff">24</span><span style="color:#f92672">*</span> <span style="color:#ae81ff">30</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    strategy <span style="color:#f92672">=</span> Cointegration(broker, setting)
</span></span><span style="display:flex;"><span>    log <span style="color:#f92672">=</span> Log(broker)
</span></span><span style="display:flex;"><span>    backtestor <span style="color:#f92672">=</span> BacktestorPairTrading(broker, strategy, log, start, end)
</span></span><span style="display:flex;"><span>    backtestor<span style="color:#f92672">.</span>load_data()
</span></span><span style="display:flex;"><span>    backtestor<span style="color:#f92672">.</span>run_backtest()
</span></span><span style="display:flex;"><span>    result <span style="color:#f92672">=</span> backtestor<span style="color:#f92672">.</span>performance()
</span></span><span style="display:flex;"><span>    msg_df <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>DataFrame(broker<span style="color:#f92672">.</span>msg)
</span></span><span style="display:flex;"><span>    analyze_arbitrage_cycles(msg_df)
</span></span><span style="display:flex;"><span>    msg_df<span style="color:#f92672">.</span>to_csv(<span style="color:#e6db74">&#39;backTestResult/msg_df.csv&#39;</span>)
</span></span></code></pre></div><h1 id="bayesian-regression">Bayesian regression<a hidden class="anchor" aria-hidden="true" href="#bayesian-regression">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bayesian_rolling_window</span>(X_t, Y_t, window_size<span style="color:#f92672">=</span><span style="color:#ae81ff">30</span>):
</span></span><span style="display:flex;"><span>    T <span style="color:#f92672">=</span> len(X_t)
</span></span><span style="display:flex;"><span>    beta_t_est <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros(T)
</span></span><span style="display:flex;"><span>    mu_t_est <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros(T)
</span></span><span style="display:flex;"><span>    beta_var_est <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros(T)
</span></span><span style="display:flex;"><span>    mu_var_est <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros(T)
</span></span><span style="display:flex;"><span>    residual_var_est <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros(T)
</span></span><span style="display:flex;"><span>    Y_pred <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros(T)
</span></span><span style="display:flex;"><span>    Y_std_est <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros(T)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Prior parameters</span>
</span></span><span style="display:flex;"><span>    beta_mean_prior <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    beta_var_prior <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    mu_mean_prior <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    mu_var_prior <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    sigma_prior <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> t <span style="color:#f92672">in</span> range(window_size, T):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Get rolling window data</span>
</span></span><span style="display:flex;"><span>        X_window <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>float64(X_t[t <span style="color:#f92672">-</span> window_size:t])
</span></span><span style="display:flex;"><span>        Y_window <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>float64(Y_t[t <span style="color:#f92672">-</span> window_size:t])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Posterior parameters for beta</span>
</span></span><span style="display:flex;"><span>        XTX <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>sum(X_window <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>        XTY <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>sum(X_window <span style="color:#f92672">*</span> (Y_window <span style="color:#f92672">-</span> np<span style="color:#f92672">.</span>mean(Y_window)))
</span></span><span style="display:flex;"><span>        beta_var_post <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> beta_var_prior <span style="color:#f92672">+</span> XTX <span style="color:#f92672">/</span> sigma_prior)
</span></span><span style="display:flex;"><span>        beta_mean_post <span style="color:#f92672">=</span> beta_var_post <span style="color:#f92672">*</span> (beta_mean_prior <span style="color:#f92672">/</span> beta_var_prior <span style="color:#f92672">+</span> XTY <span style="color:#f92672">/</span> sigma_prior)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Posterior parameters for mu</span>
</span></span><span style="display:flex;"><span>        mu_var_post <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> mu_var_prior <span style="color:#f92672">+</span> window_size <span style="color:#f92672">/</span> sigma_prior)
</span></span><span style="display:flex;"><span>        mu_mean_post <span style="color:#f92672">=</span> mu_var_post <span style="color:#f92672">*</span> (mu_mean_prior <span style="color:#f92672">/</span> mu_var_prior <span style="color:#f92672">+</span> np<span style="color:#f92672">.</span>sum(Y_window <span style="color:#f92672">-</span> beta_mean_post <span style="color:#f92672">*</span> X_window) <span style="color:#f92672">/</span> sigma_prior)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Estimate residual variance</span>
</span></span><span style="display:flex;"><span>        residuals_window <span style="color:#f92672">=</span> Y_window <span style="color:#f92672">-</span> (beta_mean_post <span style="color:#f92672">*</span> X_window <span style="color:#f92672">+</span> mu_mean_post)
</span></span><span style="display:flex;"><span>        residual_var_est[t] <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>var(residuals_window)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Store estimates</span>
</span></span><span style="display:flex;"><span>        beta_t_est[t] <span style="color:#f92672">=</span> beta_mean_post
</span></span><span style="display:flex;"><span>        mu_t_est[t] <span style="color:#f92672">=</span> mu_mean_post
</span></span><span style="display:flex;"><span>        beta_var_est[t] <span style="color:#f92672">=</span> beta_var_post
</span></span><span style="display:flex;"><span>        mu_var_est[t] <span style="color:#f92672">=</span> mu_var_post
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Predict Y_t and its credible interval</span>
</span></span><span style="display:flex;"><span>        Y_pred[t] <span style="color:#f92672">=</span> beta_t_est[t] <span style="color:#f92672">*</span> X_t[t] <span style="color:#f92672">+</span> mu_t_est[t]
</span></span><span style="display:flex;"><span>        Y_var_est <span style="color:#f92672">=</span> (X_t[t] <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">*</span> (beta_var_est[t]) <span style="color:#f92672">+</span> (mu_var_est[t]) <span style="color:#f92672">+</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> sigma_prior)
</span></span><span style="display:flex;"><span>        Y_std_est[t] <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>sqrt(Y_var_est)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Prior parameters</span>
</span></span><span style="display:flex;"><span>        beta_mean_prior <span style="color:#f92672">=</span> beta_mean_post
</span></span><span style="display:flex;"><span>        beta_var_prior <span style="color:#f92672">=</span> beta_var_post
</span></span><span style="display:flex;"><span>        mu_mean_prior <span style="color:#f92672">=</span> mu_mean_post
</span></span><span style="display:flex;"><span>        mu_var_prior <span style="color:#f92672">=</span> mu_var_post
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    residuals <span style="color:#f92672">=</span> Y_t <span style="color:#f92672">-</span> Y_pred
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    data <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;y&#39;</span>: {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;mean&#39;</span>: Y_pred,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;upper&#39;</span>: Y_pred <span style="color:#f92672">+</span> <span style="color:#ae81ff">1.96</span> <span style="color:#f92672">*</span> Y_std_est,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;lower&#39;</span>: Y_pred <span style="color:#f92672">-</span> <span style="color:#ae81ff">1.96</span> <span style="color:#f92672">*</span> Y_std_est
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;beta&#39;</span>: {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;mean&#39;</span>: beta_t_est,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;upper&#39;</span>:  beta_t_est <span style="color:#f92672">+</span> <span style="color:#ae81ff">1.96</span> <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>sqrt(beta_var_est),
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;lower&#39;</span>: beta_t_est <span style="color:#f92672">-</span> <span style="color:#ae81ff">1.96</span> <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>sqrt(beta_var_est)
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;mu&#39;</span>: {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;mean&#39;</span>: mu_t_est,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;upper&#39;</span>: mu_t_est <span style="color:#f92672">+</span> <span style="color:#ae81ff">1.96</span> <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>sqrt(mu_var_est),
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;lower&#39;</span>: mu_t_est <span style="color:#f92672">-</span> <span style="color:#ae81ff">1.96</span> <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>sqrt(mu_var_est)
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;epsilon&#39;</span>: {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;mean&#39;</span>: residuals,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;upper&#39;</span>: residuals <span style="color:#f92672">+</span> <span style="color:#ae81ff">1.96</span> <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>sqrt(residual_var_est),
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;lower&#39;</span>: residuals <span style="color:#f92672">-</span> <span style="color:#ae81ff">1.96</span> <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>sqrt(residual_var_est)
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> data
</span></span></code></pre></div><h1 id="bayesian-gam">Bayesian GAM<a hidden class="anchor" aria-hidden="true" href="#bayesian-gam">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bayesian_gam_with_splines</span>(X_t, Y_t, df<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>):
</span></span><span style="display:flex;"><span>    T <span style="color:#f92672">=</span> len(X_t)
</span></span><span style="display:flex;"><span>    time <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, T)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Design matrices for splines</span>
</span></span><span style="display:flex;"><span>    design_matrix <span style="color:#f92672">=</span> patsy<span style="color:#f92672">.</span>dmatrix(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;bs(time, df=</span><span style="color:#e6db74">{</span>df<span style="color:#e6db74">}</span><span style="color:#e6db74">, degree=3)&#34;</span>, {<span style="color:#e6db74">&#34;time&#34;</span>: time}, return_type<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;dataframe&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Joint Bayesian Ridge Regression for beta_t and mu_t</span>
</span></span><span style="display:flex;"><span>    X_joint <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>hstack([np<span style="color:#f92672">.</span>multiply(design_matrix<span style="color:#f92672">.</span>values, X_t[:, <span style="color:#66d9ef">None</span>]), design_matrix<span style="color:#f92672">.</span>values])
</span></span><span style="display:flex;"><span>    model_joint <span style="color:#f92672">=</span> BayesianRidge()
</span></span><span style="display:flex;"><span>    model_joint<span style="color:#f92672">.</span>fit(X_joint, Y_t)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Predict values with uncertainties</span>
</span></span><span style="display:flex;"><span>    Y_pred, Y_std <span style="color:#f92672">=</span> model_joint<span style="color:#f92672">.</span>predict(X_joint, return_std<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Separate beta_t and mu_t</span>
</span></span><span style="display:flex;"><span>    beta_t_est <span style="color:#f92672">=</span> design_matrix<span style="color:#f92672">.</span>values <span style="color:#f92672">@</span> model_joint<span style="color:#f92672">.</span>coef_[:design_matrix<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>]]
</span></span><span style="display:flex;"><span>    mu_t_est <span style="color:#f92672">=</span> design_matrix<span style="color:#f92672">.</span>values <span style="color:#f92672">@</span> model_joint<span style="color:#f92672">.</span>coef_[design_matrix<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>]:]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Compute standard deviations for beta and mu</span>
</span></span><span style="display:flex;"><span>    coef_cov <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linalg<span style="color:#f92672">.</span>inv(model_joint<span style="color:#f92672">.</span>alpha_ <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>eye(X_joint<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">+</span> model_joint<span style="color:#f92672">.</span>lambda_ <span style="color:#f92672">*</span> X_joint<span style="color:#f92672">.</span>T <span style="color:#f92672">@</span> X_joint)
</span></span><span style="display:flex;"><span>    beta_std_est <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>sqrt(np<span style="color:#f92672">.</span>sum((design_matrix<span style="color:#f92672">.</span>values <span style="color:#f92672">@</span> coef_cov[:design_matrix<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>], :design_matrix<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>]]) <span style="color:#f92672">*</span> design_matrix<span style="color:#f92672">.</span>values, axis<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>    mu_std_est <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>sqrt(np<span style="color:#f92672">.</span>sum((design_matrix<span style="color:#f92672">.</span>values <span style="color:#f92672">@</span> coef_cov[design_matrix<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>]:, design_matrix<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>]:]) <span style="color:#f92672">*</span> design_matrix<span style="color:#f92672">.</span>values, axis<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Posterior variance of noise</span>
</span></span><span style="display:flex;"><span>    residual_var_est <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">/</span> model_joint<span style="color:#f92672">.</span>alpha_  <span style="color:#75715e"># Posterior noise variance</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    residuals <span style="color:#f92672">=</span> Y_t <span style="color:#f92672">-</span> Y_pred
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    data <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;y&#39;</span>: {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;mean&#39;</span>: Y_pred,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;upper&#39;</span>: Y_pred <span style="color:#f92672">+</span> <span style="color:#ae81ff">1.96</span> <span style="color:#f92672">*</span> Y_std,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;lower&#39;</span>: Y_pred <span style="color:#f92672">-</span> <span style="color:#ae81ff">1.96</span> <span style="color:#f92672">*</span> Y_std
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;beta&#39;</span>: {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;mean&#39;</span>: beta_t_est,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;upper&#39;</span>: beta_t_est <span style="color:#f92672">+</span> <span style="color:#ae81ff">1.96</span> <span style="color:#f92672">*</span> beta_std_est,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;lower&#39;</span>: beta_t_est <span style="color:#f92672">-</span> <span style="color:#ae81ff">1.96</span> <span style="color:#f92672">*</span> beta_std_est
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;mu&#39;</span>: {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;mean&#39;</span>: mu_t_est,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;upper&#39;</span>: mu_t_est <span style="color:#f92672">+</span> <span style="color:#ae81ff">1.96</span> <span style="color:#f92672">*</span> mu_std_est,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;lower&#39;</span>: mu_t_est <span style="color:#f92672">-</span> <span style="color:#ae81ff">1.96</span> <span style="color:#f92672">*</span> mu_std_est
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;epsilon&#39;</span>: {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;mean&#39;</span>: residuals,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;upper&#39;</span>: residuals <span style="color:#f92672">+</span> <span style="color:#ae81ff">1.96</span> <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>sqrt(residual_var_est),
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;lower&#39;</span>: residuals <span style="color:#f92672">-</span> <span style="color:#ae81ff">1.96</span> <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>sqrt(residual_var_est)
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> data
</span></span></code></pre></div><h1 id="gaussian-process">Gaussian Process<a hidden class="anchor" aria-hidden="true" href="#gaussian-process">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TimeVaryingGP</span>(ExactGP):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, train_x, train_y, likelihood):
</span></span><span style="display:flex;"><span>        super(TimeVaryingGP, self)<span style="color:#f92672">.</span>__init__(train_x, train_y, likelihood)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Separate kernels for each component</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>beta_kernel <span style="color:#f92672">=</span> ScaleKernel(RBFKernel())
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># self.beta_kernel.base_kernel.register_prior(</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#     &#39;lengthscale_prior&#39;,</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#     gpytorch.priors.GammaPrior(10.0, 20.0),</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#     &#39;lengthscale&#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># )</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>mu_kernel <span style="color:#f92672">=</span> ScaleKernel(RBFKernel())
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>eps_kernel <span style="color:#f92672">=</span> ScaleKernel(RBFKernel())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>mean <span style="color:#f92672">=</span> ZeroMean()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">forward</span>(self, x):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Extract time and covariates</span>
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">=</span> x[:, <span style="color:#ae81ff">0</span>]  <span style="color:#75715e"># time index</span>
</span></span><span style="display:flex;"><span>        X <span style="color:#f92672">=</span> x[:, <span style="color:#ae81ff">1</span>]  <span style="color:#75715e"># covariate</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Compute kernel matrices</span>
</span></span><span style="display:flex;"><span>        K_beta <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>beta_kernel(t)
</span></span><span style="display:flex;"><span>        K_mu <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>mu_kernel(t)
</span></span><span style="display:flex;"><span>        K_eps <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>eps_kernel(t)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Compute covariance matrix</span>
</span></span><span style="display:flex;"><span>        covar <span style="color:#f92672">=</span> X<span style="color:#f92672">.</span>unsqueeze(<span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> K_beta <span style="color:#f92672">*</span> X<span style="color:#f92672">.</span>unsqueeze(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> K_mu <span style="color:#f92672">+</span> K_eps
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        mean <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>mean(x)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> MultivariateNormal(mean, covar)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">train_model</span>(X, y, n_iter<span style="color:#f92672">=</span><span style="color:#ae81ff">100</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> isinstance(X, torch<span style="color:#f92672">.</span>Tensor):
</span></span><span style="display:flex;"><span>        X <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>from_numpy(X)<span style="color:#f92672">.</span>clone()<span style="color:#f92672">.</span>detach()<span style="color:#f92672">.</span>float()
</span></span><span style="display:flex;"><span>        y <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>from_numpy(y)<span style="color:#f92672">.</span>clone()<span style="color:#f92672">.</span>detach()<span style="color:#f92672">.</span>float()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        X <span style="color:#f92672">=</span> X<span style="color:#f92672">.</span>clone()<span style="color:#f92672">.</span>detach()<span style="color:#f92672">.</span>float()
</span></span><span style="display:flex;"><span>        y <span style="color:#f92672">=</span> y<span style="color:#f92672">.</span>clone()<span style="color:#f92672">.</span>detach()<span style="color:#f92672">.</span>float()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Initialize model</span>
</span></span><span style="display:flex;"><span>    likelihood <span style="color:#f92672">=</span> gpytorch<span style="color:#f92672">.</span>likelihoods<span style="color:#f92672">.</span>GaussianLikelihood()
</span></span><span style="display:flex;"><span>    model <span style="color:#f92672">=</span> TimeVaryingGP(X, y, likelihood)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Use the adam optimizer</span>
</span></span><span style="display:flex;"><span>    optimizer <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>optim<span style="color:#f92672">.</span>Adam([
</span></span><span style="display:flex;"><span>        {<span style="color:#e6db74">&#39;params&#39;</span>: model<span style="color:#f92672">.</span>parameters()},
</span></span><span style="display:flex;"><span>    ], lr<span style="color:#f92672">=</span><span style="color:#ae81ff">0.1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># &#34;Loss&#34; for GPs - the marginal log likelihood</span>
</span></span><span style="display:flex;"><span>    mll <span style="color:#f92672">=</span> gpytorch<span style="color:#f92672">.</span>mlls<span style="color:#f92672">.</span>ExactMarginalLogLikelihood(likelihood, model)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Training loop</span>
</span></span><span style="display:flex;"><span>    model<span style="color:#f92672">.</span>train()
</span></span><span style="display:flex;"><span>    likelihood<span style="color:#f92672">.</span>train()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n_iter):
</span></span><span style="display:flex;"><span>        optimizer<span style="color:#f92672">.</span>zero_grad()
</span></span><span style="display:flex;"><span>        output <span style="color:#f92672">=</span> model(X)
</span></span><span style="display:flex;"><span>        loss <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>mll(output, y)
</span></span><span style="display:flex;"><span>        loss<span style="color:#f92672">.</span>backward()
</span></span><span style="display:flex;"><span>        optimizer<span style="color:#f92672">.</span>step()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> model, likelihood
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">predict_latent</span>(model, X_train, y_train, X_new):
</span></span><span style="display:flex;"><span>    model<span style="color:#f92672">.</span>eval()
</span></span><span style="display:flex;"><span>    jitter <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e-6</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">with</span> torch<span style="color:#f92672">.</span>no_grad():
</span></span><span style="display:flex;"><span>        t_train <span style="color:#f92672">=</span> X_train[:, <span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>        x_train <span style="color:#f92672">=</span> X_train[:, <span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>        t_new <span style="color:#f92672">=</span> X_new[:, <span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>        x_new <span style="color:#f92672">=</span> X_new[:, <span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        K_beta <span style="color:#f92672">=</span> model<span style="color:#f92672">.</span>beta_kernel(t_new, t_train)<span style="color:#f92672">.</span>evaluate()
</span></span><span style="display:flex;"><span>        K_mu <span style="color:#f92672">=</span> model<span style="color:#f92672">.</span>mu_kernel(t_new, t_train)<span style="color:#f92672">.</span>evaluate()
</span></span><span style="display:flex;"><span>        K_eps <span style="color:#f92672">=</span> model<span style="color:#f92672">.</span>eps_kernel(t_new, t_train)<span style="color:#f92672">.</span>evaluate()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        K_total <span style="color:#f92672">=</span> x_train <span style="color:#f92672">*</span> model<span style="color:#f92672">.</span>beta_kernel(t_train)<span style="color:#f92672">.</span>evaluate() <span style="color:#f92672">*</span> x_train<span style="color:#f92672">.</span>unsqueeze(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> \
</span></span><span style="display:flex;"><span>                  model<span style="color:#f92672">.</span>mu_kernel(t_train)<span style="color:#f92672">.</span>evaluate() <span style="color:#f92672">+</span> \
</span></span><span style="display:flex;"><span>                  model<span style="color:#f92672">.</span>eps_kernel(t_train)<span style="color:#f92672">.</span>evaluate() <span style="color:#f92672">+</span> \
</span></span><span style="display:flex;"><span>                  model<span style="color:#f92672">.</span>likelihood<span style="color:#f92672">.</span>noise <span style="color:#f92672">*</span> torch<span style="color:#f92672">.</span>eye(len(t_train)) <span style="color:#f92672">+</span> \
</span></span><span style="display:flex;"><span>                  jitter <span style="color:#f92672">*</span> torch<span style="color:#f92672">.</span>eye(len(t_train))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        K_new_beta <span style="color:#f92672">=</span> model<span style="color:#f92672">.</span>beta_kernel(t_new)<span style="color:#f92672">.</span>evaluate() <span style="color:#f92672">+</span> jitter <span style="color:#f92672">*</span> torch<span style="color:#f92672">.</span>eye(len(t_new))
</span></span><span style="display:flex;"><span>        K_new_mu <span style="color:#f92672">=</span> model<span style="color:#f92672">.</span>mu_kernel(t_new)<span style="color:#f92672">.</span>evaluate() <span style="color:#f92672">+</span> jitter <span style="color:#f92672">*</span> torch<span style="color:#f92672">.</span>eye(len(t_new))
</span></span><span style="display:flex;"><span>        K_new_eps <span style="color:#f92672">=</span> model<span style="color:#f92672">.</span>eps_kernel(t_new)<span style="color:#f92672">.</span>evaluate() <span style="color:#f92672">+</span> jitter <span style="color:#f92672">*</span> torch<span style="color:#f92672">.</span>eye(len(t_new))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Compute posterior mean using Cholesky</span>
</span></span><span style="display:flex;"><span>        L <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>linalg<span style="color:#f92672">.</span>cholesky(K_total)
</span></span><span style="display:flex;"><span>        alpha <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>linalg<span style="color:#f92672">.</span>solve_triangular(L, y_train<span style="color:#f92672">.</span>unsqueeze(<span style="color:#ae81ff">1</span>), upper<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>        alpha <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>linalg<span style="color:#f92672">.</span>solve_triangular(L<span style="color:#f92672">.</span>T, alpha, upper<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        K_stacked <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>stack([
</span></span><span style="display:flex;"><span>            x_new<span style="color:#f92672">.</span>unsqueeze(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> K_beta,
</span></span><span style="display:flex;"><span>            K_mu,
</span></span><span style="display:flex;"><span>            K_eps
</span></span><span style="display:flex;"><span>        ])
</span></span><span style="display:flex;"><span>        posterior_mean <span style="color:#f92672">=</span> K_stacked <span style="color:#f92672">@</span> alpha
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Compute posterior variance using Cholesky</span>
</span></span><span style="display:flex;"><span>        v_beta <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>linalg<span style="color:#f92672">.</span>solve_triangular(L, (x_train <span style="color:#f92672">*</span> K_beta<span style="color:#f92672">.</span>T)<span style="color:#f92672">.</span>T, upper<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>        v_mu <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>linalg<span style="color:#f92672">.</span>solve_triangular(L, K_mu<span style="color:#f92672">.</span>T, upper<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>        v_eps <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>linalg<span style="color:#f92672">.</span>solve_triangular(L, K_eps<span style="color:#f92672">.</span>T, upper<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        post_var_beta <span style="color:#f92672">=</span> K_new_beta <span style="color:#f92672">-</span> v_beta<span style="color:#f92672">.</span>T <span style="color:#f92672">@</span> v_beta
</span></span><span style="display:flex;"><span>        post_var_mu <span style="color:#f92672">=</span> K_new_mu <span style="color:#f92672">-</span> v_mu<span style="color:#f92672">.</span>T <span style="color:#f92672">@</span> v_mu
</span></span><span style="display:flex;"><span>        post_var_eps <span style="color:#f92672">=</span> K_new_eps <span style="color:#f92672">-</span> v_eps<span style="color:#f92672">.</span>T <span style="color:#f92672">@</span> v_eps
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;mean&#39;</span>: {
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;beta&#39;</span>: posterior_mean[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>squeeze(),
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;mu&#39;</span>: posterior_mean[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>squeeze(),
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;epsilon&#39;</span>: posterior_mean[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">.</span>squeeze()
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;variance&#39;</span>: {
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;beta&#39;</span>: post_var_beta<span style="color:#f92672">.</span>diag(),
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;mu&#39;</span>: post_var_mu<span style="color:#f92672">.</span>diag(),
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;epsilon&#39;</span>: post_var_eps<span style="color:#f92672">.</span>diag()
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">predict</span>(model, likelihood, X_new, X_train<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>, y_train<span style="color:#f92672">=</span><span style="color:#66d9ef">None</span>):
</span></span><span style="display:flex;"><span>    model<span style="color:#f92672">.</span>eval()
</span></span><span style="display:flex;"><span>    likelihood<span style="color:#f92672">.</span>eval()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> X_train <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        X_train <span style="color:#f92672">=</span> model<span style="color:#f92672">.</span>train_inputs[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> y_train <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        y_train <span style="color:#f92672">=</span> model<span style="color:#f92672">.</span>train_targets
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">with</span> torch<span style="color:#f92672">.</span>no_grad(), gpytorch<span style="color:#f92672">.</span>settings<span style="color:#f92672">.</span>fast_pred_var():
</span></span><span style="display:flex;"><span>        observed_pred <span style="color:#f92672">=</span> likelihood(model(X_new))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    latent_values <span style="color:#f92672">=</span> predict_latent(model, X_train, y_train, X_new)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> observed_pred<span style="color:#f92672">.</span>mean, observed_pred<span style="color:#f92672">.</span>variance, latent_values
</span></span></code></pre></div><h1 id="bsts">BSTS<a hidden class="anchor" aria-hidden="true" href="#bsts">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">bsts_fit</span>(x,y):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">with</span> pm<span style="color:#f92672">.</span>Model() <span style="color:#66d9ef">as</span> model:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Priors for variances</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># sigma = pm.HalfCauchy(&#39;sigma&#39;, beta=1)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Random walk for log volatility</span>
</span></span><span style="display:flex;"><span>        log_sigma <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>GaussianRandomWalk(<span style="color:#e6db74">&#39;log_sigma&#39;</span>,
</span></span><span style="display:flex;"><span>                                          sigma<span style="color:#f92672">=</span><span style="color:#ae81ff">0.1</span>,
</span></span><span style="display:flex;"><span>                                          shape<span style="color:#f92672">=</span>len(y),
</span></span><span style="display:flex;"><span>                                          init_dist<span style="color:#f92672">=</span>pm<span style="color:#f92672">.</span>Normal<span style="color:#f92672">.</span>dist(mu<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>, sigma<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>        sigma <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>Deterministic(<span style="color:#e6db74">&#39;sigma&#39;</span>, pm<span style="color:#f92672">.</span>math<span style="color:#f92672">.</span>exp(log_sigma))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        sigma_beta <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>HalfCauchy(<span style="color:#e6db74">&#39;sigma_beta&#39;</span>, beta<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        sigma_mu <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>HalfCauchy(<span style="color:#e6db74">&#39;sigma_mu&#39;</span>, beta<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Gaussian Random Walks for beta and mu</span>
</span></span><span style="display:flex;"><span>        beta <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>GaussianRandomWalk(<span style="color:#e6db74">&#39;beta&#39;</span>, sigma<span style="color:#f92672">=</span>sigma_beta, init_dist<span style="color:#f92672">=</span>pm<span style="color:#f92672">.</span>Normal<span style="color:#f92672">.</span>dist(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">10</span>), shape<span style="color:#f92672">=</span>len(y))
</span></span><span style="display:flex;"><span>        mu <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>GaussianRandomWalk(<span style="color:#e6db74">&#39;mu&#39;</span>, sigma<span style="color:#f92672">=</span>sigma_mu, init_dist<span style="color:#f92672">=</span>pm<span style="color:#f92672">.</span>Normal<span style="color:#f92672">.</span>dist(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">10</span>), shape<span style="color:#f92672">=</span>len(y))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Observation model</span>
</span></span><span style="display:flex;"><span>        Y_obs <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>Normal(<span style="color:#e6db74">&#39;Y_obs&#39;</span>, mu<span style="color:#f92672">=</span>beta <span style="color:#f92672">*</span> x <span style="color:#f92672">+</span> mu, sigma<span style="color:#f92672">=</span>sigma, observed<span style="color:#f92672">=</span>y)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># ---- 3. MCMC Sampling ----</span>
</span></span><span style="display:flex;"><span>        trace <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>sample(<span style="color:#ae81ff">1000</span>, tune<span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span>, chains<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, target_accept<span style="color:#f92672">=</span><span style="color:#ae81ff">0.9</span>)
</span></span><span style="display:flex;"><span>        ppc <span style="color:#f92672">=</span> pm<span style="color:#f92672">.</span>sample_posterior_predictive(trace, var_names<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#34;Y_obs&#34;</span>], random_seed<span style="color:#f92672">=</span><span style="color:#ae81ff">42</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Extract posterior mean and 95% credible intervals</span>
</span></span><span style="display:flex;"><span>        beta_posterior <span style="color:#f92672">=</span> trace<span style="color:#f92672">.</span>posterior[<span style="color:#e6db74">&#39;beta&#39;</span>]<span style="color:#f92672">.</span>mean(dim<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#34;chain&#34;</span>, <span style="color:#e6db74">&#34;draw&#34;</span>))
</span></span><span style="display:flex;"><span>        beta_lower <span style="color:#f92672">=</span> trace<span style="color:#f92672">.</span>posterior[<span style="color:#e6db74">&#39;beta&#39;</span>]<span style="color:#f92672">.</span>quantile(<span style="color:#ae81ff">0.025</span>, dim<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#34;chain&#34;</span>, <span style="color:#e6db74">&#34;draw&#34;</span>))
</span></span><span style="display:flex;"><span>        beta_upper <span style="color:#f92672">=</span> trace<span style="color:#f92672">.</span>posterior[<span style="color:#e6db74">&#39;beta&#39;</span>]<span style="color:#f92672">.</span>quantile(<span style="color:#ae81ff">0.975</span>, dim<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#34;chain&#34;</span>, <span style="color:#e6db74">&#34;draw&#34;</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        mu_posterior <span style="color:#f92672">=</span> trace<span style="color:#f92672">.</span>posterior[<span style="color:#e6db74">&#39;mu&#39;</span>]<span style="color:#f92672">.</span>mean(dim<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#34;chain&#34;</span>, <span style="color:#e6db74">&#34;draw&#34;</span>))
</span></span><span style="display:flex;"><span>        mu_lower <span style="color:#f92672">=</span> trace<span style="color:#f92672">.</span>posterior[<span style="color:#e6db74">&#39;mu&#39;</span>]<span style="color:#f92672">.</span>quantile(<span style="color:#ae81ff">0.025</span>, dim<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#34;chain&#34;</span>, <span style="color:#e6db74">&#34;draw&#34;</span>))
</span></span><span style="display:flex;"><span>        mu_upper <span style="color:#f92672">=</span> trace<span style="color:#f92672">.</span>posterior[<span style="color:#e6db74">&#39;mu&#39;</span>]<span style="color:#f92672">.</span>quantile(<span style="color:#ae81ff">0.975</span>, dim<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#34;chain&#34;</span>, <span style="color:#e6db74">&#34;draw&#34;</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Extract posterior predictive samples</span>
</span></span><span style="display:flex;"><span>        y_pred_samples <span style="color:#f92672">=</span> ppc<span style="color:#f92672">.</span>posterior_predictive[<span style="color:#e6db74">&#39;Y_obs&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Calculate mean and 95% prediction interval</span>
</span></span><span style="display:flex;"><span>        y_pred_mean <span style="color:#f92672">=</span> y_pred_samples<span style="color:#f92672">.</span>mean(dim<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#39;chain&#39;</span>, <span style="color:#e6db74">&#39;draw&#39;</span>))<span style="color:#f92672">.</span>values
</span></span><span style="display:flex;"><span>        y_pred_lower <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>percentile(y_pred_samples<span style="color:#f92672">.</span>values, <span style="color:#ae81ff">2.5</span>, axis<span style="color:#f92672">=</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>))  <span style="color:#75715e"># 2.5% quantile</span>
</span></span><span style="display:flex;"><span>        y_pred_upper <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>percentile(y_pred_samples<span style="color:#f92672">.</span>values, <span style="color:#ae81ff">97.5</span>, axis<span style="color:#f92672">=</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>))  <span style="color:#75715e"># 97.5% quantile</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        epsilon_samples <span style="color:#f92672">=</span> y <span style="color:#f92672">-</span> y_pred_samples<span style="color:#f92672">.</span>values  <span style="color:#75715e"># Shape: (chains, draws, time)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># ---- 3. Calculate Mean and Intervals ----</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Mean residuals</span>
</span></span><span style="display:flex;"><span>        epsilon_mean <span style="color:#f92672">=</span> epsilon_samples<span style="color:#f92672">.</span>mean(axis<span style="color:#f92672">=</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>))  <span style="color:#75715e"># Average over chains and draws</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 95% prediction intervals</span>
</span></span><span style="display:flex;"><span>        epsilon_lower <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>percentile(epsilon_samples, <span style="color:#ae81ff">2.5</span>, axis<span style="color:#f92672">=</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>        epsilon_upper <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>percentile(epsilon_samples, <span style="color:#ae81ff">97.5</span>, axis<span style="color:#f92672">=</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        data <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;y&#39;</span>: {
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;mean&#39;</span>: y_pred_mean,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;upper&#39;</span>: y_pred_upper,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;lower&#39;</span>: y_pred_lower
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;beta&#39;</span>: {
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;mean&#39;</span>: beta_posterior,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;upper&#39;</span>: beta_upper,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;lower&#39;</span>: beta_lower
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;mu&#39;</span>: {
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;mean&#39;</span>: mu_posterior,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;upper&#39;</span>: mu_upper,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;lower&#39;</span>: mu_lower
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#39;epsilon&#39;</span>: {
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;mean&#39;</span>: epsilon_mean,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;upper&#39;</span>: epsilon_upper,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#39;lower&#39;</span>: epsilon_lower
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> data
</span></span></code></pre></div><h1 id="gaussian-process-clustering">Gaussian Process clustering<a hidden class="anchor" aria-hidden="true" href="#gaussian-process-clustering">#</a></h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> pandas <span style="color:#66d9ef">as</span> pd
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> sklearn.cluster <span style="color:#f92672">import</span> KMeans
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> gpytorch
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> torch
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SparseGPModel</span>(gpytorch<span style="color:#f92672">.</span>models<span style="color:#f92672">.</span>ApproximateGP):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, inducing_points):
</span></span><span style="display:flex;"><span>        variational_distribution <span style="color:#f92672">=</span> gpytorch<span style="color:#f92672">.</span>variational<span style="color:#f92672">.</span>CholeskyVariationalDistribution(inducing_points<span style="color:#f92672">.</span>size(<span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>        variational_strategy <span style="color:#f92672">=</span> gpytorch<span style="color:#f92672">.</span>variational<span style="color:#f92672">.</span>VariationalStrategy(
</span></span><span style="display:flex;"><span>            self, inducing_points, variational_distribution, learn_inducing_locations<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        super()<span style="color:#f92672">.</span>__init__(variational_strategy)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Define kernel: RBF kernel with constant mean</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>mean_module <span style="color:#f92672">=</span> gpytorch<span style="color:#f92672">.</span>means<span style="color:#f92672">.</span>ConstantMean()
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>covar_module <span style="color:#f92672">=</span> gpytorch<span style="color:#f92672">.</span>kernels<span style="color:#f92672">.</span>ScaleKernel(gpytorch<span style="color:#f92672">.</span>kernels<span style="color:#f92672">.</span>RBFKernel())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">forward</span>(self, x):
</span></span><span style="display:flex;"><span>        mean_x <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>mean_module(x)
</span></span><span style="display:flex;"><span>        covar_x <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>covar_module(x)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> gpytorch<span style="color:#f92672">.</span>distributions<span style="color:#f92672">.</span>MultivariateNormal(mean_x, covar_x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sparse_gpr_hyperparameter_clustering</span>(data, n_clusters<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>, num_inducing<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, verbose<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    symbols <span style="color:#f92672">=</span> data<span style="color:#f92672">.</span>iloc[:, <span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>values
</span></span><span style="display:flex;"><span>    time_points <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>tensor(np<span style="color:#f92672">.</span>arange(data<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>), dtype<span style="color:#f92672">=</span>torch<span style="color:#f92672">.</span>float32)  <span style="color:#75715e"># Time indices</span>
</span></span><span style="display:flex;"><span>    time_series <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>tensor(data<span style="color:#f92672">.</span>iloc[:, <span style="color:#ae81ff">1</span>:]<span style="color:#f92672">.</span>values, dtype<span style="color:#f92672">=</span>torch<span style="color:#f92672">.</span>float32)  <span style="color:#75715e"># Time series values</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Initialize list to store hyperparameters</span>
</span></span><span style="display:flex;"><span>    hyperparameters <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> verbose:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Starting Sparse Gaussian Process Regression for each stock...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> idx, ts <span style="color:#f92672">in</span> enumerate(time_series):
</span></span><span style="display:flex;"><span>        ts <span style="color:#f92672">=</span> ts<span style="color:#f92672">.</span>unsqueeze(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)  <span style="color:#75715e"># Add a dimension for compatibility (n_samples, 1)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        inducing_points <span style="color:#f92672">=</span> time_points[::len(time_points) <span style="color:#f92672">//</span> num_inducing][:num_inducing]<span style="color:#f92672">.</span>unsqueeze(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        model <span style="color:#f92672">=</span> SparseGPModel(inducing_points)
</span></span><span style="display:flex;"><span>        likelihood <span style="color:#f92672">=</span> gpytorch<span style="color:#f92672">.</span>likelihoods<span style="color:#f92672">.</span>GaussianLikelihood()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        model<span style="color:#f92672">.</span>train()
</span></span><span style="display:flex;"><span>        likelihood<span style="color:#f92672">.</span>train()
</span></span><span style="display:flex;"><span>        optimizer <span style="color:#f92672">=</span> torch<span style="color:#f92672">.</span>optim<span style="color:#f92672">.</span>Adam(model<span style="color:#f92672">.</span>parameters(), lr<span style="color:#f92672">=</span><span style="color:#ae81ff">0.1</span>)
</span></span><span style="display:flex;"><span>        mll <span style="color:#f92672">=</span> gpytorch<span style="color:#f92672">.</span>mlls<span style="color:#f92672">.</span>VariationalELBO(likelihood, model, num_data<span style="color:#f92672">=</span>len(time_points))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Training loop (simple with fixed iterations for now)</span>
</span></span><span style="display:flex;"><span>        training_iter <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>  <span style="color:#75715e"># You can adjust this</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(training_iter):
</span></span><span style="display:flex;"><span>            optimizer<span style="color:#f92672">.</span>zero_grad()
</span></span><span style="display:flex;"><span>            output <span style="color:#f92672">=</span> model(time_points<span style="color:#f92672">.</span>unsqueeze(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>            loss <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>mll(output, ts)<span style="color:#f92672">.</span>sum()
</span></span><span style="display:flex;"><span>            loss<span style="color:#f92672">.</span>backward()
</span></span><span style="display:flex;"><span>            optimizer<span style="color:#f92672">.</span>step()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Extract learned hyperparameters</span>
</span></span><span style="display:flex;"><span>        kernel_params <span style="color:#f92672">=</span> model<span style="color:#f92672">.</span>covar_module<span style="color:#f92672">.</span>base_kernel<span style="color:#f92672">.</span>lengthscale<span style="color:#f92672">.</span>item()
</span></span><span style="display:flex;"><span>        outputscale <span style="color:#f92672">=</span> model<span style="color:#f92672">.</span>covar_module<span style="color:#f92672">.</span>outputscale<span style="color:#f92672">.</span>item()
</span></span><span style="display:flex;"><span>        noise <span style="color:#f92672">=</span> likelihood<span style="color:#f92672">.</span>noise<span style="color:#f92672">.</span>item()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        hyperparameters<span style="color:#f92672">.</span>append([outputscale, kernel_params, noise])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> verbose:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Processed </span><span style="color:#e6db74">{</span>idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#e6db74">}</span><span style="color:#e6db74">/</span><span style="color:#e6db74">{</span>len(time_series)<span style="color:#e6db74">}</span><span style="color:#e6db74">: Symbol = </span><span style="color:#e6db74">{</span>symbols[idx]<span style="color:#e6db74">}</span><span style="color:#e6db74">, &#34;</span>
</span></span><span style="display:flex;"><span>                  <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Output Scale = </span><span style="color:#e6db74">{</span>outputscale<span style="color:#e6db74">:</span><span style="color:#e6db74">.3f</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, Length Scale = </span><span style="color:#e6db74">{</span>kernel_params<span style="color:#e6db74">:</span><span style="color:#e6db74">.3f</span><span style="color:#e6db74">}</span><span style="color:#e6db74">, noise = </span><span style="color:#e6db74">{</span>noise<span style="color:#e6db74">:</span><span style="color:#e6db74">.3f</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> verbose:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Finished Sparse Gaussian Process Regression.&#34;</span>)
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;Starting clustering on hyperparameters...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Perform clustering on hyperparameters</span>
</span></span><span style="display:flex;"><span>    hyperparameters <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(hyperparameters)
</span></span><span style="display:flex;"><span>    kmeans <span style="color:#f92672">=</span> KMeans(n_clusters<span style="color:#f92672">=</span>n_clusters, random_state<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    labels <span style="color:#f92672">=</span> kmeans<span style="color:#f92672">.</span>fit_predict(hyperparameters)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    clusters <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> cluster_id <span style="color:#f92672">in</span> range(n_clusters):
</span></span><span style="display:flex;"><span>        clusters[<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Cluster</span><span style="color:#e6db74">{</span>cluster_id<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>] <span style="color:#f92672">=</span> symbols[labels <span style="color:#f92672">==</span> cluster_id]<span style="color:#f92672">.</span>tolist()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> verbose:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Cluster </span><span style="color:#e6db74">{</span>cluster_id <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span><span style="color:#e6db74">}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{</span>len(clusters[<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Cluster</span><span style="color:#e6db74">{</span>cluster_id<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>])<span style="color:#e6db74">}</span><span style="color:#e6db74"> symbols&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> verbose:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Clustering complete. Summary:&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> cluster, symbols <span style="color:#f92672">in</span> clusters<span style="color:#f92672">.</span>items():
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>cluster<span style="color:#e6db74">}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{</span>symbols<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> clusters
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>df <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>read_csv(<span style="color:#e6db74">&#39;Quantitative_Research/model_new/bayesian_clustering/transposed_stock_data.csv&#39;</span>)
</span></span><span style="display:flex;"><span>clusters <span style="color:#f92672">=</span> sparse_gpr_hyperparameter_clustering(df, n_clusters<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, verbose<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>print(clusters)
</span></span></code></pre></div><h1 id="appendix">Appendix<a hidden class="anchor" aria-hidden="true" href="#appendix">#</a></h1>
<h2 id="broker-object">broker object<a hidden class="anchor" aria-hidden="true" href="#broker-object">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Broker</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, cash: float, feeRate: float, symbols: list):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>positions <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>wallet <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> symbol <span style="color:#f92672">in</span> symbols:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>wallet[symbol] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>cash <span style="color:#f92672">=</span> cash
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>feeRate <span style="color:#f92672">=</span> feeRate
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>totalFee <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>symbols <span style="color:#f92672">=</span> symbols
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>msg <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">buy</span>(self, price, symbol, vol):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># cash = self.cash</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if cash - price * vol * (1 + self.feeRate) &lt; 0:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#     # print(&#34;not enough cash, but amount that minus fees&#34;)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#     vol -= price * vol * self.feeRate / price</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>cash <span style="color:#f92672">-=</span> price <span style="color:#f92672">*</span> vol <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>feeRate)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>wallet[symbol] <span style="color:#f92672">+=</span> vol
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>totalFee <span style="color:#f92672">+=</span> price <span style="color:#f92672">*</span> vol <span style="color:#f92672">*</span> self<span style="color:#f92672">.</span>feeRate
</span></span><span style="display:flex;"><span>        msg <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Buy </span><span style="color:#e6db74">{</span>symbol<span style="color:#e6db74">}</span><span style="color:#e6db74"> at price: </span><span style="color:#e6db74">{</span>price<span style="color:#e6db74">}</span><span style="color:#e6db74"> for </span><span style="color:#e6db74">{</span>vol<span style="color:#e6db74">}</span><span style="color:#e6db74"> amount&#34;</span>
</span></span><span style="display:flex;"><span>        print(msg)
</span></span><span style="display:flex;"><span>        msg_dict <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;symbol&#34;</span>: symbol,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;price&#34;</span>: price,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;vol&#34;</span>: vol,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;action&#34;</span>: <span style="color:#e6db74">&#34;buy&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>msg<span style="color:#f92672">.</span>append(msg_dict)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sell</span>(self, price, symbol, vol):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>cash <span style="color:#f92672">+=</span> price <span style="color:#f92672">*</span> vol <span style="color:#f92672">*</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> self<span style="color:#f92672">.</span>feeRate)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>wallet[symbol] <span style="color:#f92672">-=</span> vol
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>totalFee <span style="color:#f92672">+=</span> price <span style="color:#f92672">*</span> vol <span style="color:#f92672">*</span> self<span style="color:#f92672">.</span>feeRate
</span></span><span style="display:flex;"><span>        msg <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Sell </span><span style="color:#e6db74">{</span>symbol<span style="color:#e6db74">}</span><span style="color:#e6db74"> at price: </span><span style="color:#e6db74">{</span>price<span style="color:#e6db74">}</span><span style="color:#e6db74"> for </span><span style="color:#e6db74">{</span>vol<span style="color:#e6db74">}</span><span style="color:#e6db74"> amount&#34;</span>
</span></span><span style="display:flex;"><span>        print(msg)
</span></span><span style="display:flex;"><span>        msg_dict <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;symbol&#34;</span>: symbol,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;price&#34;</span>: price,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;vol&#34;</span>: vol,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;action&#34;</span>: <span style="color:#e6db74">&#34;sell&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>msg<span style="color:#f92672">.</span>append(msg_dict)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_update_position</span>(self, symbol, price, vol, direction, time):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> symbol <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>positions:
</span></span><span style="display:flex;"><span>            position <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>positions[symbol]
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> position<span style="color:#f92672">.</span>direction <span style="color:#f92672">==</span> direction:
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># 加仓，计算新的加权平均价格</span>
</span></span><span style="display:flex;"><span>                new_volume <span style="color:#f92672">=</span> position<span style="color:#f92672">.</span>volume <span style="color:#f92672">+</span> vol
</span></span><span style="display:flex;"><span>                new_avg_price <span style="color:#f92672">=</span> (position<span style="color:#f92672">.</span>avg_price <span style="color:#f92672">*</span> position<span style="color:#f92672">.</span>volume <span style="color:#f92672">+</span> price <span style="color:#f92672">*</span> vol) <span style="color:#f92672">/</span> new_volume
</span></span><span style="display:flex;"><span>                position<span style="color:#f92672">.</span>avg_price <span style="color:#f92672">=</span> new_avg_price
</span></span><span style="display:flex;"><span>                position<span style="color:#f92672">.</span>volume <span style="color:#f92672">=</span> new_volume
</span></span><span style="display:flex;"><span>                position<span style="color:#f92672">.</span>time <span style="color:#f92672">=</span> time
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># 如果方向相反，考虑部分平仓或完全平仓的情况</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> abs(position<span style="color:#f92672">.</span>volume) <span style="color:#f92672">&gt;</span> vol:
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># 部分平仓</span>
</span></span><span style="display:flex;"><span>                    position<span style="color:#f92672">.</span>volume <span style="color:#f92672">-=</span> vol
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">elif</span> abs(position<span style="color:#f92672">.</span>volume) <span style="color:#f92672">==</span> vol:
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># 完全平仓，删除仓位</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">del</span> self<span style="color:#f92672">.</span>positions[symbol]
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e"># 平掉原仓位并开立新方向的仓位</span>
</span></span><span style="display:flex;"><span>                    new_vol <span style="color:#f92672">=</span> vol <span style="color:#f92672">-</span> abs(position<span style="color:#f92672">.</span>volume)
</span></span><span style="display:flex;"><span>                    position<span style="color:#f92672">.</span>direction <span style="color:#f92672">=</span> direction
</span></span><span style="display:flex;"><span>                    position<span style="color:#f92672">.</span>avg_price <span style="color:#f92672">=</span> price
</span></span><span style="display:flex;"><span>                    position<span style="color:#f92672">.</span>volume <span style="color:#f92672">=</span> new_vol
</span></span><span style="display:flex;"><span>                    position<span style="color:#f92672">.</span>time <span style="color:#f92672">=</span> time
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># 开立新仓位</span>
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>positions[symbol] <span style="color:#f92672">=</span> Position(time<span style="color:#f92672">=</span>time, avg_price<span style="color:#f92672">=</span>price, symbol<span style="color:#f92672">=</span>symbol, direction<span style="color:#f92672">=</span>direction,
</span></span><span style="display:flex;"><span>                                              volume<span style="color:#f92672">=</span>vol)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">long</span>(self, price, symbol, vol, leverage, time):
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        开立多头仓位，使用杠杆购买资产。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        :param price: 当前资产价格
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        :param symbol: 资产符号
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        :param vol: 购买的资产数量
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        :param leverage: 杠杆倍数
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        :param time: 当前时间
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        margin_required <span style="color:#f92672">=</span> (price <span style="color:#f92672">*</span> vol) <span style="color:#f92672">/</span> leverage
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if self.cash &lt; margin_required:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#     print(&#34;Not enough cash to open long position with leverage.&#34;)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#     return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>cash <span style="color:#f92672">-=</span> margin_required
</span></span><span style="display:flex;"><span>        fee <span style="color:#f92672">=</span> price <span style="color:#f92672">*</span> vol <span style="color:#f92672">*</span> self<span style="color:#f92672">.</span>feeRate
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>totalFee <span style="color:#f92672">+=</span> fee
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>_update_position(symbol, price, vol <span style="color:#f92672">*</span> leverage, <span style="color:#e6db74">&#39;long&#39;</span>, time)
</span></span><span style="display:flex;"><span>        msg <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Long </span><span style="color:#e6db74">{</span>symbol<span style="color:#e6db74">}</span><span style="color:#e6db74"> at price: </span><span style="color:#e6db74">{</span>price<span style="color:#e6db74">}</span><span style="color:#e6db74"> for </span><span style="color:#e6db74">{</span>vol<span style="color:#e6db74">}</span><span style="color:#e6db74"> amount with leverage </span><span style="color:#e6db74">{</span>leverage<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>        print(msg)
</span></span><span style="display:flex;"><span>        msg_dict <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;symbol&#34;</span>: symbol,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;price&#34;</span>: price,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;vol&#34;</span>: vol,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;action&#34;</span>: <span style="color:#e6db74">&#34;long&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>msg<span style="color:#f92672">.</span>append(msg_dict)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">short</span>(self, price, symbol, vol, leverage, time):
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        开立空头仓位，使用杠杆卖出资产。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        :param price: 当前资产价格
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        :param symbol: 资产符号
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        :param vol: 卖出的资产数量
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        :param leverage: 杠杆倍数
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        :param time: 当前时间
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        margin_required <span style="color:#f92672">=</span> (price <span style="color:#f92672">*</span> vol) <span style="color:#f92672">/</span> leverage
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if self.cash &lt; margin_required:</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#     print(&#34;Not enough cash to open short position with leverage.&#34;)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">#     return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>cash <span style="color:#f92672">-=</span> margin_required
</span></span><span style="display:flex;"><span>        fee <span style="color:#f92672">=</span> price <span style="color:#f92672">*</span> vol <span style="color:#f92672">*</span> self<span style="color:#f92672">.</span>feeRate
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>totalFee <span style="color:#f92672">+=</span> fee
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>_update_position(symbol, price, vol <span style="color:#f92672">*</span> leverage, <span style="color:#e6db74">&#39;short&#39;</span>, time)
</span></span><span style="display:flex;"><span>        msg <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Short </span><span style="color:#e6db74">{</span>symbol<span style="color:#e6db74">}</span><span style="color:#e6db74"> at price: </span><span style="color:#e6db74">{</span>price<span style="color:#e6db74">}</span><span style="color:#e6db74"> for </span><span style="color:#e6db74">{</span>vol<span style="color:#e6db74">}</span><span style="color:#e6db74"> amount with leverage </span><span style="color:#e6db74">{</span>leverage<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>        print(msg)
</span></span><span style="display:flex;"><span>        msg_dict <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;symbol&#34;</span>: symbol,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;price&#34;</span>: price,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;vol&#34;</span>: vol,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;action&#34;</span>: <span style="color:#e6db74">&#34;short&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>msg<span style="color:#f92672">.</span>append(msg_dict)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">cover_long</span>(self, price, symbol, vol, time):
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        平掉多头仓位。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        :param price: 当前资产价格
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        :param symbol: 资产符号
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        :param vol: 平仓的资产数量
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        :param time: 当前时间
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> symbol <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>positions <span style="color:#f92672">or</span> self<span style="color:#f92672">.</span>positions[symbol]<span style="color:#f92672">.</span>direction <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;long&#39;</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#34;No long position to cover.&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        fee <span style="color:#f92672">=</span> price <span style="color:#f92672">*</span> vol <span style="color:#f92672">*</span> self<span style="color:#f92672">.</span>feeRate
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>totalFee <span style="color:#f92672">+=</span> fee
</span></span><span style="display:flex;"><span>        position_worth <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>positions[symbol]<span style="color:#f92672">.</span>avg_price <span style="color:#f92672">*</span> vol
</span></span><span style="display:flex;"><span>        pnl <span style="color:#f92672">=</span> (price <span style="color:#f92672">-</span> self<span style="color:#f92672">.</span>positions[symbol]<span style="color:#f92672">.</span>avg_price) <span style="color:#f92672">*</span> vol
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>cash <span style="color:#f92672">+=</span> pnl <span style="color:#f92672">+</span> position_worth <span style="color:#f92672">-</span> fee
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>_update_position(symbol, price, vol, <span style="color:#e6db74">&#39;cover_long&#39;</span>, time)
</span></span><span style="display:flex;"><span>        msg <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Cover long </span><span style="color:#e6db74">{</span>symbol<span style="color:#e6db74">}</span><span style="color:#e6db74"> at price: </span><span style="color:#e6db74">{</span>price<span style="color:#e6db74">}</span><span style="color:#e6db74"> for </span><span style="color:#e6db74">{</span>vol<span style="color:#e6db74">}</span><span style="color:#e6db74"> amount&#34;</span>
</span></span><span style="display:flex;"><span>        print(msg)
</span></span><span style="display:flex;"><span>        msg_dict <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;symbol&#34;</span>: symbol,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;price&#34;</span>: price,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;vol&#34;</span>: vol,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;action&#34;</span>: <span style="color:#e6db74">&#34;cover long&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>msg<span style="color:#f92672">.</span>append(msg_dict)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">cover_short</span>(self, price, symbol, vol, time):
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        平掉空头仓位。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        :param price: 当前资产价格
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        :param symbol: 资产符号
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        :param vol: 平仓的资产数量
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        :param time: 当前时间
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> symbol <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>positions <span style="color:#f92672">or</span> self<span style="color:#f92672">.</span>positions[symbol]<span style="color:#f92672">.</span>direction <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;short&#39;</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#34;No short position to cover.&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        fee <span style="color:#f92672">=</span> price <span style="color:#f92672">*</span> vol <span style="color:#f92672">*</span> self<span style="color:#f92672">.</span>feeRate
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>totalFee <span style="color:#f92672">+=</span> fee
</span></span><span style="display:flex;"><span>        position_worth <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>positions[symbol]<span style="color:#f92672">.</span>avg_price <span style="color:#f92672">*</span> vol
</span></span><span style="display:flex;"><span>        pnl <span style="color:#f92672">=</span> (self<span style="color:#f92672">.</span>positions[symbol]<span style="color:#f92672">.</span>avg_price <span style="color:#f92672">-</span> price) <span style="color:#f92672">*</span> vol
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>cash <span style="color:#f92672">+=</span> pnl <span style="color:#f92672">+</span> position_worth <span style="color:#f92672">-</span> fee
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>_update_position(symbol, price, vol, <span style="color:#e6db74">&#39;cover_short&#39;</span>, time)
</span></span><span style="display:flex;"><span>        msg <span style="color:#f92672">=</span> <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Cover short </span><span style="color:#e6db74">{</span>symbol<span style="color:#e6db74">}</span><span style="color:#e6db74"> at price: </span><span style="color:#e6db74">{</span>price<span style="color:#e6db74">}</span><span style="color:#e6db74"> for </span><span style="color:#e6db74">{</span>vol<span style="color:#e6db74">}</span><span style="color:#e6db74"> amount&#34;</span>
</span></span><span style="display:flex;"><span>        print(msg)
</span></span><span style="display:flex;"><span>        msg_dict <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;symbol&#34;</span>: symbol,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;price&#34;</span>: price,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;vol&#34;</span>: vol,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;action&#34;</span>: <span style="color:#e6db74">&#34;cover short&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>msg<span style="color:#f92672">.</span>append(msg_dict)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">calculate_total_account_equity</span>(self, current_prices: dict):
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        计算当前账户的总净值，包括现金和所有持仓的浮动盈亏。
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        :param current_prices: dict，包含每个资产的当前价格，例如：{&#34;BTC&#34;: 40000, &#34;ETH&#34;: 3000}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        total_pnl <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        position_worth <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> symbol, position <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>positions<span style="color:#f92672">.</span>items():
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> symbol <span style="color:#f92672">in</span> current_prices:
</span></span><span style="display:flex;"><span>                current_price: BarData <span style="color:#f92672">=</span> current_prices[symbol]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> position<span style="color:#f92672">.</span>direction <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;long&#39;</span>:
</span></span><span style="display:flex;"><span>                    pnl <span style="color:#f92672">=</span> (current_price<span style="color:#f92672">.</span>close <span style="color:#f92672">-</span> position<span style="color:#f92672">.</span>avg_price) <span style="color:#f92672">*</span> position<span style="color:#f92672">.</span>volume
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">elif</span> position<span style="color:#f92672">.</span>direction <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;short&#39;</span>:
</span></span><span style="display:flex;"><span>                    pnl <span style="color:#f92672">=</span> (position<span style="color:#f92672">.</span>avg_price <span style="color:#f92672">-</span> current_price<span style="color:#f92672">.</span>close) <span style="color:#f92672">*</span> position<span style="color:#f92672">.</span>volume
</span></span><span style="display:flex;"><span>                position_worth <span style="color:#f92672">+=</span> position<span style="color:#f92672">.</span>volume <span style="color:#f92672">*</span> position<span style="color:#f92672">.</span>avg_price
</span></span><span style="display:flex;"><span>                total_pnl <span style="color:#f92672">+=</span> pnl
</span></span><span style="display:flex;"><span>        total_equity <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>cash <span style="color:#f92672">+</span> total_pnl <span style="color:#f92672">+</span> position_worth
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># print(f&#34;Total Account Equity: {total_equity:.2f} USD&#34;)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> total_equity
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_current_pos_profit_rate</span>(self, current_prices:dict):
</span></span><span style="display:flex;"><span>        total_pnl <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        position_worth <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> symbol, position <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>positions<span style="color:#f92672">.</span>items():
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> symbol <span style="color:#f92672">in</span> current_prices:
</span></span><span style="display:flex;"><span>                current_price: BarData <span style="color:#f92672">=</span> current_prices[symbol]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> position<span style="color:#f92672">.</span>direction <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;long&#39;</span>:
</span></span><span style="display:flex;"><span>                    pnl <span style="color:#f92672">=</span> (current_price<span style="color:#f92672">.</span>close <span style="color:#f92672">-</span> position<span style="color:#f92672">.</span>avg_price) <span style="color:#f92672">*</span> position<span style="color:#f92672">.</span>volume
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">elif</span> position<span style="color:#f92672">.</span>direction <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;short&#39;</span>:
</span></span><span style="display:flex;"><span>                    pnl <span style="color:#f92672">=</span> (position<span style="color:#f92672">.</span>avg_price <span style="color:#f92672">-</span> current_price<span style="color:#f92672">.</span>close) <span style="color:#f92672">*</span> position<span style="color:#f92672">.</span>volume
</span></span><span style="display:flex;"><span>                position_worth <span style="color:#f92672">+=</span> position<span style="color:#f92672">.</span>volume <span style="color:#f92672">*</span> position<span style="color:#f92672">.</span>avg_price
</span></span><span style="display:flex;"><span>                total_pnl <span style="color:#f92672">+=</span> pnl
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        profit_rate <span style="color:#f92672">=</span> total_pnl <span style="color:#f92672">/</span> position_worth
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> profit_rate
</span></span></code></pre></div><p><img alt="Alt text" loading="lazy" src="/images/Report.png"></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Bayesian Cointegration codes on x"
            href="https://x.com/intent/tweet/?text=Bayesian%20Cointegration%20codes&amp;url=https%3a%2f%2foldhuntor.github.io%2fposts%2fcodesnippets%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Bayesian Cointegration codes on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2foldhuntor.github.io%2fposts%2fcodesnippets%2f&amp;title=Bayesian%20Cointegration%20codes&amp;summary=Bayesian%20Cointegration%20codes&amp;source=https%3a%2f%2foldhuntor.github.io%2fposts%2fcodesnippets%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Bayesian Cointegration codes on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2foldhuntor.github.io%2fposts%2fcodesnippets%2f&title=Bayesian%20Cointegration%20codes">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Bayesian Cointegration codes on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2foldhuntor.github.io%2fposts%2fcodesnippets%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Bayesian Cointegration codes on whatsapp"
            href="https://api.whatsapp.com/send?text=Bayesian%20Cointegration%20codes%20-%20https%3a%2f%2foldhuntor.github.io%2fposts%2fcodesnippets%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Bayesian Cointegration codes on telegram"
            href="https://telegram.me/share/url?text=Bayesian%20Cointegration%20codes&amp;url=https%3a%2f%2foldhuntor.github.io%2fposts%2fcodesnippets%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Bayesian Cointegration codes on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Bayesian%20Cointegration%20codes&u=https%3a%2f%2foldhuntor.github.io%2fposts%2fcodesnippets%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://oldhuntor.github.io/">Xuanhao&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
